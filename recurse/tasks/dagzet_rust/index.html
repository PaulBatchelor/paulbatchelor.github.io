<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<link rel="stylesheet" href="/recurse/css/style.css">
<meta name="viewport" content="width=device-width,initial-scale=1" />
</head>
<body>
<div id="main">
<p><title>Port dagzet to rust</title>
<h1>Port dagzet to rust</h1>
task id: dagzet-rust
</p>
<p><a href="#2024_07_03_08_35" id="2024_07_03_08_35">2024-07-03 08:35</a>: I really need to rewrite dagzet #dagzet-rust</p>
<div class="comment-block">
<p>My lua implementation was always designed to just be a prototype, and nowadays it's getting quite heavy. Now that I'm a bit more familiar with the language, I don't think it'd be too difficult to build it in Rust, tbh. I think the standard library has enough rich data types that it should be pretty straightforward.
</p>
</div>
<p><a href="#2024_07_11_08_39" id="2024_07_11_08_39">2024-07-11 08:39</a>: Some initial boilerplate rust code would be nice to set up today if there's time #dagzet-rust</p>
<p><a href="#2024_07_12_08_14" id="2024_07_12_08_14">2024-07-12 08:14</a>: Did not get to this yesterday. Today maybe? #dagzet-rust</p>
<p><a href="#2024_07_12_09_16" id="2024_07_12_09_16">2024-07-12 09:16</a>: initial thoughts #dagzet-rust #timelog:00:18:23</p>
<div class="comment-block">
<p>My hope is that the lua implementatoin is trivial enough that I can bring it over to rust without too many complications. I will outline some of the broad strokes steps required to get this program up and running. 
</p>
<p> While writing these thoughts  
</p>
<p> The first thing I'll need to be able to do is read a file from disk, possibly entirely into memory. The dagzet parser works line by by line, so if there's some iterator abstraction that allows me be to do this, great. 
</p>
<p> For parsing commands, I need to be able to read the first three characters of each line to determine the command code. Commands are two characters followed by a space, with the rest of the line being being arguments. 
</p>
<p> Commands need to map to functions which can parse the argument data of that line, and potentially append or modifiy a rust data struct representing the graph being built up somehow. But, just setting up a convenient way to map commands to functions would be great. There will be quite a few, and I often find myself wanting to add more commands to meet my needs. I made use of Lua tables to create a look-up table of callbacks. Hopefully I can do a similar thing in Rust without too much fuss? 
</p>
<p> I need to be able to split data up by spaces. Lua does not have a built-in <code>split()</code> like you'd see in other languages. I'm hoping Rust standard library has one somewhere (this functionality should be standard not outsourced to a crate right? right?!) 
</p>
<p> I need a top-level data struct that can be populated with information that is parsed. I the lua implementation, I used tables: usually as a hashmap or array structure, sometimes an array of array. IIRC Rust STD has hashmaps, and vectors I think should be enough. I can't foresee too many ownership issues due to how imperative this is, but who knows. 
</p>
<p> I need to implement topological sort (Kahn's algorithm). My lua approach used node IDs instead of references, so I think this is going to be mostly Rust-friendly to port. Still, I get the feeling that I may be forgetting something that will be a pain point with Rust. 
</p>
<p> When it has been determined that the graph contains no cycles, generate the SQLite code to standard output. This seems pretty straight forward to me, more or less going through the generated struct (read-only) and printing equivalent SQLite code.
</p>
</div>
<p><a href="#2024_07_12_09_45" id="2024_07_12_09_45">2024-07-12 09:45</a>: Starting initial boilerplate code. #dagzet-rust #timelog:01:07:29 </p>
<p><a href="#2024_07_12_09_46" id="2024_07_12_09_46">2024-07-12 09:46</a>: get it to read lines of a file #dagzet-rust</p>
<div class="comment-block">
<p>Going to try to use neovim for this now. 
</p>
<p> tangent: trying to get auto-import working. Found: &lt;&lt;<a href="#">neovim/nvim_cmp</a>&gt;&gt;. 
</p>
<p> how to get this working with lazy, README only has vim-plug? 
</p>
<p> Wait, it's already installed, according to the Lazy control panel. What does InsertEnter mean? 
</p>
<p> Okay, I get the recommendations, but I don't know how to insert it. 
</p>
<p> Got it! Typing "File" then hitting ctrl-y does it. 
</p>
<br>
<br>
</div>
<p><a href="#2024_07_12_10_19" id="2024_07_12_10_19">2024-07-12 10:19</a>: haha. flopping around with rust compiler on trivial things. nailing it. #dagzet-rust</p>
<p><a href="#2024_07_12_10_24" id="2024_07_12_10_24">2024-07-12 10:24</a>: give it a file on the command line #dagzet-rust</p>
<p><a href="#2024_07_12_10_39" id="2024_07_12_10_39">2024-07-12 10:39</a>: Parse lines, find their command code. #dagzet-rust</p>
<p><a href="#2024_07_12_10_51" id="2024_07_12_10_51">2024-07-12 10:51</a>: That's some good enough boilerplate. #dagzet-rust</p>
<div class="comment-block">
<p>I have it parsing command codes in the test file, and there is some placeholder stuff where I can eventually do stuff with those commands.
</p>
</div>
<p><a href="#2024_07_15_08_45" id="2024_07_15_08_45">2024-07-15 08:45</a>: As it turns out, there was no time yesterday. #dagzet-rust</p>
<p><a href="#2024_07_15_09_50" id="2024_07_15_09_50">2024-07-15 09:50</a>: dagzet in rust today #dagzet-rust #timelog:01:24:57</p>
<p><a href="#2024_07_15_09_53" id="2024_07_15_09_53">2024-07-15 09:53</a>: Beginning initial top-level struct #dagzet-rust</p>
<div class="comment-block">
<p>Eventually this will be populated with data from the commands.
</p>
</div>
<p><a href="#2024_07_15_10_02" id="2024_07_15_10_02">2024-07-15 10:02</a>: Now would be a good time to figure out rust docstrings #dagzet-rust</p>
<div class="comment-block">
<p>Being able to add in-line descriptions of struct contents that get rendered to rust documentation would be helpful.
</p>
</div>
<p><a href="#2024_07_15_10_44" id="2024_07_15_10_44">2024-07-15 10:44</a>: namespace and graph remarks mostly figured out #dagzet-rust</p>
<div class="comment-block">
<p>I have a incremental TDD approach to porting this, which feels nice.
</p>
</div>
<p><a href="#2024_07_15_10_45" id="2024_07_15_10_45">2024-07-15 10:45</a>: Make use of =Option= to indicate uninitialized values #dagzet-rust</p>
<p><a href="#2024_07_15_11_14" id="2024_07_15_11_14">2024-07-15 11:14</a>: Better error handling, new node command incomplete #dagzet-rust</p>
<div class="comment-block">
<p>I'm making use of Result and putting return codes into a single Enum. This is just mirroring how I'd do it in C. Hopefully it's idiomatic enough in Rust.
</p>
</div>
<p><a href="#2024_07_15_15_49" id="2024_07_15_15_49">2024-07-15 15:49</a>: More work on dagzet in rust #dagzet-rust #timelog:00:35:58</p>
<p><a href="#2024_07_15_15_50" id="2024_07_15_15_50">2024-07-15 15:50</a>: Let's run clippy on my dagzet project so far #dagzet-rust</p>
<div class="comment-block">
<p>Turns out it doesn't have a lot to say. 
</p>
<p> Voxbox, on the other hand, is a mess.
</p>
</div>
<p><a href="#2024_07_15_16_19" id="2024_07_15_16_19">2024-07-15 16:19</a>: finished new node command, now lines. #dagzet-rust</p>
<p><a href="#2024_07_15_20_25" id="2024_07_15_20_25">2024-07-15 20:25</a>: back to dagzet #dagzet-rust #timelog:00:22:25</p>
<div class="comment-block">
<p>added a lines command. now I'm very tired.
</p>
</div>
<p><a href="#2024_07_17_16_06" id="2024_07_17_16_06">2024-07-17 16:06</a>: Attempting to implement connect #dagzet-rust #timelog:01:07:59</p>
<div class="comment-block">
<p>Connect adds a pair of edges to the graph. 
</p>
<p> These are set to be local connections. ID values work just fine here. 
</p>
<p> I'm curious about knowing how I did cx? Was that another structure? Am I checking cycles there? 
</p>
<p> cx is another structure and loops/cycles are not= being checked for.
</p>
</div>
<p><a href="#2024_07_17_16_37" id="2024_07_17_16_37">2024-07-17 16:37</a>: I think connections don't check for existing nodes until the end? #dagzet-rust</p>
<div class="comment-block">
<p>My original dagzet implementation reperesents the dagzet connections as strings that are only checked at the end of parsing when all the nodes have been added. Only then does it attempt to resolve the symbols. This makes for a more permissive parser. 
</p>
<p> My dagzet parser does the topological sort with the strings. I think it would be better to resolve those chunks into local ID values before the sort.
</p>
</div>
<p><a href="#2024_07_17_17_09" id="2024_07_17_17_09">2024-07-17 17:09</a>: Connections work, but unverified #dagzet-rust</p>
<div class="comment-block">
<p>This is intentional. Verifications are defferred until everything is parsed. Verification is beyond the responsibility of connection. 
</p>
<p> There is a linear check for already existing connections, and a test is put into place to make sure this is all properly caught.
</p>
</div>
<p><a href="#2024_07_17_17_13" id="2024_07_17_17_13">2024-07-17 17:13</a>: Shortcuts are not yet supported in co #dagzet-rust</p>
<div class="comment-block">
<p>Adding TODOs for that. 
</p>
<p> I've implemented enough today.
</p>
</div>
<p><a href="#2024_07_18_08_47" id="2024_07_18_08_47">2024-07-18 08:47</a>: dagzet could bea good portfolio project #dagzet-rust</p>
<div class="comment-block">
<p>It's got a good scope, it's got data structures, and I'm putting in the time to incrementally test as I go. 
</p>
<p> This is also a migration project. If I do this right, I should be able to drop in the dagzet program and have it replace my adhoc lua code for my knowledge tree generator, which I'm using to power the knowledge graph here.
</p>
</div>
<p><a href="#2024_07_18_09_34" id="2024_07_18_09_34">2024-07-18 09:34</a>: connection shortcuts #dagzet-rust #timelog:01:03:58</p>
<p><a href="#2024_07_18_09_39" id="2024_07_18_09_39">2024-07-18 09:39</a>: oh no, I'm getting my task tags wrong #dagzet-rust</p>
<p><a href="#2024_07_18_09_42" id="2024_07_18_09_42">2024-07-18 09:42</a>: back on track. #dagzet-rust</p>
<p><a href="#2024_07_18_10_00" id="2024_07_18_10_00">2024-07-18 10:00</a>: Reminding myself why string hashmaps are used for nodes #dagzet-rust</p>
<div class="comment-block">
<p>hashmaps are used as the data structure to ensure that a node isn't created twice. 
</p>
<p> if I wanted to get a node name from a string, how would I do that? Right now, the answer seems to be enumerate through all the keys and find an answer. I could also just make a separate inverse lookup table out of a vector.
</p>
</div>
<p><a href="#2024_07_18_10_20" id="2024_07_18_10_20">2024-07-18 10:20</a>: I made an inverse lookup table #dagzet-rust</p>
<div class="comment-block">
<p>It's a memory hit, and there's room for the eventual possibility that the tables will go out of sync. But, it's good enough for now. I imagine I'll be doing this lookup operatoin quite a few times I don't want to do a linear sweep every time.
</p>
</div>
<p><a href="#2024_07_18_10_50" id="2024_07_18_10_50">2024-07-18 10:50</a>: Up next: connection remarks #dagzet-rust</p>
<div class="comment-block">
<p>Variation on a theme, I suspect. Unplugging and getting lunch now.
</p>
</div>
</div>
</body>
</html>
