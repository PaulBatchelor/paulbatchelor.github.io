<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<link rel="stylesheet" href="/recurse/css/style.css">
<meta name="viewport" content="width=device-width,initial-scale=1" />
</head>
<body>
<div id="main">
<p><title>leetcode/references</title>
<h1>references</h1>
<a href="/recurse/dz">dz</a> / <a href="/recurse/dz/leetcode">leetcode</a> / <a href="/recurse/dz/leetcode/references">references</a>
<p></p>
<h2>Subgraphs</h2>
<ul>
<li><a href="/recurse/dz/leetcode/references/binary_tree">binary_tree</a></li>
<li><a href="/recurse/dz/leetcode/references/tree_traversal">tree_traversal</a></li>
</ul>
<h2>Node Tree</h2>
<ul>
<li>
<a href=#abstract_data_type>abstract_data_type</a><ul>
<li>
<a href=#stack>stack</a></li>
</ul>
</li>
<li>
<a href=#algorithmic_paradigm>algorithmic_paradigm</a></li>
<li>
<a href=#associative_array>associative_array</a><ul>
<li>
<a href=#hash_table>hash_table</a></li>
</ul>
</li>
<li>
<a href=#backtracking>backtracking</a></li>
<li>
<a href=#binary_search>binary_search</a><ul>
<li>
<a href=#sorted_array>sorted_array</a></li>
</ul>
</li>
<li>
<a href=#binary_search_java>binary_search_java</a></li>
<li>
<a href=#binary_search_leetcode>binary_search_leetcode</a></li>
<li>
<a href=#binary_search_tree>binary_search_tree</a></li>
<li>
<a href=#binary_tree>binary_tree</a></li>
<li>
<a href=#bottom_up_top_down>bottom_up_top_down</a></li>
<li>
<a href=#boyer_moore_majority_vote_algorithm>boyer_moore_majority_vote_algorithm</a></li>
<li>
<a href=#breadth_first_search>breadth_first_search</a></li>
<li>
<a href=#combinatorial_optimization>combinatorial_optimization</a><ul>
<li>
<a href=#knapsack_problem>knapsack_problem</a></li>
</ul>
</li>
<li>
<a href=#depth_first_search>depth_first_search</a></li>
<li>
<a href=#disjoint_data_set>disjoint_data_set</a></li>
<li>
<a href=#dynamic_programming>dynamic_programming</a></li>
<li>
<a href=#floyds_algorithm>floyds_algorithm</a><ul>
<li>
<a href="/recurse/dz/leetcode/problems#876_middle_of_linked_list">leetcode/problems/876_middle_of_linked_list</a></li>
</ul>
</li>
<li>
<a href=#greedy_algorithm>greedy_algorithm</a></li>
<li>
<a href=#linked_list>linked_list</a></li>
<li>
<a href=#lowest_common_ancestor>lowest_common_ancestor</a></li>
<li>
<a href=#maximum_subarray_problem>maximum_subarray_problem</a><ul>
<li>
<a href=#kadanes>kadanes</a></li>
</ul>
</li>
<li>
<a href=#opionated_guide_binary_search>opionated_guide_binary_search</a></li>
<li>
<a href=#optimal_substructure>optimal_substructure</a><ul>
<li>
<a href=#recurrence_relation>recurrence_relation</a></li>
</ul>
</li>
<li>
<a href=#optimization_problem>optimization_problem</a><ul>
<li>
<a href=#candidate_solution>candidate_solution</a></li>
</ul>
</li>
<li>
<a href=#prefix_sum>prefix_sum</a></li>
<li>
<a href=#queues>queues</a></li>
<li>
<a href=#tail_call>tail_call</a></li>
<li>
<a href=#tree_traversal>tree_traversal</a></li>
<li>
<a href=#two_pointer_technique>two_pointer_technique</a></li>
</ul>
<h2>Nodes</h2>
<table border="1px">
<tr>
<td colspan=2>
<a href=#optimization_problem>optimization_problem</a><a id="optimization_problem"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Optimization Problem (Computer Science): the problem of finding the best solution from all feasible solutions.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#candidate_solution>candidate_solution</a> (the "best solution" is a candidate solution)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href="/recurse/dz/leetcode/problems#322_coin_change">leetcode/problems/322_coin_change</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Optimization_problem">https://en.wikipedia.org/wiki/Optimization_problem</a>
</td>
</tr>
<tr>
<td>
flashcard (front)
</td>
<td>
What is an optimization problem?
</td>
</tr>
<tr>
<td>
flashcard (back)
</td>
<td>
the problem of finding the best solution from all feasible solutions.
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#candidate_solution>candidate_solution</a><a id="candidate_solution"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Candidate solution: member of the set of possible solutions in the feasible region of given problems.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#optimization_problem>optimization_problem</a>
</td>
</tr>
<tr>
<td>
flashcard (front)
</td>
<td>
What is a candidate solution?
</td>
</tr>
<tr>
<td>
flashcard (back)
</td>
<td>
A candidate solution is a solution in the feasible region of given problems.
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#optimal_substructure>optimal_substructure</a><a id="optimal_substructure"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Optimal Substructure: in computer sience, a problem is said to have optimal substructure if an optimal solution can be constructed from optimal solutions of its subproblems.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#recurrence_relation>recurrence_relation</a> (used to represent optimal substructure)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href="/recurse/dz/leetcode/paradigms#dynamic_programming">leetcode/paradigms/dynamic_programming</a>, <a href="/recurse/dz/leetcode/problems#322_coin_change">leetcode/problems/322_coin_change</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Optimal_substructure">https://en.wikipedia.org/wiki/Optimal_substructure</a>
</td>
</tr>
<tr>
<td>
flashcard (front)
</td>
<td>
What is optimal substructure?
</td>
</tr>
<tr>
<td>
flashcard (back)
</td>
<td>
Optimal substructure is a property of a problem where an optimal solution can be constructed from optimal solutions of its subproblems.
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#recurrence_relation>recurrence_relation</a><a id="recurrence_relation"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Recurrence Relation: In mathematics, a recurrence relation is an equation according to which the n  nth term of a sequence of numbers is equal  to some combination of the previous terms.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#optimal_substructure>optimal_substructure</a>, <a href="/recurse/dz/leetcode/problems#322_coin_change">leetcode/problems/322_coin_change</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Recurrence_relation">https://en.wikipedia.org/wiki/Recurrence_relation</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#bottom_up_top_down>bottom_up_top_down</a><a id="bottom_up_top_down"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Bottom-up and Top-down design: are both strategies of  information processing and ordering knowledge, used in a  variety of fields including software, humanistic and  scientific theories (see systemics), and management and  organization. In practice they can be seen as a style of  thinking, teaching, or leadership. 
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href="/recurse/dz/leetcode/paradigms#dynamic_programming">leetcode/paradigms/dynamic_programming</a>, <a href="/recurse/dz/leetcode/problems#322_coin_change">leetcode/problems/322_coin_change</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Bottom%E2%80%93up_and_top%E2%80%93down_design">https://en.wikipedia.org/wiki/Bottom%E2%80%93up_and_top%E2%80%93down_design</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#dynamic_programming>dynamic_programming</a><a id="dynamic_programming"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Dynamic Programming: A mathematicl optimization method and an algorithmic paradigm.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href="/recurse/dz/leetcode/paradigms#dynamic_programming">leetcode/paradigms/dynamic_programming</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Dynamic_programming">https://en.wikipedia.org/wiki/Dynamic_programming</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#algorithmic_paradigm>algorithmic_paradigm</a><a id="algorithmic_paradigm"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Algorithmic Paradigm: An algorithmic paradigm is a generic model or framework which underlies the design of a class of algorithms.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href="/recurse/dz/leetcode/paradigms#algorithmic_paradigm">leetcode/paradigms/algorithmic_paradigm</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Algorithmic_paradigm">https://en.wikipedia.org/wiki/Algorithmic_paradigm</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#prefix_sum>prefix_sum</a><a id="prefix_sum"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Prefix Sum
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href="/recurse/dz/leetcode/problems#643_maximum_average_subarray">leetcode/problems/643_maximum_average_subarray</a>, <a href="/recurse/dz/leetcode/problems#238_product_of_array_except_self">leetcode/problems/238_product_of_array_except_self</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Prefix_sum">https://en.wikipedia.org/wiki/Prefix_sum</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#binary_search_tree>binary_search_tree</a><a id="binary_search_tree"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Binary Search Tree
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href="/recurse/dz/leetcode/data_structures#binary_search_tree">leetcode/data_structures/binary_search_tree</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Binary_search_tree">https://en.wikipedia.org/wiki/Binary_search_tree</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#tree_traversal>tree_traversal</a><a id="tree_traversal"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
tree traversal
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Tree_traversal">https://en.wikipedia.org/wiki/Tree_traversal</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#depth_first_search>depth_first_search</a><a id="depth_first_search"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Depth-First-Search (DFS)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href="/recurse/dz/leetcode/paradigms#depth_first_search">leetcode/paradigms/depth_first_search</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Depth-first_search">https://en.wikipedia.org/wiki/Depth-first_search</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#disjoint_data_set>disjoint_data_set</a><a id="disjoint_data_set"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Disjoint Data Set: a data structure that stores a collection of disjoint (non-overlapping) sets.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href="/recurse/dz/leetcode/problems#200_number_of_islands">leetcode/problems/200_number_of_islands</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">https://en.wikipedia.org/wiki/Disjoint-set_data_structure</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#breadth_first_search>breadth_first_search</a><a id="breadth_first_search"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Bread-first search (BFS)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href="/recurse/dz/leetcode/paradigms#breadth_first_search">leetcode/paradigms/breadth_first_search</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Breadth-first_search">https://en.wikipedia.org/wiki/Breadth-first_search</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#binary_search>binary_search</a><a id="binary_search"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Binary Search: algorithm that finds the position of a target value in a sorted array.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#sorted_array>sorted_array</a> (sorted array is the data structure used in binary search)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href="/recurse/dz/leetcode/paradigms#binary_search">leetcode/paradigms/binary_search</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Binary_search">https://en.wikipedia.org/wiki/Binary_search</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#binary_search_java>binary_search_java</a><a id="binary_search_java"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Binary Search code snippet in Java, with with code comments
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href="/recurse/dz/leetcode/paradigms#binary_search">leetcode/paradigms/binary_search</a>
</td>
</tr>
<tr>
<td>
remarks
</td>
<td>
Recommended by EV
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://algs4.cs.princeton.edu/11model/BinarySearch.java.html">https://algs4.cs.princeton.edu/11model/BinarySearch.java.html</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#sorted_array>sorted_array</a><a id="sorted_array"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Sorted Array: an array data structure where each element is sorted in numerical, alphabetical, or some other order.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#binary_search>binary_search</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Sorted_array">https://en.wikipedia.org/wiki/Sorted_array</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#opionated_guide_binary_search>opionated_guide_binary_search</a><a id="opionated_guide_binary_search"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
An opinionated guide to binary search
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href="/recurse/dz/leetcode/paradigms#binary_search">leetcode/paradigms/binary_search</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://leetcode.com/discuss/study-guide/2371234/An-opinionated-guide-to-binary-search-">https://leetcode.com/discuss/study-guide/2371234/An-opinionated-guide-to-binary-search-</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#backtracking>backtracking</a><a id="backtracking"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Backtracking
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href="/recurse/dz/leetcode/paradigms#backtracking">leetcode/paradigms/backtracking</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Backtracking">https://en.wikipedia.org/wiki/Backtracking</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#knapsack_problem>knapsack_problem</a><a id="knapsack_problem"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Knapsack problem: given a set of items, each with a  weight and a value, determine which items to include in  the collection so that the total weight is less than or  equal to a given limit and the total value is as large  as possible.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#combinatorial_optimization>combinatorial_optimization</a>, <a href="/recurse/dz/leetcode/problems#39_combination_sum">leetcode/problems/39_combination_sum</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Knapsack_problem">https://en.wikipedia.org/wiki/Knapsack_problem</a>
</td>
</tr>
<tr>
<td>
flashcard (front)
</td>
<td>
What is the knapsack problem?
</td>
</tr>
<tr>
<td>
flashcard (back)
</td>
<td>
The knapsack problem can be described as: given a set of items, each with a weight and a value, determine which items to include in the collection so that the total weight is less than or equal to a given limit and the total value is as large as possible.
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#combinatorial_optimization>combinatorial_optimization</a><a id="combinatorial_optimization"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Combinatorial optimization is a subfield of mathematical  optimization that consists of finding an optimal object  from a finite set of objects,[1] where the set of  feasible solutions is discrete or can be reduced to a  discrete set.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#knapsack_problem>knapsack_problem</a> (knapsack problem is a problem in combinatorial optimization)
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Combinatorial_optimization">https://en.wikipedia.org/wiki/Combinatorial_optimization</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#binary_search_leetcode>binary_search_leetcode</a><a id="binary_search_leetcode"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Binary Search Leetcode explore card
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href="/recurse/dz/leetcode/paradigms#binary_search">leetcode/paradigms/binary_search</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://leetcode.com/explore/learn/card/binary-search/">https://leetcode.com/explore/learn/card/binary-search/</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#hash_table>hash_table</a><a id="hash_table"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
A hash table is a data structure that implements an associative array, also called a dictionary or map.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href="/recurse/dz/leetcode/data_structures#hash_table">leetcode/data_structures/hash_table</a>, <a href=#associative_array>associative_array</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Hash_table">https://en.wikipedia.org/wiki/Hash_table</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#associative_array>associative_array</a><a id="associative_array"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
associative array: an abstract data type that stores a collection of key-value pairs, such that each possible key appears at most once in the collection.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#hash_table>hash_table</a> (a hash table implements an associative array)
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Associative_array">https://en.wikipedia.org/wiki/Associative_array</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#abstract_data_type>abstract_data_type</a><a id="abstract_data_type"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
abstract data type: mathematical model for data types, defined by its behavior (semantics) from the point of view of a user of the data, specifically in terms of possible values, possible operations on the data of this type, and the behavior of these operations.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#stack>stack</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Abstract_data_type">https://en.wikipedia.org/wiki/Abstract_data_type</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#stack>stack</a><a id="stack"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Stack (abstract data type)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#abstract_data_type>abstract_data_type</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">https://en.wikipedia.org/wiki/Stack_(abstract_data_type)</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#linked_list>linked_list</a><a id="linked_list"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
linked list
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href="/recurse/dz/leetcode/data_structures#linked_list">leetcode/data_structures/linked_list</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Linked_list">https://en.wikipedia.org/wiki/Linked_list</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#maximum_subarray_problem>maximum_subarray_problem</a><a id="maximum_subarray_problem"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Maximum Subarray problem
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#kadanes>kadanes</a> (used to solve maximum subarray problem)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href="/recurse/dz/leetcode/problems#121_best_time_to_sell_and_buy_stock">leetcode/problems/121_best_time_to_sell_and_buy_stock</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem">https://en.wikipedia.org/wiki/Maximum_subarray_problem</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#kadanes>kadanes</a><a id="kadanes"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Kadane's algorithm
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href="/recurse/dz/leetcode/problems#121_best_time_to_sell_and_buy_stock">leetcode/problems/121_best_time_to_sell_and_buy_stock</a>, <a href=#maximum_subarray_problem>maximum_subarray_problem</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Maximum_subarray_problem#Kadane's_algorithm">https://en.wikipedia.org/wiki/Maximum_subarray_problem#Kadane's_algorithm</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#greedy_algorithm>greedy_algorithm</a><a id="greedy_algorithm"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Greedy Algorithm
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href="/recurse/dz/leetcode/paradigms#greedy">leetcode/paradigms/greedy</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Greedy_algorithm">https://en.wikipedia.org/wiki/Greedy_algorithm</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#two_pointer_technique>two_pointer_technique</a><a id="two_pointer_technique"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Two-Pointer Technique (leetcode)
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://leetcode.com/articles/two-pointer-technique/">https://leetcode.com/articles/two-pointer-technique/</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#lowest_common_ancestor>lowest_common_ancestor</a><a id="lowest_common_ancestor"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Lowest Common Ancestor: the LCA of two nodes v and w in a tree or DAG is the lowest node that has both v and w as descendants, where we define each node to be a descendant of itself
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href="/recurse/dz/leetcode/problems#235_lowest_common_ancestor_BST">leetcode/problems/235_lowest_common_ancestor_BST</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">https://en.wikipedia.org/wiki/Lowest_common_ancestor</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#binary_tree>binary_tree</a><a id="binary_tree"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Binary Tree: tree data structure in which a node has at most two children: a left child and a right child.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href="/recurse/dz/leetcode/data_structures#binary_tree">leetcode/data_structures/binary_tree</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Binary_tree">https://en.wikipedia.org/wiki/Binary_tree</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#floyds_algorithm>floyds_algorithm</a><a id="floyds_algorithm"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Floyd's Cycle Finding Algorithm
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href="/recurse/dz/leetcode/problems#876_middle_of_linked_list">leetcode/problems/876_middle_of_linked_list</a> (the fast/slow pointer trick made me think of floyd's algorithm)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href="/recurse/dz/leetcode/problems#287_find_the_duplicate_number">leetcode/problems/287_find_the_duplicate_number</a>, <a href="/recurse/dz/leetcode/data_structures#linked_list">leetcode/data_structures/linked_list</a>, <a href="/recurse/dz/leetcode/problems#141_linked_list_cycle">leetcode/problems/141_linked_list_cycle</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Cycle_detection#Floyd's_tortoise_and_hare">https://en.wikipedia.org/wiki/Cycle_detection#Floyd's_tortoise_and_hare</a>
</td>
</tr>
<tr>
<td>
flashcard (front)
</td>
<td>
Describe Floyd's algorithm
</td>
</tr>
<tr>
<td>
flashcard (back)
</td>
<td>
Floyd's algorithm can be used for cycle detection in linked lists (think tortois and hare). You a slow pointer a fast pointer. If there's a cycle, the fast pointer will eventually lap the fast pointer.
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#queues>queues</a><a id="queues"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Queue (Abstract Data Type)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href="/recurse/dz/leetcode/data_structures#queue">leetcode/data_structures/queue</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)">https://en.wikipedia.org/wiki/Queue_(abstract_data_type)</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#boyer_moore_majority_vote_algorithm>boyer_moore_majority_vote_algorithm</a><a id="boyer_moore_majority_vote_algorithm"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Boyer-Moore majority vote algorithm
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href="/recurse/dz/leetcode/problems#169_majority_element">leetcode/problems/169_majority_element</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm">https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#tail_call>tail_call</a><a id="tail_call"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
tail call: subroutine performed as the final action of a procedure
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href="/recurse/dz/leetcode/problems#104_max_depth_binary_tree">leetcode/problems/104_max_depth_binary_tree</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Tail_call">https://en.wikipedia.org/wiki/Tail_call</a>
</td>
</tr>
</table><br>
</p>
</div>
</body>
</html>
