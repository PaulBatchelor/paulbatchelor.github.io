<html>
<title>talkbox</title>
<head>
<link rel="stylesheet" href="css/skeleton.css">
<link rel="stylesheet" href="css/normalize.css">
</head>
<body>
<div class="container">
<i><h1>talkbox</h1></i>
<div class="row">
Files: <i>talkbox.h, talkbox.c</i></div>
<div class="row"><br></div>
A high talkbox emulation, simular to a vocoder.
This is the talkbox plugin ported from the MDA plugin suite. In many ways,
this Talkbox functions like a vocoder: it takes in a source signal (usually
speech), which then excites an excitation signal 
(usually a harmonically rich signal like a saw wave). This particular algorithm
uses linear-predictive coding (LPC), making speech intelligibility better 
than most vocoder implementations.

<div class="row"><br></div>
<div class="row">
<div class="row">
<h2>Functions</h2></div>
</div>
<div class="row">
sp_talkbox_create(sp_talkbox **talkbox)
</div>
<div class="row">
sp_talkbox_init(sp_data *sp, sp_talkbox *talkbox)
</div>
<div class="row">
sp_talkbox_compute(sp_data *sp, sp_talkbox *talkbox, SPFLOAT *source, SPFLOAT *excitation, SPFLOAT *out)
</div>
<div class="row">
sp_talkbox_destroy(sp_talkbox **talkbox)
</div>
<div class="row"><br></div>
<div class="row">
<h2>Optional Parameters</h2></div>
<div class="row">
<i>quality:</i> Quality of the talkbox sound. 0=lowest fidelity. 1=highest fidelity</div>
<div class="row">

(Default value: 1)
</div>
<div class="row"><br></div>

<div class="row">
<h2>Inputs</h2></div>
<div class="row">
<i>source:</i> Input signal that shapes the excitation. Also known as the modulator.
</div>
<div class="row">
<i>excitation:</i> The signal to be excited. Also known as the carrier.
</div>
<div class="row"><br></div>
<div class="row">
<h2>Outputs</h2></div>
<div class="row">
<i>out:</i> Talkbox signal output.
</div>
<div class="row"><br></div>
<div class="row">
<h2>Example Code</h2></div>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include "soundpipe.h"

#define NOSC 5

typedef struct {
    sp_talkbox *talkbox;
    sp_blsaw *saw[NOSC];
    sp_diskin *diskin;
} UserData;

static int chord[] = {48, 51, 55, 60, 70};

void process(sp_data *sp, void *udata) {
    UserData *ud = udata;
    SPFLOAT tmp;
    int i;
    SPFLOAT src = 0;
    SPFLOAT exc = 0;
    SPFLOAT talkbox = 0;

    exc = 0;
    for(i = 0; i &lt; NOSC; i++) {
		sp_blsaw_compute(sp, ud-&gt;saw[i], NULL, &tmp);
		exc += tmp;
    }
    sp_diskin_compute(sp, ud-&gt;diskin, NULL, &src);
    src *= 0.5;
    sp_talkbox_compute(sp, ud-&gt;talkbox, &src, &exc, &talkbox);
    sp_out(sp, 0, talkbox);
}

int main() {
    UserData ud;
    sp_data *sp;
    int i;
    sp_create(&sp);
    sp_srand(sp, 1234567);

    sp_diskin_create(&ud.diskin);
	sp_talkbox_create(&ud.talkbox);
	sp_talkbox_init(sp, ud.talkbox);
	ud.talkbox-&gt;quality = 0.2;

	for(i = 0; i &lt; NOSC; i++) {
		sp_blsaw_create(&ud.saw[i]);
		sp_blsaw_init(sp, ud.saw[i]);
		*ud.saw[i]-&gt;freq = sp_midi2cps(chord[i]);
		*ud.saw[i]-&gt;amp = 0.1;
    }

    sp_diskin_init(sp, ud.diskin, "oneart.wav");

    sp-&gt;len = 44100 * 8;
    sp_process(sp, &ud, process);

    sp_talkbox_destroy(&ud.talkbox);
    for(i = 0; i &lt; NOSC; i ++) {
		sp_blsaw_destroy(&ud.saw[i]);
    }
    sp_diskin_destroy(&ud.diskin);

    sp_destroy(&sp);
    return 0;
}
</code></pre></div></body></html>
