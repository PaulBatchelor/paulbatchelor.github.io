<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/brain/css/style.css">

</head>
<body>
<div id="main">
<title>Glossary</title>
<h1>Glossary</h1>
<p>Specially formatted messages tagged with the @glossary
label. Format should be word:definition.
</p>
<p><b>ALU</b>: arithmetic logic unit.
</p>
<p><b>AMD</b>: Advanced Micro Devices.
</p>
<p><b>Amdahl's Law</b>: states that when increasing the speed of one part of the system, the effect on the overall system performance depends on both how significant this part was and how much it sped up.
</p>
<p><b>CPU</b>: central processing unit. the engine that interprets (or executes) instructions stored in main memory.
</p>
<p><b>Closure</b>: A function-like constant you can store in a variable.
</p>
<p><b>DMA</b>: direct memory access.
</p>
<p><b>DRAM</b>: dynamic random access memory.
</p>
<p><b>ISA</b>: instruction set architecture.
</p>
<p><b>Iterators</b>: a way of processing a series of elements
</p>
<p><b>L1 cache</b>: Cache that tens of thousands of bytes long, and can be accesed nearly as fast at the register file.
</p>
<p><b>L2 cache</b>: cache that is larger than L1 cache, with hundreds of thousands to millions of bytes and is connected to the processor by a special bus. It can be 5x slower than the L1 cache.
</p>
<p><b>SipHash</b>: default hash used in Rust, designed to be resilient against DoS attacks. This algorithm is a tradeoff of security over performance.
</p>
<p><b>abstraction barriers</b>: being able to isolate different levels of a system using abstraction.
</p>
<p><b>applicative-order evaluation</b>: an evaluation method that evaluates the arguments and then applies. this is the method that the scheme interpreter uses.
</p>
<p><b>articulatory inversion</b>: the process of taking acoustic data and converting it back into vocal tract shapes.
</p>
<p><b>backtrace</b>: a list of all the functions that have been called to get to this point.
</p>
<p><b>blanket implementations</b>: implementations of a trait on any type that satisfies the trait bounds.
</p>
<p><b>buses</b>: a collection of electrical conduits that carry bytes of information back and forth between components.
</p>
<p><b>cache memory</b>: smaller and faster storage devices that serve as temporary staging areas for information that the processor is likely to need in the near future.
</p>
<p><b>case analysis</b>: a special form in lisp that can make tests and perform different operations depending on the result of the test.
</p>
<p><b>clause</b>: in lisp, a parenthesized pair of expressions that follow the cond symbol.
</p>
<p><b>combinations</b>: expressions in lisp formed by delimiting a list of expression within parentheses in order to denote procedure application.
</p>
<p><b>concurrently</b>: instructions of one process are interleaved with the instructions of another process.
</p>
<p><b>consequent expression</b>: the value of the corresponding expression associated with a predicate that is true. used in conditional expressions.
</p>
<p><b>consuming adaptors</b>: in the context of iterators, methods that use up the iterator when called. Methods that call "next" on an iterator are consuming adaptors.
</p>
<p><b>context switching</b>: the mechanism that the OS uses to interleave instructions from multiple processes.
</p>
<p><b>context</b>: the state information that the process needs in order to run.
</p>
<p><b>controller/adapter</b>: the means by which an IO device is connected to the IO bus. The distinction between a controller or an adapter is mainly one of packaging.
</p>
<p><b>correctness</b>: the extent to which code does what it is intended to do.
</p>
<p><b>crate root</b>: source file that the rust compiler starts from and makes up the root module of your crate.
</p>
<p><b>crate</b>: a binary or library.
</p>
<p><b>create a new library restaurant</b>: <code>cargo new --lib restaurant</code>.
</p>
<p><b>deferred operations</b>: in recursion, operations that are created while a process expands an expression, and are performed during the contraction.
</p>
<p><b>documentation comment</b>: in Rust, a particular comment format used for inline code documentation.
</p>
<p><b>effective address</b>: in assembly, this is the computed address used to access a particular part of memory.
</p>
<p><b>environment</b>: some sort of memory in the interpreter that keeps track of name-object pairs. more precisely called the global environment.
</p>
<p><b>file</b>: a sequence of bytes. nothing more. nothing less.
</p>
<p><b>functional programming</b>: programming without assignment (SICP).
</p>
<p><b>grapheme cluster</b>: a unit of measurement for strings in Rust. A close analagy would be a letter. Things like Devanagari script that use diacritics can have grapheme clusters with a variable number of bytes.
</p>
<p><b>hyperthreading</b>: a method to run two programs simultaneously on a single processor. First introduced in the x86 line with the Pentium 4E processor in 2004.
</p>
<p><b>imperative description</b>: "what" description. mathematics are concerned with this (vs "how to").
</p>
<p><b>imperative descriptions</b>: how-to descriptions. computer scientists are usually concerned with this (vs "what is").
</p>
<p><b>imperitive programming</b>: programming that makes extensive use of assignment. (SICP)
</p>
<p><b>integration tests</b>: check that many parts of the library work together correctly. Use the library's public API similar to how external code will use it.
</p>
<p><b>iterative process</b>: a process whose state can be summarized by a fixed number of state variables, together with a fixed rule that describes how the state variables should be updated as the process moves from state to state and an optional end test that specifies conditions under which the process should terminate.
</p>
<p><b>iterator adapter</b>: other methods in the Iterator struct that allow you to change iterators into different kinds of iterators.
</p>
<p><b>lazy evaluation</b>: also known as memoization, the ability for a closure to compute a value only when needed to, and to other wise use a cached value.
</p>
<p><b>lifetime</b>: the scope for which a reference is valid.
</p>
<p><b>lifetimes</b>: a generic in Rust that ensure that references are valid as long as they are needed to be.
</p>
<p><b>linear iterative process</b>: an interative process whose growth is linear.
</p>
<p><b>linear recursive process</b>: a recursive process that keeps track of a chain of deferred operations. This chain has linear growth.
</p>
<p><b>locality</b>: the tendency for programs to access data and code in localized regions.
</p>
<p><b>main memory</b>: a temporary storage device that holds both a program and the data it manipulates while the processor is executing the program.
</p>
<p><b>means of abstraction</b>: compound elements can be named and manipulated as units
</p>
<p><b>means of combination</b>: compound elements are built from simpler ones.
</p>
<p><b>memory hierarchy</b>: the way a computer system organizes memory by performance. moving from top to bottom, devices become slower, larger, and less costly per byte.
</p>
<p><b>message passing</b>: a style of programming found in languages such as LISP/Scheme which involve the ability to manipulate procedures as objects (which automatically provies the ability to represent compound data).
</p>
<p><b>modules (rust)</b>: thing that organizes code within a crate into groups for readability and easy reuse.
</p>
<p><b>monomorphization</b>: the process of turning generic code into specific code by filling in the concrete types that are used when compiled.
</p>
<p><b>motherboard</b>: systems main printed circuit board.
</p>
<p><b>nested</b>: to have combinations whose elements are themselves combinations.
</p>
<p><b>normal order evaluation</b>: an evaluation method that fully expands and then reduces.
</p>
<p><b>operand</b>: the other elements following the operator.
</p>
<p><b>operating system</b>: the layer of software interposed between the application program and the hardware.
</p>
<p><b>operator</b>: the leftmost element in the list.
</p>
<p><b>order of growth</b>: a notion used to describe the rate at which a process consumes computational resources. This is obtained via the gross measure of resources required by a process as the inputs become larger.
</p>
<p><b>package</b>: one or more crates that provide a set of functionality.
</p>
<p><b>parity flag</b>: in x86-64, a 1-bit flag that is set after an arithmetic or logical operation. PF is 1 when the lower 8 bits have an even number of 1s, 0 otherwise. This information is not directly accessible in C and requires machien-dependent assembly code.
</p>
<p><b>predicate</b>: procedures that return true or false.
</p>
<p><b>prefix notation</b>: convention of placing operator to the left of the operands.
</p>
<p><b>pretty-printing</b>: a formatting convention in which each long combination is written so that the operands are aligned vertically.
</p>
<p><b>primitive expression</b>: the simplest entities the language is concerned with.
</p>
<p><b>primitive obsession</b>: using primitive values when a complex type would be more appopriate.
</p>
<p><b>privacy (rust)</b>: in the context of modules, the determination whether an item can be used by outside code (public) or not.
</p>
<p><b>privacy boundary</b>: the line that encapsulates the implementation details isn't allowed to know about, or rely on.
</p>
<p><b>procedure definitions</b>: a compound operation that can be given a name and then referred as a unit.
</p>
<p><b>process</b>: the operating system's abstraction for a running program.
</p>
<p><b>processor-memory gap</b>: the growing gap between processor and memory performance. as semiconductor technology progresses over the years, this gap continues to increase.
</p>
<p><b>program counter</b>: a register that points at some machine language instruction in main memory.
</p>
<p><b>read-eval-print loop</b>: the operation cycle of interpreter. read an expression from the terminal, evalulate the expression, and print the result.
</p>
<p><b>recursive process</b>: a process defined by a chain of deferred operations.
</p>
<p><b>recursive</b>: evaluation rule that includes, as one of its steps, the need to invoke the rule itself.
</p>
<p><b>register file</b>: contains 16 named locations storing 64-bit values, able to hold addresses or integer data.
</p>
<p><b>register</b>: a word-sized storage device.
</p>
<p><b>release profile</b>: predefined and customizable profile with different configurations that allow a programmer to have more control over various options for compiling code.
</p>
<p><b>special forms</b>: exceptions to the general evaluation rule. <code>define</code> in scheme is an example of a special form.
</p>
<p><b>trait bound</b>: a special form in Rust that is used when traits are parameters. It's a long form, and often there's synactic sugar for it "impl Trait".
</p>
<p><b>trait</b>: similar to interfaces in other languages, a mechanism used in Rust that tells the Rust compiler about the functionality a particular type has and can share with other types. Can be used to define shared behavior in an abstract way.
</p>
<p><b>tree recursion</b>: a common pattern of computation. A recursive process whose evolution looks like a tree. in (<a href="/brain/SICP">SICP</a>), the fibonacci algorithm is used as an example of a process with tree recursion.
</p>
<p><b>type annotation</b>: in rust, this refers to explicitely labelling what something is, such as <code><i32></code>.
</p>
<p><b>unit test</b>: excersize different parts of a library separately. Can test private implementation details.
</p>
<p><b>unrolling</b>: an optimization that removes the overhead of the loop controlling code and instead generates repetitive code for each iteration of the loop.
</p>
<p><b>virtual address space</b>: a uniform view of memory that each process has.
</p>
<p><b>virtual memory</b>: an abstraction that provides each process with the illusion that it has exclusive use of the main memory.
</p>
<p><b>word</b>: a fixed size chunk of bytes. Most machines today have word sizes of 4 bytes or 8 bytes.
</p>
<p><b>zero-cost abstraction</b>: In the Rust Programming Language, an abstraction that imposes no additional runtime overhead.
</p>
<p><b>zero-overhead</b>: the term Bjarne Stroustrup uses in his book "Foundations of C++" (2012) to describe in C++ what Rustaceans would call "Zero-Cost".
</p>
</div>
</body>
</html>
