<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/brain/css/style.css">

</head>
<body>
<div id="main">
<title>Computer Systems, A Programmers Perspective</title>
<h1>Computer Systems, A Programmers Perspective</h1>

<h2>Overview</h2>

<p>A book recommended in the <a href="/brain/TYCS">TYCS</a> series.
</p>
<p>Document UUID: <code>gfjehshjf-hqek-hluo-ekoq-uihwfrrlehwi</code>.
</p>
<p>The short-term goal is to read chapters 1-6, as recommended
by TYCS. Projects will be skipped, unless they can be
somehow reworked to be musical.
</p>
<p>Go to <a href="/brain/computer_systems_programmers_perspective#messages">messages</a>.
</p>

<h2>Chapter 1: A tour of computer systems</h2>

<p>What is a computer system? A computer system
colnsists of hardawre and systems software that work
together to run application programs.
</p>
<p>Hello World in C. Bits, bytes. The compiler pipeline for
Hello World. How the hardware is organized: Buses, I/O devices,
Main Memory, Processor. Caches and memory hierarchy.
</p>
<p>OS management of hardware. Virtual memory. Processes. Threads.
Files. Networks. Parallelism. SIMD.
</p>

<h2>Chapter 2: Representing and manipulating information</h2>

<p>Hex, Binary, how integers are represented. Also
floating point.
</p>
<p>There's a lot of nitty-gritty details here that are worth
going back to at some point.
</p>

<h2>Chapter 3: Machine-Level Represenation of Programs</h2>


<h3>3.1: A historical Perspective</h3>

<p>This is just a big list of the processors from Intel. x86
carries a lot of historical baggage, and you can see
where things come from.
</p>

<h3>3.2: Program Encodings</h3>

<p>Outlines some of the differences between C and
machine representations of programs. C abstracts
away things like <code>program counter</code>, <code>register</code>,
<code>condition code</code>, and <code>vector registers</code>. C offers more
constructs of data, that get translated to continugous
bytes in machine code.
</p>
<p>Some words on tooling here. How to view machine code from
C code using <code>disassemblers</code>. OBJDUMP is mentioned, GDB
is mentioned.
</p>
<p>ATT vs Intel assembly code formats discussed as an aside.
This book opts for ATT.
</p>

<h3>3.3: Data Formats</h3>

<p>Defining a Word as 16 bits. A byte is 8 bits. Long is 32
bits (or double words). Quads are 64 bits. etc. etc.
</p>
<p>Assembly uses single-character suffixes denoting the size
of the operand (table 3.1). 'l' can mean either 'long'
or float, depending on context.
</p>

<h3>3.4: Accessing Information</h3>

<p>x86-64 contains 16 general purpose 64-bit registers.
</p>
<p>History dictates the naming of these registers. Originally
<code>%ax</code> through <code>%bp</code>, then expanded to 32-bit with <code>%eax</code>through <code>%ebp</code>, then expanded to 64 bits with <code>%rax</code>through <code>%rbp</code>. 8 registers were added as well: <code>%r8</code>through <code>%r15</code>.
</p>
<p>Instructions can operate on registers using different sizes.
1 or 2 byte: leave remaing bytes unchagned. 4 bytes:
set upper 4 bytes to 0.
</p>
<p>The <code>%rsp</code> register is the end position in the runtime
stack, and it is the most specialized register.
</p>
<p>Instructions have operands, which specify the source
and destination values. x86 has many <code>operand forms</code>.
</p>
<p>Immediate values are constants, written <code>$</code> followed
by a value.
</p>
<p>Register values denote the contents of register. Denoted
<code>r_a</code> is a register and <code>R[r_a]</code> is the value in that
register.
</p>
<p>Memory references access a memory location, using
the notation <code>M_b[Addr]</code>, though the subscript b
is usually dropped.
</p>
<p>There are many <code>addressing modes</code> to get at a memory
location. There's 9 of 'em in this table on pg 474
(figure 3.3).
</p>
<p><code>lmm</code> is an absolute reference.
</p>
<p><code>(r_a)</code> is an indirect reference <code>M[R[r_a]]</code>.
</p>
<p><code>lmm(r_b)</code> is base + displacement <code>M[lmm + R[r_b]]</code>.
</p>
<p><code>(rb, ri)</code> is indexed <code>M[R[rb] + R[ri]]</code>.
</p>
<p><code>lmm(rb, ri)</code> is indexed <code>M[lmm + R[rb] + R[ri]]</code>.
</p>
<p><code>(,ri,s)</code> is scaled indexed <code>M[R[ri] * s]</code>.
</p>
<p><code>lmm(,ri, s)</code> is scaled indexed <code>M[lmm + R[ri]*s]</code>.
</p>
<p><code>(rb,ri,s)</code> is scaled indexed <code>M[R[rb] + R[ri]*s]</code>.
</p>
<p><code>lmm(rb,ri,s)</code> is scaled index <code>M[lmm + R[rb] + R[ri]*s]</code>.
this is the most general form.
</p>
<p><code>mov(S,D)</code> copies from data from one place (<b>S</b>ource) to another
(<b>D</b>estination). <code>movb</code>, <code>movw</code>, <code>movl</code>, <code>moivq</code>,
<code>movabsq</code>. Source is a value (immediate, register, memory)
the destination (register, memory address).
Source/destination can't both be memory addresses.
</p>
<p><code>movz(S,D)</code> does a move and pads the remaining bytes with
zeros. <code>movz</code>, <code>movzbw</code>, <code>movzbl</code>, <code>movzwl</code>, <code>movzbq</code>,
<code>movzwq</code>. <code>movzlq</code> does not exist because <code>movl</code> will
automatically zero out the upper 4 bytes.
</p>
<p><code>movs(S, D)</code> does a move with sign extension. <code>movsbw</code>,
<code>movsbl</code>, <code>movswl</code>, <code>movsbq</code>, <code>movswq</code>, <code>movslq</code>, <code>cltq</code>.
</p>
<p>The program stack can be a way to move data around. It's
a LIFO.
</p>
<p><code>pushq(S)</code> has the effect:
</p>
<pre><code>R[%rsp] = R[%rsp] - 8;
M[R[%rsp]] = S</pre></code>
<p></p>
<p><code>popq(S)</code> has the effect:
</p>
<pre><code>D = M[R[%rsp]];
R[%rsp] = R[%rsp] + 8;</pre></code>
<p></p>
<p>Stack grows downward: top element has the lowest
stack element.
</p>

<h3>3.5: Arithmetic and Logical Operations</h3>

<p>Operations are divided into 4 groups:
<code>Load Effective Address</code>, <code>unary</code> (one operand),
<code>binary</code> (two operands), and <code>shifts</code>.
</p>
<p>The Load Effective Address command <code>leaq</code> takes the address
of a source and loads it into the destination. This
gets abused for simple arithmetic operations.
</p>
<p>unary operations: <code>inc</code>, <code>dec</code>, <code>neg</code>, <code>not</code>.
</p>
<p>binary operations: <code>add</code>, <code>sub</code>, <code>mul</code>, <code>xor</code>, <code>or</code>,
<code>and</code>. Note that the ordering goes <b>S</b>ource, then
<b>D</b>estination.
</p>
<p>Shift operations: <code>sal</code>, <code>shl</code>, <code>sar</code>, <code>shr</code>. Follow
the arguments (k, D). Where <code>k</code> is a byte that
determines the amount to shift. Low order bits are used.
</p>
<p>x86-64 has limited support for 128-bit arithmetic
operations: <code>imulq</code>, <code>mulq</code>, <code>cqto</code>, <code>idivq</code>, <code>divq</code>.
</p>

<h3>3.6: Control</h3>

<p>Condition codes: single-bit registers that the CPU
maintains, which describe attributes of the most
recent arithmetic or logical operation. These include
<code>carry flag</code> (CF), <code>zero flag</code> (ZF), <code>sign flag</code> (SF), and
<code>overflow flag</code> (OF).
</p>
<p>There are two instruction classes that can set condition
codes without touching the registers. <code>cmp</code> works like
<code>sub</code> but only changing the condition codes. <code>test</code>behaves like <code>and</code> without updating the registers.
</p>
<p>Condition codes get indirectly read 3 wasy: setting
a byte to 1 or 0, conditionally jumping based on state,
or conditionally transferring data.
</p>
<p>Suffixes for these instructions are different than other
instructions. <code>setl</code> and <code>setb</code> mean "set less" and
"set below", not "set long word" or "set byte". (Yeesh).
</p>
<p>The <code>set</code> commands are used to set a register or memory
address to the value of the condition flag. <code>sete</code> or <code>setz</code>,
<code>setne</code> or <code>setnz</code>, <code>sets</code>, <code>setns</code>, <code>setg</code> or <code>setnle</code>,
<code>setge</code> or <code>setnl</code>, <code>setl</code> or <code>setnge</code>, <code>setle</code> or <code>setng</code>,
<code>seta</code> or <code>setnbe</code>, <code>setae</code> or <code>setnb</code>, <code>setb</code> or <code>setnae</code>,
<code>setbe</code> or <code>setna</code>.
</p>
<p>The "or"s are synonyms.
</p>
<p>(There's some tricky stuff with set at the end of this
chapter (pdf pg 125) that I'm still trying to grok. I
just don't think the author is being all that clear.)
</p>
<p>Jumps allows executation to switch to a completely different
position in the program. They are usually indicated with
the use of labels. <code>jmp</code> (Label), <code>jmp</code> (Operand), <code>je</code>,
<code>jne</code>, <code>js</code>, <code>jns</code>, <code>jg</code>, <code>jge</code>, <code>jl</code>, <code>jle</code>, <code>ja</code>, <code>jae</code>,
<code>jb</code>, <code>jbe</code>.
</p>
<p>PC Relative jumps are offsets relative to the positions
they are jumping off from.
</p>
<p>The value of the program counter when performing
PC-relative addressing is the address of the instruction
<b>following</b> the jump instruction, not the address
of the jump instruction itself.
</p>
<p>Relative jumps allow for compact code that can be
shifted to different positions without alterations.
</p>
<p>Conditional and unconditional jumping. Gotos can be
used in C to closely match the equivalent assembly, but
in "goto code" is considered bad practice.
</p>
<p>Conditional moves change a value based on a condition
being true. Known as conditional data transfer.
<code>cmove</code> or <code>cmovz</code>, <code>cmovene</code> or <code>cmovenz</code>, <code>cmovs</code>,
<code>cmovens</code>, <code>cmovg</code> or <code>cmovnle</code>, <code>cmovge</code> or <code>cmovnl</code>,
<code>cmovl</code> or <code>cmovnge</code>, <code>cmovle</code> or <code>cmovng</code>,
<code>cmova</code> or <code>cmovnbe</code>, <code>cmovae</code> or <code>cmovnb</code>,
<code>cmovb</code> or <code>cmovnae</code>, <code>cmovbe</code> or <code>cmovna</code>. 
</p>
<p>The pipelining used in modern processors is why this is
more efficient. Branch prediction allows a processor
to make guesses where it's going to go, and will
fill the pipeline full of instructions. A bad prediction
(branch misprediction) causes it to discard work and
start filling things over again. This incurs a performance
penalty.
</p>
<p>Not all conditional expressions can be expressed as
conditional moves. Since both
sides are evaluated, they could introduce side effects.
</p>
<p>Conditional moves aren't always the most efficient option,
especially if the <code>then-expr</code> or <code>else-expr</code> requires
significant computation. A compiler like GCC will cleverly
know when to use them.
</p>
<p>Loops in C like do-while, while, and for, boil down to
combintations of conditional tests and jumps in assembly.
</p>
<p><code>do-while</code>: repeat body statment, evaluate test expression,
and continue if non-zero. The body statement is executed
at least once.
</p>
<p><code>while</code>: like <code>do-while</code>, except the test statement is
executed before the body. This means the loop can be
terminated before the first iteration (stopped before
it even starts).
</p>
<p><code>for loop</code>: has <code>init-expr</code>, <code>test-expr</code>, <code>update-expr</code>,
can <b>mostly</b> be written as an equivalent while loop.
</p>
<p><code>switch</code> statement in C: provides multiway branching
capabilities based on the value of an index. Can be
efficiently implemented using a <code>jump table</code>. The compiler
automatically implements these.
</p>
<p>Switch cases that <code>fall through</code> don't have a break
statement.
</p>

<h3>3.7: Procedures</h3>

<p>Machine-level support for procedures need to do the
following: pass control, pass data, and allocate/deallocate
memory for local variables.
</p>
<p>Run-time stack: a LIFO stack used to manage memory. When
a procedure runs out of space in registers, it allocates
memory on the stack. Known as a <code>stack frame</code>.
</p>
<p>Return address: an address that gets pushed onto the stack
that indicates where to return to when the procedure is
done.
</p>
<p>Procedure Control transfer involves updating program
counter. <code>call</code> is the instruction that that calls
a procedure, and the return address is the address that
follows right after it. <code>ret</code> is used to go back to the
return address (popping it off the stack and setting
it to the PC).
</p>
<p>Most data transfer between procedures is done via
registers. In x86-64, up to six integral (integer, pointer)
arguments can be passed via registers.
</p>
<p>Registers are used in a specified order (these names
change based on the sized value being used). 64-bit
register order is: <code>%rdi</code>, <code>%rsi</code>, %rdx=, <code>%rc</code>, <code>%r8</code>,
<code>%r9</code>.
</p>
<p>More than 6 integral arguments, and the extras get passed
on the stack.
</p>

<h3>3.8: Array Allocation and Access</h3>

<p>TBD.
</p>

<h3>3.9: Heterogeneous Data Structures</h3>

<p>TBD.
</p>

<h3>3.10: Combining Control and Data in Machine-Level Programs</h3>

<p>TBD.
</p>

<h3>3.11: Floating-point Code</h3>

<p>TBD.
</p>

<h2>Messages</h2>

<p><a id="messages"></a>Any messages tagged with the group <code>CSAPP</code>.
</p>
<p><b>[a2b56a73] 2022-03-25-13-12</b>: finally done with 3.6. wow that felt like forever.
</p>
<p><b>[c38e3679] 2022-03-25-13-07</b>: jump table: data structure used to efficiently implement switches. It is an array of addresses to jump to, using the index as a lookup.
</p>
<p><b>[34ad4a46] 2022-03-25-13-00</b>: there's a "jump to middle" strategy. now there's a "guarded-do" strategy.
</p>
<p><b>[c101f2d8] 2022-03-25-12-55</b>: <code>jump to middle</code> isn't cleanly defined, but it seems like a term I should become familiar with.
</p>
<p><b>[dd40a2e2] 2022-03-24-13-48</b>: branch prediction logic: a mechanism in modern processors use to try and guess whether or not each jump instruction will be followed.
</p>
<p><b>[5c8ea530] 2022-03-24-13-44</b>: conditional move instructions are better suited for modern processors than conditional transfer of control (program follows different execution paths based on condition).
</p>
<p><b>[86aba329] 2022-03-24-13-40</b>: or, to segue into the current section from the previous section, you say something like "in the previous section..., but now in this section...". again, CSAPP fails to do this, and it makes the writing unclear.
</p>
<p><b>[8b9b9fbb] 2022-03-24-13-38</b>: the first sentence of every section should describe what the section is going to be about. this book does not do that, instead choosing to ramble about something else before getting to the point.
</p>
<p><b>[c6022ffe] 2022-03-24-13-23</b>: If I were to to do this better, I'd do what Knuth did in TAOCP and include comments on each line of assembly, or have some kind of arrows.
</p>
<p><b>[62c25b95] 2022-03-24-13-22</b>: okay, there is more than one '5' in this sample code, which made it hard to understand what they were saying. The '5' here refers to the memory address of the next line, which the jump address adds onto to get where it needs to go. The confusing bit was that a sentence ago, it was talking about the other jump instruction, which had a 5 somewhere.
</p>
<p><b>[834cc0e2] 2022-03-24-10-52</b>: so, there's this aside about what repz/retq does. it's this really bonkers convention in the AMD guidelines to writing compilers. It's a thing done to prevent the ret instruction from being the destination of a conditional jump instruction.
</p>
<p><b>[1e43664e] 2022-03-23-14-03</b>: PC relative: jumps that are encoded as the difference between the address of the target instruction and the address of the instruction immediately following the jump.
</p>
<p><b>[0d256f7a] 2022-03-23-13-39</b>: trying to grok what is meant by this "although all arithmetic and logical operations set the condition codes, the descriptions of the different SET instructions apply to the case where a comparison instruction has been executed, setting the condition codes according to the computation t = a - b."
</p>
<p><b>[a7129a42] 2022-03-23-13-37</b>: "wtb" on page 525 is still not making sense to me. It's like having "x" on both sides of the equation. A helpful math textbook would re-arrange things so that the variable is on one side.
</p>
<p><b>[0a5e7a07] 2022-03-23-13-21</b>: <code>setl</code> and <code>setb</code> do not in fact mean "set long word" or "set byte", as one would expect. yeeeesh.
</p>
<p><b>[15b43c72] 2022-03-22-12-49</b>: this oracle doc page on operands in x86 feels more helpful than this book <a href="https://docs.oracle.com/cd/E19120-01/open.solaris/817-5477/ennby/index.html">https://docs.oracle.com/cd/E19120-01/open.solaris/817-5477/ennby/index.html</a>.
</p>
<p><b>[8f3d6ee6] 2022-03-22-12-46</b>: in 3.4, it's unclear to me if the notation system used lines up with actual assembly or if it's just a convention in the textbook. Also, there seems to be 9 friggin ways to address memory?
</p>
<p><b>[3d02e1f9] 2022-03-21-10-37</b>: My reading approach isn't working. I think I need to be a bit more granular. I've been grouping things by chapter, when it should be subsections.
</p>
<p><b>[37352992] 2022-03-15-14-58</b>: try to better grok what t = a - wtb means (pdf page 525)
</p>
<p><b>[7cdaa79e] 2022-03-15-14-53</b>: for reference, I'm staring at "t = a - wtb" waiting for that to click. There was another definition a while back about arithmetic shifts with various word sizes that also took a moment for me to grok. Did I mention the math typesetting here sucks?
</p>
<p><b>[730caa82] 2022-03-15-14-50</b>: this book really seems to like define things in mathematical terms. It's precise, but not intuitive or clear for me.
</p>
<p><b>[949b2997] 2022-03-15-14-48</b>: as an example of synonym, <code>setnle</code> (set not less or equal) and <code>setg</code> (set greater).
</p>
<p><b>[03e81f44] 2022-03-15-14-47</b>: apparently there are "synonyms" in assembly, where two instructions refer to the same machine code. totally not confusing.
</p>
<p><b>[a3df192b] 2022-03-15-14-45</b>: the SET instructions sets a register or memory location to either 0 or 1.
</p>
<p><b>[e1a528d8] 2022-03-15-14-43</b>: common ways to access condition codes: setting a byte to 0 or 1, conditionally jumping, conditionally transferring data.
</p>
<p><b>[514670c5] 2022-03-15-14-40</b>: beginning to see the patterns in all these assembly instructions. the names seem to follow a predictable naming system. the hard part for me is remembering all the assembly notation on the right-hand side. interestingly enough, this is what has been tripping me up with learning MIXAL in TAOCP.
</p>
<p><b>[86e1e386] 2022-03-15-14-37</b>: the TEST instructions behave like AND. but similar to CMP, they only update the condition codes.
</p>
<p><b>[9fe34fac] 2022-03-15-14-36</b>: the CMP instructions set the the condition codes according to the differences between of their two operands. they behave like SUB, except they only update the condition codes, not the destinations.
</p>
<p><b>[2f4d9e53] 2022-03-15-14-29</b>: straight-line code: code where instructions follow one another in sequence.
</p>
<p><b>[849d5915] 2022-03-15-14-29</b>: onto 3.6: Control
</p>
<p><b>[7479f4d8] 2022-03-15-14-28</b>: oct word: what Intel refers to as a 16-byte quantity.
</p>
<p><b>[f6f6958b] 2022-03-15-14-28</b>: Skimming through the special arithmetic operations. The gist seems to be that these handle very large numbers like quads and octs (16 byte words).
</p>
<p><b>[eb6314ce] 2022-03-14-07-23</b>: moving through the overview of instructins too quickly. call this a first pass.
</p>
<p><b>[d181ff55] 2022-03-14-07-15</b>: look at leaq more closely and work on problems
</p>
<p><b>[5358f167] 2022-03-14-07-14</b>: leaq looks like black magic to me.
</p>
<p><b>[d83a702d] 2022-03-14-07-13</b>: load effective address: instruction that is a variant of the movq instruction, referred to as leaq. Commonly used to perform simple arithmetic.
</p>
<p><b>[3d527d32] 2022-03-13-18-55</b>: these abbreviations are getting a little silly. looking at you, movz.
</p>
<p><b>[c81d894c] 2022-03-13-18-44</b>: this assembly chapter is starting to go into territory I don't know much about. A part of me thinks it would be wise to do the problem sets, but another part of me wants to keep reading.
</p>
<p><b>[38d1fd5a] 2022-03-13-18-43</b>: effective address: in assembly, this is the computed address used to access a particular part of memory.
</p>
<p><b>[59cd535d] 2022-03-13-18-42</b>: Operands in x86-64 have three types: immediate (for constant values), register (contents of a register), and memory (access a memory location).
</p>
<p><b>[89631152] 2022-03-13-18-38</b>: Figure 3.2 (Integer Registers) looks like a very helpful chart (pdf pg 473). The page before it has a good terse summary of all the register names and abbreviations.
</p>
<p><b>[6b9abe6e] 2022-03-13-18-35</b>: in GCC assembly code, the data movement instruction has 4 variants: <code>movb</code> (move byte), <code>movw</code> (move word), <code>movl</code> (move double word), and <code>movg</code> (move quad word).
</p>
<p><b>[303ed42f] 2022-03-09-16-30</b>: parity flag: in x86-64, a 1-bit flag that is set after an arithmetic or logical operation. PF is 1 when the lower 8 bits have an even number of 1s, 0 otherwise. This information is not directly accessible in C and requires machien-dependent assembly code.
</p>
<p><b>[4b50a996] 2022-03-09-16-25</b>: Intel uses the word "word" to describe a 16-bit data type. This is for historical reasons. Origins as a 16-bit architecture.
</p>
<p><b>[7de2489a] 2022-03-09-16-23</b>: it seems NOPs can be used for zero-padding for memory alignement. go figure.
</p>
<p><b>[8d9ff2bc] 2022-03-09-16-14</b>: the "-S" flag will generate the assembly file only and go no futher. Probnably should be used with "-Og" for learning purposes.
</p>
<p><b>[7ec9d86c] 2022-03-09-16-12</b>: register file: contains 16 named locations storing 64-bit values, able to hold addresses or integer data.
</p>
<p><b>[a803ab44] 2022-03-09-16-09</b>: ISA: instruction set architecture.
</p>
<p><b>[b9ec9347] 2022-03-09-16-08</b>: the "-Og" flag in GCC is used to produce machine code with the overall structure of the C code.
</p>
<p><b>[9af0424a] 2022-03-09-16-07</b>: linking handles filling in the address of global values in the object files
</p>
<p><b>[63477beb] 2022-03-09-16-05</b>: reading about instruction sets makes me want to take a peak at RISC-V. I wonder what it's like to learn compared to x86. It doesn't have the historical baggage, so maybe more elegant?
</p>
<p><b>[31abc336] 2022-03-09-16-01</b>: hyperthreading: a method to run two programs simultaneously on a single processor. First introduced in the x86 line with the Pentium 4E processor in 2004.
</p>
<p><b>[0c292a1e] 2022-03-09-15-18</b>: AMD: Advanced Micro Devices.
</p>
<p><b>[f19cf5a8] 2022-03-09-15-18</b>: These intros are very lecture-like.
</p>
<p><b>[03376f12] 2022-03-09-15-17</b>: "Those who say 'I understand the general principles, I don't want to bother learning the details' are deluding themselves". Jesus. Little sore much?
</p>
<p><b>[494ceb1c] 2022-03-09-15-11</b>: starting chapter 3 now: machine level representations of programs
</p>
<p><b>[be268d80] 2022-02-03-14-51</b>: this chapter has concepts that are pretty familiar to me after my years of writing C. I'm skimming this more quickly until I find things that look unfamiliar. Maybe IEEE floating point gets introduced here? I could always stand to learn more about that.
</p>
<p><b>[614aa6a5] 2022-02-03-14-50</b>: the math equations in chapter 2 seem to be typeset incorrectly half of the time. And when they are typeset correctly, it looks terrible and confusing.
</p>
<p><b>[f91aa55d] 2022-01-24-17-25</b>: I like this, as it is relevant to my bitmap glyph live coding project: In isolation, a single bit is not very useful. When we group bits together and apply some interpretation that gives meaning to the different possible bit patterns, however, we can represent the elements of any finite set.
</p>
<p><b>[cda51c27] 2022-01-24-17-23</b>: okay. onto chapter 2 now.
</p>
<p><b>[1c52374f] 2022-01-24-17-18</b>: Finished chapter 1. Reviewing before moving on to chapter 2: representing and manipulating information.
</p>
<p><b>[e24ecde1] 2022-01-24-17-18</b>: getting my act together with the CSAPP page (which, I regrettably chose a very long name for. oh well).
</p>
<p><b>[22c8adad] 2022-01-13-13-18</b>: Amdahl's Law: states that when increasing the speed of one part of the system, the effect on the overall system performance depends on both how significant this part was and how much it sped up.
</p>
<p><b>[126d5e28] 2022-01-13-13-14</b>: file: a sequence of bytes. nothing more. nothing less.
</p>
<p><b>[9c8481a4] 2022-01-13-13-12</b>: virtual address space: a uniform view of memory that each process has.
</p>
<p><b>[aca1e54c] 2022-01-13-13-12</b>: virtual memory: an abstraction that provides each process with the illusion that it has exclusive use of the main memory.
</p>
<p><b>[245122be] 2022-01-13-13-08</b>: context: the state information that the process needs in order to run.
</p>
<p><b>[eee78ebb] 2022-01-13-13-08</b>: context switching: the mechanism that the OS uses to interleave instructions from multiple processes.
</p>
<p><b>[a9b02aa8] 2022-01-13-13-06</b>: concurrently: instructions of one process are interleaved with the instructions of another process.
</p>
<p><b>[f0aa548b] 2022-01-13-13-06</b>: process: the operating system's abstraction for a running program.
</p>
<p><b>[f72270b8] 2022-01-12-17-45</b>: operating system: the layer of software interposed between the application program and the hardware.
</p>
<p><b>[2a73cc20] 2022-01-12-17-44</b>: memory hierarchy: the way a computer system organizes memory by performance. moving from top to bottom, devices become slower, larger, and less costly per byte.
</p>
<p><b>[832ac8d8] 2022-01-12-17-42</b>: locality: the tendency for programs to access data and code in localized regions.
</p>
<p><b>[81d52e86] 2022-01-12-17-40</b>: L2 cache: cache that is larger than L1 cache, with hundreds of thousands to millions of bytes and is connected to the processor by a special bus. It can be 5x slower than the L1 cache.
</p>
<p><b>[c9f8fa63] 2022-01-12-17-39</b>: L1 cache: Cache that tens of thousands of bytes long, and can be accesed nearly as fast at the register file.
</p>
<p><b>[a8f04ba6] 2022-01-12-17-38</b>: cache memory is used to deal with the processor-memory gap
</p>
<p><b>[0a1352f0] 2022-01-12-17-37</b>: it is easier and cheaper to make processors run faster than it is to make memory run faster.
</p>
<p><b>[28deebd5] 2022-01-12-17-37</b>: processor-memory gap: the growing gap between processor and memory performance. as semiconductor technology progresses over the years, this gap continues to increase.
</p>
<p><b>[1d34671d] 2022-01-12-17-34</b>: cache memory: smaller and faster storage devices that serve as temporary staging areas for information that the processor is likely to need in the near future.
</p>
<p><b>[fd5d3c13] 2022-01-11-08-58</b>: DMA: direct memory access.
</p>
<p><b>[e92ac973] 2022-01-11-08-57</b>: ALU: arithmetic logic unit.
</p>
<p><b>[4f88cb3a] 2022-01-11-08-56</b>: program counter: a register that points at some machine language instruction in main memory.
</p>
<p><b>[a85ba752] 2022-01-11-08-55</b>: register: a word-sized storage device.
</p>
<p><b>[35d7a30a] 2022-01-11-08-55</b>: CPU: central processing unit. the engine that interprets (or executes) instructions stored in main memory.
</p>
<p><b>[f99d4ba5] 2022-01-11-08-54</b>: DRAM: dynamic random access memory.
</p>
<p><b>[4ae19852] 2022-01-11-08-53</b>: main memory: a temporary storage device that holds both a program and the data it manipulates while the processor is executing the program.
</p>
<p><b>[60bc46aa] 2022-01-11-08-53</b>: motherboard: systems main printed circuit board.
</p>
<p><b>[36843765] 2022-01-11-08-52</b>: controller/adapter: the means by which an IO device is connected to the IO bus. The distinction between a controller or an adapter is mainly one of packaging.
</p>
<p><b>[e01b3a40] 2022-01-11-08-51</b>: buses: a collection of electrical conduits that carry bytes of information back and forth between components.
</p>
<p><b>[fdfda208] 2022-01-11-08-50</b>: word: a fixed size chunk of bytes. Most machines today have word sizes of 4 bytes or 8 bytes.
</p>
<p><b>[fd49f8bb] 2022-01-10-17-48</b>: read chapters 1-6 of CSAPP
</p>
<p><b>[ed4c1eaa] 2022-01-09-13-44</b>: just skimmed TOC. there's a lot of ground covered here. (<a href="/brain/TYCS">TYCS</a>) recommends the first part at leaast (1-6). But the other parts seem useful. We shall see what the content is like though.
</p>
<p><b>[f979bfa8] 2022-01-09-13-41</b>: the label @CSAPP will be used for anything related to (<a href="/brain/computer_systems_programmers_perspective">computer_systems_programmers_perspective</a>).
</p>
</div>
</body>
</html>
