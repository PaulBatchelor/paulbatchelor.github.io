<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<link rel="stylesheet" href="/brain/css/style.css">

</head>
<body>
<div id="main">
<title>Structure And Interpretation Of Computer Programs</title>
<h1>Structure And Interpretation Of Computer Programs</h1>
<p>A classic. Recommended book found in <a href="/brain/TYCS">TYCS</a>.
</p>
<p>For updates see: <a href="/brain/SICP_logs">SICP_logs</a></p>

<h2>1 Building Abstractions With Procedures</h2>


<h3>1.1 Elements of Programming</h3>

<p>Some fundamental keywords, as they relate to scheme.
</p>
<p>Procedures, combinations, special forms, etc.
</p>
<p>Case study: Square Roots by Newton's method. The point
here is to start with a mathematical definition, then
turn it into a structure of procedures.
</p>

<h3>1.2 Procedures and Processes</h3>

<p>Linear recursion and iteration.
</p>
<p>Tree recursion: process evolution looks like a tree.
</p>
<p>Orders of growth (space vs time).
</p>
<p>Case studies such as: exponentiation and GCD. Explore
linear recursive vs iterative processes, and
analyze growth.
</p>

<h3>1.3 Formulating abstractions with higher-order procedures</h3>

<p>Introducing things like let, lambda, etc.
</p>
<p>They make a parallel between higher-order functions and
the sigma notation in Mathematics. Some sequences are
explored.
</p>
<p>Various sequences are explored: sum of cubes, pi/8 sum, sum
of integers (using identity function).
</p>
<p>Case study: finding roots of equations using half-interval
method.
</p>

<h2>2 Building Abstractions With Data</h2>


<h3>2.1 Introduction to Data Abstraction</h3>

<p>Introduces the idea of compound data objects. Uses
rational number type as an initial example. Abstraction
barriers. <code>cons</code>, <code>car</code>, and <code>cdr</code> get re-implemented in
scheme (wow!).
</p>

<h3>2.2 Hierarchical Data and the Closure Property</h3>

<p>The sequence, and how they are represented in Scheme as
cons's (aka a linked list). Introduction to list operations.
Mapping over lists. Hierarchical structures (aka Trees).
Mapping over trees. Sequence operations (like how a DSP
engineer would think). "Picture language" used as a visual
way to synthesize complex operations from a core set of
primitives using high-order operations.
</p>

<h3>2.3 Symbolic Data</h3>

<p>The quote operator. Symbolic algebra. Abstract data.
Implementations of Binary trees. Huffman encoding and
huffman trees.
</p>

<h3>2.4 Multiple Representations for Abstract Data</h3>

<p>Example used: complex numbers, and how they can
be represented differently (this may be in 2.5?) (this may be in 2.5?).
Builds up abstractions for how
to manage complex number operations. Dispatching on Type.
Generic interfaces. Data-directed programming.
</p>

<h3>2.5 Systems with Generic Operations</h3>

<p>More on generic systems using compelx numbers as example.
Hierarchies of types. Inadequacies of hierarchies.
</p>
<p>I "super-skimmed" 2.5.3 section on symbolic algebra, as
it was very math-oriented and not really interesting
to me.
</p>

<h2>3 Modularity, Objects, and State</h2>


<h3>3.1 Assignment and Local State</h3>

<p>Introducing <code>set!</code> using a bank acount <code>withdraw</code> as an
example. Using local state to make different instances of
withdraw. Building a stateful RNG and using it
in monte-carlo simulations (showcasing how it simplifies
code). Downfalls of assignment/state: can not use substitution
like previous chapters. Programming without assignment:
functional programming. Samness.
</p>

<h3>3.2 The Environment Model of Evaluation</h3>

<p>Variables as "places" instead of values. Analysis of
Environments used in simple procedures like square and
sum-of-squares. Analysis of make-withdraw. Internal
defitions in environments. Sharing and identity.
Mutation=assignment.
</p>

<h3>3.3 Modeling with Mutable Data</h3>

<p>Queues. Tables: one and two dimensions. Local tables with
separate lookup and insert for each table. Digital circuit
simulator implementation: logic, wires, agenda, constraints.
</p>

<h3>3.4 Concurrency: Time is of the Essence</h3>

<p>TBD.
</p>

<h3>3.5 Streams</h3>

<p>TBD.
</p>

<h2>4 Metalinguistic Abstraction</h2>


<h3>4.1 The metacircular environment</h3>

<p>TBD.
</p>

<h3>4.2 Variations on a Scheme -- Lazy Evaluation</h3>

<p>TBD.
</p>

<h3>4.3 Variations on a Scheme -- Nondeterministic Computing</h3>

<p>TBD.
</p>

<h3>4.4 Logic Programming</h3>

<p>TBD.
</p>

<h2>5 Computing with Register Machines</h2>


<h3>5.1 Designing Register Machines</h3>

<p>TBD.
</p>

<h3>5.2 A Register-Machine Simulator</h3>

<p>TBD.
</p>

<h3>5.3 Storage Allocation and Garbage Collection</h3>

<p>TBD.
</p>

<h3>5.4 The Explict-Control Evaluator</h3>

<p>TBD.
</p>

<h3>5.5 Compilation</h3>

<p>TBD.
</p>
</div>
</body>
</html>
