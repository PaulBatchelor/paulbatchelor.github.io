<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/brain/css/style.css">

</head>
<body>
<div id="main">
<p><title>leetcode/palindromic_substring</title>
<h1>palindromic_substring</h1>
<a href="/brain/dz">dz</a> / <a href="/brain/dz/leetcode">leetcode</a> / <a href="/brain/dz/leetcode/palindromic_substring">palindromic_substring</a>
<p></p>
<h2>Summary</h2>
<p>
Given a string s, return the longest palindromic substring in s.
</p>
<h2>Node Tree</h2>
<ul>
<li>
<a href=#intuition_pre_hint>intuition_pre_hint</a><ul>
<li>
<a href=#expand_from_centers>expand_from_centers</a></li>
<li>
<a href=#intuition_post_hint>intuition_post_hint</a><ul>
<li>
<a href=#dynamic_programming>dynamic_programming</a></li>
</ul>
</li>
<li>
<a href=#brute_force>brute_force</a></li>
</ul>
</li>
<li>
<a href=#leetcode_editorial>leetcode_editorial</a><ul>
<li>
<a href=#dynamic_programming>dynamic_programming</a></li>
<li>
<a href=#expand_from_centers>expand_from_centers</a></li>
<li>
<a href=#manachers_algorithm>manachers_algorithm</a></li>
<li>
<a href=#brute_force>brute_force</a></li>
</ul>
</li>
<li>
<a href=#URL>URL</a></li>
<li>
<a href=#cpp_implementation>cpp_implementation</a><ul>
<li>
<a href=#dynamic_programming>dynamic_programming</a></li>
<li>
<a href=#error_in_comments>error_in_comments</a></li>
<li>
<a href=#use_of_matrix_structure>use_of_matrix_structure</a><ul>
<li>
<a href=#error_in_comments>error_in_comments</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>Nodes</h2>
<table border="1px">
<tr>
<td colspan=2>
<a href=#URL>URL</a><a id="URL"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
URL
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://leetcode.com/problems/longest-palindromic-substring">https://leetcode.com/problems/longest-palindromic-substring</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#intuition_pre_hint>intuition_pre_hint</a><a id="intuition_pre_hint"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
The brute-force approach I imagine would involve taking each character, and then sweeping backwards from the end of string, check every matching character to see if the region marks a palindrome. Palindromes can be split in half, which means the largest segment a palindrome can be is N/2. There might be a way to use this property to make a more efficient algorithm, perhaps a sliding window. Another approach: finding potential palindromes starting at the center, and working backwards. The smallest possible even palindrome is two duplicate letters. The smallest possible odd palindrome is 3 letters (not counting 1 letter), with a center letter and two duplicate letters on the outside. You could do a linear sweep for even/odd palindromes, and upon finding one, expand the palindrome out on either end and check the size.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#expand_from_centers>expand_from_centers</a> (thought about this here), <a href=#intuition_post_hint>intuition_post_hint</a> (after reading the hint), <a href=#brute_force>brute_force</a>
</td>
</tr>
<tr>
<td>
remarks
</td>
<td>
There's a hint on the leetcode website that I'm ignoring for the moment. So my thoughts here are just reading the problem.
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#intuition_post_hint>intuition_post_hint</a><a id="intuition_post_hint"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
The language of the 3 uses terms like "re-use previously computed palindrome", which suggests a solution using recursion and/or dynamic programming. My initial thoughts finding palindrome centers seems close. Apparently the O(n) palindrome checks in brute force can be reduced to O(1). So, that seems like a data structure.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#dynamic_programming>dynamic_programming</a> (what I thought of after reading the hints)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition_pre_hint>intuition_pre_hint</a>
</td>
</tr>
<tr>
<td>
remarks
</td>
<td>
thoughts after reading the hint
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#cpp_implementation>cpp_implementation</a><a id="cpp_implementation"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
C++ implementation of solution
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#dynamic_programming>dynamic_programming</a> (what the C++ implementation was trying to do), <a href=#error_in_comments>error_in_comments</a>, <a href=#use_of_matrix_structure>use_of_matrix_structure</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#use_of_matrix_structure>use_of_matrix_structure</a><a id="use_of_matrix_structure"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Use of matrix data structure. Still trying to grok this, though the comments are helpful. I should have read the constraints of the string length (max length 1000), that would have been a good hint.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#error_in_comments>error_in_comments</a> (reading comments about matrix)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#cpp_implementation>cpp_implementation</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#error_in_comments>error_in_comments</a><a id="error_in_comments"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
I think the comments here are incorrect. I believe it is erroneously saying "abbcba" is the longest palindrome.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#use_of_matrix_structure>use_of_matrix_structure</a>, <a href=#cpp_implementation>cpp_implementation</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#leetcode_editorial>leetcode_editorial</a><a id="leetcode_editorial"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
leetcode editorial
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#dynamic_programming>dynamic_programming</a>, <a href=#expand_from_centers>expand_from_centers</a>, <a href=#manachers_algorithm>manachers_algorithm</a> (Fastest solution, advanced and out of scope), <a href=#brute_force>brute_force</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://leetcode.com/problems/longest-palindromic-substring/editorial">https://leetcode.com/problems/longest-palindromic-substring/editorial</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#dynamic_programming>dynamic_programming</a><a id="dynamic_programming"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
The dynamic programming algorithm is basically what the C++ solution was attempting to do. The LC algorithm uses a boolean table, while the C++ solution I think keeps track of the sizes? The answer they come to is incorrect when they work it out in the comments, so I'm mildly skeptical this is a correct algorithm.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#leetcode_editorial>leetcode_editorial</a>, <a href=#intuition_post_hint>intuition_post_hint</a>, <a href=#cpp_implementation>cpp_implementation</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#expand_from_centers>expand_from_centers</a><a id="expand_from_centers"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
"Expand from centers" seems to be the line of thinking I came to when I was thinking about the problem.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition_pre_hint>intuition_pre_hint</a>, <a href=#leetcode_editorial>leetcode_editorial</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#brute_force>brute_force</a><a id="brute_force"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
I think I mostly described the brute force solution correctly, although the editorial has a more elegant way of describing it: check all substrings for palindromes.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition_pre_hint>intuition_pre_hint</a>, <a href=#leetcode_editorial>leetcode_editorial</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#manachers_algorithm>manachers_algorithm</a><a id="manachers_algorithm"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Manachers Algorithm for finding the longest palindromic string in O(n) time. Faster because it re-uses precomputed data when a palindrome exists inside another palindrome.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#leetcode_editorial>leetcode_editorial</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher%27s_algorithm">https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher%27s_algorithm</a>
</td>
</tr>
</table><br>
</p>
</div>
</body>
</html>
