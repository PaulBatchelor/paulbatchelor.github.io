<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/brain/css/style.css">

</head>
<body>
<div id="main">
<p><title>leetcode/two_sum</title>
<h1>two_sum</h1>
<a href="/brain/dz">dz</a> / <a href="/brain/dz/leetcode">leetcode</a> / <a href="/brain/dz/leetcode/two_sum">two_sum</a>
<p></p>
<h2>Node Tree</h2>
<ul>
<li>
<a href=#problem>problem</a><ul>
<li>
<a href=#intuition>intuition</a><ul>
<li>
<a href=#better_performance>better_performance</a><ul>
<li>
<a href=#better_impl>better_impl</a></li>
<li>
<a href=#caching_vs_smaller_inner_loop>caching_vs_smaller_inner_loop</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href=#cpp_impl>cpp_impl</a><ul>
<li>
<a href=#subtract_from_target>subtract_from_target</a><ul>
<li>
<a href=#relies_on_exactly_one_answer>relies_on_exactly_one_answer</a></li>
</ul>
</li>
<li>
<a href=#unordered_map_cpp>unordered_map_cpp</a></li>
<li>
<a href=#caching_vs_smaller_inner_loop>caching_vs_smaller_inner_loop</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href=#URL>URL</a></li>
</ul>
<h2>Nodes</h2>
<table border="1px">
<tr>
<td colspan=2>
<a href=#URL>URL</a><a id="URL"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
URL
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://leetcode.com/problems/two-sum">https://leetcode.com/problems/two-sum</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#problem>problem</a><a id="problem"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
two-sum: given an array of integers =nums= and an integer =target=, return indices of the two numbers such that they add up to =target=. You may assume that each input would have exactly one solution, and may not use the same element twice.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#intuition>intuition</a>, <a href=#cpp_impl>cpp_impl</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#intuition>intuition</a><a id="intuition"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
This can be solved using brute force using two loops. For each number, add it with every other number, and return the pair if it adds up to the target. This yields a performance time of O(n^2).
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#better_performance>better_performance</a> (follow-up, how to do better performance)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#problem>problem</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#better_performance>better_performance</a><a id="better_performance"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
This can be solved in less than O(n^2) time by realizing that pairs can be in any order. Comparing indices A and B is equivalent to B and A. My gut tells me that this cuts it in half, so O(n^2)/2, but I have yet to prove it.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#better_impl>better_impl</a> (how to implement), <a href=#caching_vs_smaller_inner_loop>caching_vs_smaller_inner_loop</a> (I thought about using a smaller inner loop)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition>intuition</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#better_impl>better_impl</a><a id="better_impl"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
How to keep track of pairs already done? There's always brute-force of keeping track. But, you can also order the pairs. There is a total ordering here, and you can choose to only consider pairs where A &lt; B. If the outer loop is A, the inner loop is B, the inner loop could iterate up to A.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#better_performance>better_performance</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#cpp_impl>cpp_impl</a><a id="cpp_impl"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
The CPP solutions don't implement the naive n^2 solution and instead use hash maps to cache results to remove the inner loop used for searching, reducing performance from O(n) to O(1).
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#subtract_from_target>subtract_from_target</a>, <a href=#unordered_map_cpp>unordered_map_cpp</a>, <a href=#caching_vs_smaller_inner_loop>caching_vs_smaller_inner_loop</a> (the solutions here use caching via an unordered map)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#problem>problem</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#subtract_from_target>subtract_from_target</a><a id="subtract_from_target"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
There are two implementations, but the gist is to keep track of the target minus the number in the map, the idea being that that key is the only solution for to make that number work. The value stored is the indice. If the matching pair is found, it will be a hit on the map, and the two indices are returned.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#relies_on_exactly_one_answer>relies_on_exactly_one_answer</a>
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#cpp_impl>cpp_impl</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#unordered_map_cpp>unordered_map_cpp</a><a id="unordered_map_cpp"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Uses an unordered map in C++
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#cpp_impl>cpp_impl</a>
</td>
</tr>
<tr>
<td>
remarks
</td>
<td>
find() and end() methods are used. If find() == end(), it means it is not in there.
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.cppreference.com/w/cpp/container/unordered_map">https://en.cppreference.com/w/cpp/container/unordered_map</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#relies_on_exactly_one_answer>relies_on_exactly_one_answer</a><a id="relies_on_exactly_one_answer"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
The problem states there is exactly one answer, which rules out the possibility of accidently returning the same indices.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#subtract_from_target>subtract_from_target</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#caching_vs_smaller_inner_loop>caching_vs_smaller_inner_loop</a><a id="caching_vs_smaller_inner_loop"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
My initial idea was to use a smaller inner loop to remove redundancies in searching for an answer. I referred to caching as a solution that only works if you have the memory for it. I was thinking about a 2d matrix, which is very memory-intensive. The C++ uses a map which is way more clever.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#cpp_impl>cpp_impl</a>, <a href=#better_performance>better_performance</a>
</td>
</tr>
</table><br>
</p>
</div>
</body>
</html>
