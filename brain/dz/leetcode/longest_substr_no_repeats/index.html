<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/brain/css/style.css">

</head>
<body>
<div id="main">
<p><title>leetcode/longest_substr_no_repeats</title>
<h1>longest_substr_no_repeats</h1>
<a href="/brain/dz">dz</a> / <a href="/brain/dz/leetcode">leetcode</a> / <a href="/brain/dz/leetcode/longest_substr_no_repeats">longest_substr_no_repeats</a>
<p></p>
<h2>Summary</h2>
<p>
Given a string s, find the length of the longest substring without repeating characters.
</p>
<h2>Node Tree</h2>
<ul>
<li>
<a href=#maxlen_init_negative_one>maxlen_init_negative_one</a></li>
<li>
<a href=#URL>URL</a></li>
<li>
<a href=#cpp_implementation>cpp_implementation</a><ul>
<li>
<a href=#no_inner_loop>no_inner_loop</a></li>
<li>
<a href=#hashmap_stores_last_known_position>hashmap_stores_last_known_position</a><ul>
<li>
<a href=#repeat_pos_latest_repeating_character>repeat_pos_latest_repeating_character</a><ul>
<li>
<a href=#distance_between_latest_repeating>distance_between_latest_repeating</a><ul>
<li>
<a href=#postion_always_updated_at_end>postion_always_updated_at_end</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href=#intuition>intuition</a><ul>
<li>
<a href=#brute_force>brute_force</a></li>
</ul>
</li>
</ul>
<h2>Nodes</h2>
<table border="1px">
<tr>
<td colspan=2>
<a href=#URL>URL</a><a id="URL"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
URL
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters">https://leetcode.com/problems/longest-substring-without-repeating-characters</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#intuition>intuition</a><a id="intuition"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
I think I can imagine a brute-force way to do this, but I vaguely remember reading about a more elegant solution The Algorithm Design Manual. Brute force involves starting at each character, and sweeping until it finds itself again, yielding approximately an O(n^2) algorithm. I think the more elegant solution involved a data structure or divide-and-conquer somehow.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#brute_force>brute_force</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#brute_force>brute_force</a><a id="brute_force"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Brute Force involves two loops. The outer loop sweeps through every character. The inner loop starts at that character position, and continues until it finds a match or reaches the end. At the end of the inner loop, you'll have a size. If the size is the greatest one seen so far, it is stored along with the indice.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition>intuition</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#cpp_implementation>cpp_implementation</a><a id="cpp_implementation"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
So the CPP implementation is kinda weird. It's using a hash map to keep track of character positions. It's hard to tell if this is correct or not. It just seems overly complicated. There is an alternative verson that uses a flat array instead.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#no_inner_loop>no_inner_loop</a>, <a href=#hashmap_stores_last_known_position>hashmap_stores_last_known_position</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#no_inner_loop>no_inner_loop</a><a id="no_inner_loop"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Ah, I'm starting to see a pattern with these solutions, they do not have an inner loop.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#cpp_implementation>cpp_implementation</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#maxlen_init_negative_one>maxlen_init_negative_one</a><a id="maxlen_init_negative_one"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
The maxlen value is initialized at -1. That way, the first character (index 0) has a maxlen of 1. Not an obvious first thing.
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#hashmap_stores_last_known_position>hashmap_stores_last_known_position</a><a id="hashmap_stores_last_known_position"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
The hashmap data structure here is used to store the last known location of a particular character, if it existed at all. All that matters is the last seen character. The previous ones can be discarded.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#repeat_pos_latest_repeating_character>repeat_pos_latest_repeating_character</a>
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#cpp_implementation>cpp_implementation</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#repeat_pos_latest_repeating_character>repeat_pos_latest_repeating_character</a><a id="repeat_pos_latest_repeating_character"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
The repeat position stored the latest repeating character (the greatest indice).
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#distance_between_latest_repeating>distance_between_latest_repeating</a>
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#hashmap_stores_last_known_position>hashmap_stores_last_known_position</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#distance_between_latest_repeating>distance_between_latest_repeating</a><a id="distance_between_latest_repeating"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
The distance is measured between the latest (last) repeating character, and the position of the current character. This is stored away if it is the longest distance it has seen.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#postion_always_updated_at_end>postion_always_updated_at_end</a>
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#repeat_pos_latest_repeating_character>repeat_pos_latest_repeating_character</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#postion_always_updated_at_end>postion_always_updated_at_end</a><a id="postion_always_updated_at_end"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
The character position is always stored away at the end.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#distance_between_latest_repeating>distance_between_latest_repeating</a>
</td>
</tr>
</table><br>
</p>
</div>
</body>
</html>
