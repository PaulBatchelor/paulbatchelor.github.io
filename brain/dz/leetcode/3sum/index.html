<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/brain/css/style.css">

</head>
<body>
<div id="main">
<p><title>leetcode/3sum</title>
<h1>3sum</h1>
<a href="/brain/dz">dz</a> / <a href="/brain/dz/leetcode">leetcode</a> / <a href="/brain/dz/leetcode/3sum">3sum</a>
<p></p>
<h2>Summary</h2>
<p>
15. 3sum. Given an integer array nums, return all the triplets  [nums[i], nums[j], nums[k]] such that i != j, i != k, and  j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate  triplets.
</p>
<h2>Node Tree</h2>
<ul>
<li>
<a href=#wikipedia>wikipedia</a><ul>
<li>
<a href=#hash_table_solution>hash_table_solution</a><ul>
<li>
<a href=#hash_table_intuition_vs_reality>hash_table_intuition_vs_reality</a></li>
<li>
<a href=#mathematical_set>mathematical_set</a></li>
</ul>
</li>
<li>
<a href=#comparison_based_model>comparison_based_model</a></li>
<li>
<a href=#cpp_impl>cpp_impl</a></li>
</ul>
</li>
<li>
<a href=#URL>URL</a></li>
<li>
<a href=#intuition>intuition</a><ul>
<li>
<a href=#enumerate_all_unique_pairs_and_ideal_solution>enumerate_all_unique_pairs_and_ideal_solution</a><ul>
<li>
<a href=#hash_table_intuition_vs_reality>hash_table_intuition_vs_reality</a></li>
<li>
<a href=#hash_table_solution>hash_table_solution</a><ul>
<li>
<a href=#hash_table_intuition_vs_reality>hash_table_intuition_vs_reality</a></li>
<li>
<a href=#mathematical_set>mathematical_set</a></li>
</ul>
</li>
<li>
<a href=#intuition_post_hint>intuition_post_hint</a></li>
</ul>
</li>
<li>
<a href=#intuition_post_hint>intuition_post_hint</a></li>
<li>
<a href=#any_way_to_remove_values>any_way_to_remove_values</a></li>
</ul>
</li>
<li>
<a href=#intuition_brute_force>intuition_brute_force</a></li>
<li>
<a href=#sort_array_first>sort_array_first</a></li>
</ul>
<h2>Nodes</h2>
<table border="1px">
<tr>
<td colspan=2>
<a href=#URL>URL</a><a id="URL"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
URL
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://leetcode.com/problems/3sum/">https://leetcode.com/problems/3sum/</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#intuition>intuition</a><a id="intuition"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
The thing that makes this problem interesting is that the triplet combinations are distinct. You can't simply brute force all the combinations, you actually need a way to keep track of values.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#enumerate_all_unique_pairs_and_ideal_solution>enumerate_all_unique_pairs_and_ideal_solution</a>, <a href=#intuition_post_hint>intuition_post_hint</a>, <a href=#any_way_to_remove_values>any_way_to_remove_values</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#intuition_brute_force>intuition_brute_force</a><a id="intuition_brute_force"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Go through all the combinations and test for 0. When a match has been found, the triplet values are sorted and then stored in a 3d hashmap. If an entry doesn't exist yet, append it to the array and the map, otherwise ignore. This is O(n^3) performance time, so not great.
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#any_way_to_remove_values>any_way_to_remove_values</a><a id="any_way_to_remove_values"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
I wonder if there's any way to remove values from the input array. Indices aren't really considered, only the values themselves.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition>intuition</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#enumerate_all_unique_pairs_and_ideal_solution>enumerate_all_unique_pairs_and_ideal_solution</a><a id="enumerate_all_unique_pairs_and_ideal_solution"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Similar to some of the two-sum solutions, use a hashmap to store all unique pairs with their ideal third pair match as the key, and a tuple containing the other two values. Building up the hashmap would take O(n^2), and the lookup would take O(n) time. You'd need a way to prevent duplicate lookups, which can be done with another map, or by removing the key from the map.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#hash_table_intuition_vs_reality>hash_table_intuition_vs_reality</a> (intuition), <a href=#hash_table_solution>hash_table_solution</a> (along the lines of what I was thinking about), <a href=#intuition_post_hint>intuition_post_hint</a> (looks pretty close, though it's a bit clunky after looking at hint)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition>intuition</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#intuition_post_hint>intuition_post_hint</a><a id="intuition_post_hint"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
It seems like some kind of hashmap is warranted to speed things up. I think my solution could work, but it feels clunky to have what is essentially two hash maps (one to store answers, one two keep track of found solutions). I think I am missing something.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#enumerate_all_unique_pairs_and_ideal_solution>enumerate_all_unique_pairs_and_ideal_solution</a>, <a href=#intuition>intuition</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#cpp_impl>cpp_impl</a><a id="cpp_impl"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
C++ implementation (couldn't find editorial anywhere)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#wikipedia>wikipedia</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#sort_array_first>sort_array_first</a><a id="sort_array_first"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
array is sorted first. This seems to make a lot of things easier, including the duplication issue.
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#wikipedia>wikipedia</a><a id="wikipedia"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
wikipedia article on 3sum, including pseudo-code for the canonical solution in O(n^2) time.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#hash_table_solution>hash_table_solution</a>, <a href=#comparison_based_model>comparison_based_model</a>, <a href=#cpp_impl>cpp_impl</a> (main C++ implementation uses this)
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/3SUM">https://en.wikipedia.org/wiki/3SUM</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#comparison_based_model>comparison_based_model</a><a id="comparison_based_model"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
A comparison based model uses pre-sorting of the list and then tests all possible pairs in a careful order that prevents the need to binary search for the pairs in a sorted list, causing O(n^2) time.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#wikipedia>wikipedia</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#hash_table_solution>hash_table_solution</a><a id="hash_table_solution"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
For an input array S[0..n-1], insert S(i) into a hash table, and then, for each index i and j, checking whether the hash table contains the integer -(S[i] + S[j]).
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#hash_table_intuition_vs_reality>hash_table_intuition_vs_reality</a> (reality), <a href=#mathematical_set>mathematical_set</a> (treats hash table like set data structure)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#wikipedia>wikipedia</a>, <a href=#enumerate_all_unique_pairs_and_ideal_solution>enumerate_all_unique_pairs_and_ideal_solution</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#hash_table_intuition_vs_reality>hash_table_intuition_vs_reality</a><a id="hash_table_intuition_vs_reality"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
My intuitive solution involved computing the ideal last value in the triplet and having that be the key, and a tuple be the values. Meanwhile, the actual solution uses the hash map as more of a mathematical set operation, where the "last value" is imply the negative, of the other two values. A check is seeing if the value belongs to the set.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#enumerate_all_unique_pairs_and_ideal_solution>enumerate_all_unique_pairs_and_ideal_solution</a>, <a href=#hash_table_solution>hash_table_solution</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#mathematical_set>mathematical_set</a><a id="mathematical_set"></a>
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#hash_table_solution>hash_table_solution</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Set_(mathematics)">https://en.wikipedia.org/wiki/Set_(mathematics)</a>
</td>
</tr>
</table><br>
</p>
</div>
</body>
</html>
