<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/brain/css/style.css">

</head>
<body>
<div id="main">
<p><title>leetcode/39_combination_sum</title>
<h1>39_combination_sum</h1>
<a href="/brain/dz">dz</a> / <a href="/brain/dz/leetcode">leetcode</a> / <a href="/brain/dz/leetcode/39_combination_sum">39_combination_sum</a>
<p></p>
<h2>Summary</h2>
<p>
Given an array of distinct integers candidates and a  target integer target, return a list of all unique  combinations of candidates where the chosen numbers sum  to target. You may return the combinations in any order.  The same number may be chosen from candidates an  unlimited number of times. Two combinations are unique if  the frequency of at least one of the chosen numbers is different.  The test cases are generated such that the number of  unique combinations that sum up to target is less than  150 combinations for the given input.
</p>
<h2>Node Tree</h2>
<ul>
<li>
<a href=#intuition>intuition</a><ul>
<li>
<a href=#handling_distinction>handling_distinction</a><ul>
<li>
<a href=#select_candidates_in_order>select_candidates_in_order</a></li>
</ul>
</li>
<li>
<a href=#intuition_basically_correct>intuition_basically_correct</a></li>
<li>
<a href=#dynamic_programming>dynamic_programming</a><ul>
<li>
<a href=#handling_distinction>handling_distinction</a><ul>
<li>
<a href=#select_candidates_in_order>select_candidates_in_order</a></li>
</ul>
</li>
<li>
<a href=#use_of_remainder>use_of_remainder</a></li>
<li>
<a href=#approach_1_backtracking>approach_1_backtracking</a><ul>
<li>
<a href=#intuition_basically_correct>intuition_basically_correct</a></li>
<li>
<a href=#select_candidates_in_order>select_candidates_in_order</a></li>
<li>
<a href=#space_complexity>space_complexity</a></li>
<li>
<a href=#time_complexity>time_complexity</a><ul>
<li>
<a href=#space_complexity>space_complexity</a></li>
</ul>
</li>
<li>
<a href=#visualized_using_graph>visualized_using_graph</a></li>
<li>
<a href=#backtracking>backtracking</a><ul>
<li>
<a href=#backtracking_wiki>backtracking_wiki</a></li>
</ul>
</li>
<li>
<a href=#combo_sum_3>combo_sum_3</a></li>
<li>
<a href=#depth_first_traversal>depth_first_traversal</a><ul>
<li>
<a href=#often_implemented_recursively>often_implemented_recursively</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href=#eliminate_args_greater>eliminate_args_greater</a></li>
</ul>
</li>
<li>
<a href=#URL>URL</a></li>
<li>
<a href=#editorial>editorial</a><ul>
<li>
<a href=#approach_1_backtracking>approach_1_backtracking</a><ul>
<li>
<a href=#intuition_basically_correct>intuition_basically_correct</a></li>
<li>
<a href=#select_candidates_in_order>select_candidates_in_order</a></li>
<li>
<a href=#space_complexity>space_complexity</a></li>
<li>
<a href=#time_complexity>time_complexity</a><ul>
<li>
<a href=#space_complexity>space_complexity</a></li>
</ul>
</li>
<li>
<a href=#visualized_using_graph>visualized_using_graph</a></li>
<li>
<a href=#backtracking>backtracking</a><ul>
<li>
<a href=#backtracking_wiki>backtracking_wiki</a></li>
</ul>
</li>
<li>
<a href=#combo_sum_3>combo_sum_3</a></li>
<li>
<a href=#depth_first_traversal>depth_first_traversal</a><ul>
<li>
<a href=#often_implemented_recursively>often_implemented_recursively</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>Nodes</h2>
<table border="1px">
<tr>
<td colspan=2>
<a href=#URL>URL</a><a id="URL"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
URL
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://leetcode.com/problems/combination-sum/">https://leetcode.com/problems/combination-sum/</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#intuition>intuition</a><a id="intuition"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
One of those problems where I feel like a brute-force solution would be enormously inefficient. Fortunately the bounds are pretty small.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#handling_distinction>handling_distinction</a>, <a href=#intuition_basically_correct>intuition_basically_correct</a> (basically correct intuition), <a href=#dynamic_programming>dynamic_programming</a>, <a href=#eliminate_args_greater>eliminate_args_greater</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#eliminate_args_greater>eliminate_args_greater</a><a id="eliminate_args_greater"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Any number greater than the target is eliminated.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition>intuition</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#dynamic_programming>dynamic_programming</a><a id="dynamic_programming"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
This is probably a dynamic programming slash recursive backtracking solution. You can always break down a problem into "given an initial value X, find all the numbers that can add to less than or equal to target". Repeat that recursively, and keep track of numbers so far. Recursion ends when there is no number that can be less than or equal to target. Add to list if it is exactly the target. If sum is less than target, recurse.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#handling_distinction>handling_distinction</a>, <a href=#use_of_remainder>use_of_remainder</a> (My logic was slightly different, opting to keep the current,sum rather than remainder.), <a href=#approach_1_backtracking>approach_1_backtracking</a> (I also mentioned "backtracking" here, which is probably,closer to what it actually is)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition>intuition</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#handling_distinction>handling_distinction</a><a id="handling_distinction"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
In past problems, there have been solutions that have really elegantly handled distinctness. I forget them now. Perhaps it's how you set up the iteration for finding the numbers. When you check for matching sums, you're going through each number once. I'm willing to believe that ordering prevents duplicates from happening.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#select_candidates_in_order>select_candidates_in_order</a> (My hunch about doing things in order was correct)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#dynamic_programming>dynamic_programming</a>, <a href=#intuition>intuition</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#editorial>editorial</a><a id="editorial"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
editorial
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#approach_1_backtracking>approach_1_backtracking</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#approach_1_backtracking>approach_1_backtracking</a><a id="approach_1_backtracking"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Approach 1: backtracking
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#intuition_basically_correct>intuition_basically_correct</a>, <a href=#select_candidates_in_order>select_candidates_in_order</a>, <a href=#space_complexity>space_complexity</a>, <a href=#time_complexity>time_complexity</a>, <a href=#visualized_using_graph>visualized_using_graph</a>, <a href=#backtracking>backtracking</a> (definition), <a href=#combo_sum_3>combo_sum_3</a>, <a href=#depth_first_traversal>depth_first_traversal</a>
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#editorial>editorial</a>, <a href=#dynamic_programming>dynamic_programming</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#combo_sum_3>combo_sum_3</a><a id="combo_sum_3"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Combination sum iii: recommended to solve before continuing. has a very similar solution, and is slightly easier
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#approach_1_backtracking>approach_1_backtracking</a>
</td>
</tr>
<tr>
<td>
remarks
</td>
<td>
I am not tackling this problem today
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://leetcode.com/problems/combination-sum-iii/description/">https://leetcode.com/problems/combination-sum-iii/description/</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#backtracking>backtracking</a><a id="backtracking"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Backtracking is a general algorithm for finding all (or some) solutions to some computational problems. The idea is that it incrementally builds candidates to the solutions, and abandons a candidate ("backtrack") as soon as it determines that this candidate is not a final solution.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#backtracking_wiki>backtracking_wiki</a>
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#approach_1_backtracking>approach_1_backtracking</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#backtracking_wiki>backtracking_wiki</a><a id="backtracking_wiki"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Backtracking Wikipedia page
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#backtracking>backtracking</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Backtracking">https://en.wikipedia.org/wiki/Backtracking</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#visualized_using_graph>visualized_using_graph</a><a id="visualized_using_graph"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Can be visualized using graph (tree?). At any instance, can be at only one of the nodes.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#approach_1_backtracking>approach_1_backtracking</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#select_candidates_in_order>select_candidates_in_order</a><a id="select_candidates_in_order"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
An important detail on choosing the next number is that they are selected in order, where the total candidates are a list. Once a candidate is added to the current combination, there is no looking back at the previous candidates in the next explorations.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#handling_distinction>handling_distinction</a>, <a href=#approach_1_backtracking>approach_1_backtracking</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#depth_first_traversal>depth_first_traversal</a><a id="depth_first_traversal"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
The backtracking algorithm is unfolded as Depth-First Tree Traversal, or DFS.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#often_implemented_recursively>often_implemented_recursively</a>
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#approach_1_backtracking>approach_1_backtracking</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#often_implemented_recursively>often_implemented_recursively</a><a id="often_implemented_recursively"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Often implemented with recursion
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#depth_first_traversal>depth_first_traversal</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#use_of_remainder>use_of_remainder</a><a id="use_of_remainder"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Use of remainder variable to keep track of how much to the target is remaining. Base case remain==0 means a combination has been found, remain &lt; 0 means value has been exceeded and exploration ceases.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#dynamic_programming>dynamic_programming</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#time_complexity>time_complexity</a><a id="time_complexity"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
O(N^(T/M + 1)) where N is number of candidates, T is target value, and M is the minimal value among the candidates.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#space_complexity>space_complexity</a> (related)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#approach_1_backtracking>approach_1_backtracking</a>
</td>
</tr>
<tr>
<td>
remarks
</td>
<td>
not sure how this was derived, but this was an interestingly precise O number.
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#space_complexity>space_complexity</a><a id="space_complexity"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
O(T/M)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#approach_1_backtracking>approach_1_backtracking</a>, <a href=#time_complexity>time_complexity</a>
</td>
</tr>
<tr>
<td>
remarks
</td>
<td>
similar to the time complexity, very specific. Not sure how it was derived.
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#intuition_basically_correct>intuition_basically_correct</a><a id="intuition_basically_correct"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
I think my intuition for this one was basically correct for this, though I thought the solution was an example of dynamic programming, not backtracking, even though I wrote down both. there's clearly a bunch of algorithms that make use of the backtracking pattern, so it'll be worth looking into in greater detail.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#approach_1_backtracking>approach_1_backtracking</a>, <a href=#intuition>intuition</a>
</td>
</tr>
</table><br>
</p>
</div>
</body>
</html>
