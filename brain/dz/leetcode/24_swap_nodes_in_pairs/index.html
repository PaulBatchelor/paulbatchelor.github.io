<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/brain/css/style.css">

</head>
<body>
<div id="main">
<p><title>leetcode/24_swap_nodes_in_pairs</title>
<h1>24_swap_nodes_in_pairs</h1>
<a href="/brain/dz">dz</a> / <a href="/brain/dz/leetcode">leetcode</a> / <a href="/brain/dz/leetcode/24_swap_nodes_in_pairs">24_swap_nodes_in_pairs</a>
<p></p>
<h2>Summary</h2>
<p>
24. Swap Nodes in Pairs. Given a linked list, swap every two adjacent nodes and  return its head. You must solve the problem without  modifying the values in the list's nodes (i.e., only nodes  themselves may be changed.)
</p>
<h2>Node Tree</h2>
<ul>
<li>
<a href=#URL>URL</a></li>
<li>
<a href=#editorial>editorial</a><ul>
<li>
<a href=#approach_1_recursion>approach_1_recursion</a></li>
<li>
<a href=#approach_2_iteration>approach_2_iteration</a><ul>
<li>
<a href=#dummy_node>dummy_node</a></li>
<li>
<a href=#working_out_approach_2>working_out_approach_2</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href=#intuition>intuition</a><ul>
<li>
<a href=#visualize>visualize</a></li>
<li>
<a href=#approach_2_iteration>approach_2_iteration</a><ul>
<li>
<a href=#dummy_node>dummy_node</a></li>
<li>
<a href=#working_out_approach_2>working_out_approach_2</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href=#swap_algo>swap_algo</a><ul>
<li>
<a href=#working_out>working_out</a><ul>
<li>
<a href=#approach_2_iteration>approach_2_iteration</a><ul>
<li>
<a href=#dummy_node>dummy_node</a></li>
<li>
<a href=#working_out_approach_2>working_out_approach_2</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>Nodes</h2>
<table border="1px">
<tr>
<td colspan=2>
<a href=#URL>URL</a><a id="URL"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
URL
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://leetcode.com/problems/swap-nodes-in-pairs">https://leetcode.com/problems/swap-nodes-in-pairs</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#intuition>intuition</a><a id="intuition"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
This is another linked list manipulation problem. It's more about getting the details right. I've stated this before, but I'm not a fan of these kinds of problems in coding interviews because it can be easy to miss the details in a stressful situation. The gist of this comes down updating pointer values in a loop. Drawing a picture and visualizing this is best in my experience.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#visualize>visualize</a>, <a href=#approach_2_iteration>approach_2_iteration</a> (This is the approach I thought up.)
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#visualize>visualize</a><a id="visualize"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
A-&gt;B-&gt;C-&gt;D becomes B-&gt;A-&gt;D-&gt;C. Swapping happens in pairs two at a time, so the intermediate lists would look like B-&gt;A-&gt;C-&gt;D, then B-&gt;A-&gt;D-&gt;C.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition>intuition</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#swap_algo>swap_algo</a><a id="swap_algo"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Run while value "node" is not null. Let A = node, B = node.next. Update current node. node = B.next. Swap: update B.next = A. Clear A next: A.next = NULL.  Update previous node, if not null: prev.next = A. Update previous node: prev = A.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#working_out>working_out</a> (working out this algorithm)
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#working_out>working_out</a><a id="working_out"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Working out this algo. A-&gt;B-&gt;C-&gt;D. B-&gt;A-&gt;NULL C-&gt;D. node=C, prev=A. B-&gt;A-&gt;NULL, D-&gt;C-&gt;NULL. B-&gt;A-&gt;D-&gt;C. node=NULL, prev=C. END.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#approach_2_iteration>approach_2_iteration</a> (worked out my algorithm after reading this one to make sure mine works. I think it does?)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#swap_algo>swap_algo</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#editorial>editorial</a><a id="editorial"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
editorial
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#approach_1_recursion>approach_1_recursion</a>, <a href=#approach_2_iteration>approach_2_iteration</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#approach_1_recursion>approach_1_recursion</a><a id="approach_1_recursion"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Approach 1 uses recursion. As an input it takes in a head, and it returns a new head. Base case is when the head is null, meaning it has reached the end of the list. Each call swaps the two nodes, and returns the new head. Head and head-&gt;next make A, B. A.next = swap(B.next), and B.next = A.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#editorial>editorial</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#approach_2_iteration>approach_2_iteration</a><a id="approach_2_iteration"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
This was basically the approach I came up with. In my algorithm, I cleared the pointer of the value and waited until the next iteration to update it (the last iteration would leave it empty, making it the end of the list). Using my notation, this algorithm does this: A.next = B.next, B.next=A. prev.next=B.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#dummy_node>dummy_node</a> (lots of dummy nodes used in linked list ops), <a href=#working_out_approach_2>working_out_approach_2</a>
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#working_out>working_out</a>, <a href=#editorial>editorial</a>, <a href=#intuition>intuition</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#working_out_approach_2>working_out_approach_2</a><a id="working_out_approach_2"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Working out the iterative approach. A-&gt;B-&gt;C-&gt;D. A-&gt;C-&gt;D. B-&gt;A-&gt;C-&gt;D. B-&gt;A-&gt;C-&gt;NULL. B-&gt;A-&gt;C, D-&gt;C. B-&gt;A-&gt;D-&gt;C.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#approach_2_iteration>approach_2_iteration</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#dummy_node>dummy_node</a><a id="dummy_node"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
They sure do like to use dummy nodes in these solutions will probably need to study this. Maybe this is just to avoid NULL checks?
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#approach_2_iteration>approach_2_iteration</a>
</td>
</tr>
</table><br>
</p>
</div>
</body>
</html>
