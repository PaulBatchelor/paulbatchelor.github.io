<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/brain/css/style.css">

</head>
<body>
<div id="main">
<p><title>leetcode/17_letter_combinations_phone_number</title>
<h1>17_letter_combinations_phone_number</h1>
<a href="/brain/dz">dz</a> / <a href="/brain/dz/leetcode">leetcode</a> / <a href="/brain/dz/leetcode/17_letter_combinations_phone_number">17_letter_combinations_phone_number</a>
<p></p>
<h2>Summary</h2>
<p>
Letter Combinations of a Phone Number Given a string containing digits from 2-9 inclusive, return  all possible letter combinations that the number could  represent. Return the answer in any order. A mapping of digits to letters (just like on the telephone  buttons) is given below. Note that 1 does not map to any  letters.
</p>
<h2>Node Tree</h2>
<ul>
<li>
<a href=#intuition>intuition</a><ul>
<li>
<a href=#flatten_loop>flatten_loop</a><ul>
<li>
<a href=#counter>counter</a></li>
</ul>
</li>
<li>
<a href=#lookup_table>lookup_table</a></li>
</ul>
</li>
<li>
<a href=#URL>URL</a></li>
<li>
<a href=#editorial>editorial</a><ul>
<li>
<a href=#lock_in_letters>lock_in_letters</a></li>
<li>
<a href=#recursion_reason_why_digits_size_small>recursion_reason_why_digits_size_small</a></li>
<li>
<a href=#recursive_solution>recursive_solution</a><ul>
<li>
<a href=#recursion_explanation>recursion_explanation</a></li>
</ul>
</li>
<li>
<a href=#solutions_mine_vs_theirs>solutions_mine_vs_theirs</a></li>
<li>
<a href=#backtracking_function>backtracking_function</a></li>
</ul>
</li>
</ul>
<h2>Nodes</h2>
<table border="1px">
<tr>
<td colspan=2>
<a href=#URL>URL</a><a id="URL"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
URL
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/">https://leetcode.com/problems/letter-combinations-of-a-phone-number/</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#intuition>intuition</a><a id="intuition"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Combinatorial problem (I think I have the terminology correct). My gut says this is mostly about setting up the loops properly. The first digit has 3-4 possible letters, then the second has 3-4, then the next, etc. Limit is 4 digit.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#flatten_loop>flatten_loop</a>, <a href=#lookup_table>lookup_table</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#flatten_loop>flatten_loop</a><a id="flatten_loop"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
You could compute the number of combinations ahead of time. For instance, "23" should have 3^2 or 9 combinations. a loop would need to run exactly 9 times to get all the combinations
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#counter>counter</a> (State managed in the loop)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition>intuition</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#counter>counter</a><a id="counter"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
You could keep track of state in a fixed-array as a kind of counter, where every digit goes 0,1,2 or 0,1,2,3 depending on size. Every time the rightmost digit goes back to zero, update every other digit. It's sort of like a weird base number system that's mostly base 3.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#flatten_loop>flatten_loop</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#lookup_table>lookup_table</a><a id="lookup_table"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Lookup table for numbers is needed. You really just need an array where a number maps to a string. 9 is four letters, the rest are 3.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition>intuition</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#editorial>editorial</a><a id="editorial"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Leetcode Editorial
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#lock_in_letters>lock_in_letters</a>, <a href=#recursion_reason_why_digits_size_small>recursion_reason_why_digits_size_small</a>, <a href=#recursive_solution>recursive_solution</a>, <a href=#solutions_mine_vs_theirs>solutions_mine_vs_theirs</a>, <a href=#backtracking_function>backtracking_function</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#recursive_solution>recursive_solution</a><a id="recursive_solution"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
The suggestion in the editorial is to use recursion, which makes sense. A language like LISP could probably express this quite elegantly.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#recursion_explanation>recursion_explanation</a>
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#editorial>editorial</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#lock_in_letters>lock_in_letters</a><a id="lock_in_letters"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
The phrase "lock in letters" is used.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#editorial>editorial</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#backtracking_function>backtracking_function</a><a id="backtracking_function"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
The recursive function is referred to as a "backtracking function".
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#editorial>editorial</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#recursion_reason_why_digits_size_small>recursion_reason_why_digits_size_small</a><a id="recursion_reason_why_digits_size_small"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
I noticed that the constraints for the input digits was very small (4 max). In the past, this has been a hint for a dynamic programming solution. But, this one could be related to recursion? (also, combinations can get quite large quite quickly).
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#editorial>editorial</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#recursion_explanation>recursion_explanation</a><a id="recursion_explanation"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
The idea here is you are using recursion to build up a string, which implicitely is like having a nested loop of arbitrary size. You start with an empty, string, add characters to it. The recursive call appends a letter to the end of the string, and moves the index position forward one. When a string is the length of the number of digits (base case), it gets appeneded to a list of combinations.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#recursive_solution>recursive_solution</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#solutions_mine_vs_theirs>solutions_mine_vs_theirs</a><a id="solutions_mine_vs_theirs"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
My solution ultimately was about pre-computing the number of combinations and in a loop computing the combinations with a means of keeping track of state. The leetcode solution involved expressing that problem in terms of recursion. My solution was more imperative, something you'd think about writing in a language like C where stack smashing is real. My solution would scale better than the recursive solution. But, it is less expressive. This problem is very well suited for a functional programming language.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#editorial>editorial</a>
</td>
</tr>
</table><br>
</p>
</div>
</body>
</html>
