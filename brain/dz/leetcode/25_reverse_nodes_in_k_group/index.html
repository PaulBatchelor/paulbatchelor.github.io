<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/brain/css/style.css">

</head>
<body>
<div id="main">
<p><title>leetcode/25_reverse_nodes_in_k_group</title>
<h1>25_reverse_nodes_in_k_group</h1>
<a href="/brain/dz">dz</a> / <a href="/brain/dz/leetcode">leetcode</a> / <a href="/brain/dz/leetcode/25_reverse_nodes_in_k_group">25_reverse_nodes_in_k_group</a>
<p></p>
<h2>Summary</h2>
<p>
25. Reverse Nodes in K Group. Given the head of a linked list, reverse the nodes of the  list k at a time, and return the modified list. k is a positive integer and is less than or equal to the  length of the linked list. If the number of nodes is not  a multiple of k then left-out nodes, in the end, should  remain as it is. You may not alter the values in the list's nodes, only  nodes themselves may be changed.
</p>
<h2>Node Tree</h2>
<ul>
<li>
<a href=#URL>URL</a></li>
<li>
<a href=#approximate_algorithm>approximate_algorithm</a><ul>
<li>
<a href=#reverse_list>reverse_list</a></li>
</ul>
</li>
<li>
<a href=#editorial>editorial</a><ul>
<li>
<a href=#approach_1_recursion>approach_1_recursion</a><ul>
<li>
<a href=#recursion_works_well_for_linked_lists>recursion_works_well_for_linked_lists</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href=#intuition>intuition</a><ul>
<li>
<a href=#approach_2_iterative>approach_2_iterative</a><ul>
<li>
<a href=#forgot_about_the_new_head>forgot_about_the_new_head</a></li>
</ul>
</li>
<li>
<a href=#forgot_about_the_new_head>forgot_about_the_new_head</a></li>
<li>
<a href=#how_to_use_dummy_node>how_to_use_dummy_node</a></li>
</ul>
</li>
</ul>
<h2>Nodes</h2>
<table border="1px">
<tr>
<td colspan=2>
<a href=#URL>URL</a><a id="URL"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
URL
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://leetcode.com/problems/reverse-nodes-in-k-group/">https://leetcode.com/problems/reverse-nodes-in-k-group/</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#intuition>intuition</a><a id="intuition"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Thinking about a linked list in terms of chunks/blocks of size k. A block can be defined in terms of the start and end node. A reverse operation on a block updates the links to be reverse flow, the start becomes the end and then becomes the start. These start/end blocks then need to be properly linked to the neighboring blocks, the previous end points to the current start.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#approach_2_iterative>approach_2_iterative</a> (similar to what I thought of), <a href=#forgot_about_the_new_head>forgot_about_the_new_head</a> (detail I forgot), <a href=#how_to_use_dummy_node>how_to_use_dummy_node</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#how_to_use_dummy_node>how_to_use_dummy_node</a><a id="how_to_use_dummy_node"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
They keep using dummy nodes in the answers to these questions, I'm not used to thinking that way.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition>intuition</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#approximate_algorithm>approximate_algorithm</a><a id="approximate_algorithm"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Start with the head, set to start. In a loop, iterate k times to get start/end. If no null, found, reverse segment with start/end, and swap. Link previous end to start. Set current end to previous. If null was found in current block, break.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#reverse_list>reverse_list</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#reverse_list>reverse_list</a><a id="reverse_list"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
There are multiple ways to reverse a linked list. Since k is rather large (5000), using a stack-based recursion approach is probably out of the question. A-&gt;B-&gt;C-&gt;D becomes A&lt;-B&lt;-C&lt;-D. So, this should be able to be done in pairs iteratively.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#approximate_algorithm>approximate_algorithm</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#editorial>editorial</a><a id="editorial"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
editorial
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#approach_1_recursion>approach_1_recursion</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#approach_1_recursion>approach_1_recursion</a><a id="approach_1_recursion"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Approach 1 is recursion (even though there's a space constraint). Basically start with a head, and reverse-append. There are two pointers to keep track of. "head" pointer is passed to the function call. "rev-head" is something that recursion will return to the caller. User a counter to keep track of k nodes and break when it reaches k.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#recursion_works_well_for_linked_lists>recursion_works_well_for_linked_lists</a>
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#editorial>editorial</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#recursion_works_well_for_linked_lists>recursion_works_well_for_linked_lists</a><a id="recursion_works_well_for_linked_lists"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Recursion works well for linked lists because a subset of a linked list is another linked list.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#approach_1_recursion>approach_1_recursion</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#approach_2_iterative>approach_2_iterative</a><a id="approach_2_iterative"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Instead of using the stack and imagining the problem recursively, introduce a few new variables. In addition to =rev= and =rev_head=, also include =ktail=, the tail of the previous k nodes after reversal, and =new_head=, the head of the final list after output.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#forgot_about_the_new_head>forgot_about_the_new_head</a>
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition>intuition</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#forgot_about_the_new_head>forgot_about_the_new_head</a><a id="forgot_about_the_new_head"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
In the solution I thought up, I forgot about returning the new head, which is the kth element in the list.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition>intuition</a>, <a href=#approach_2_iterative>approach_2_iterative</a>
</td>
</tr>
</table><br>
</p>
</div>
</body>
</html>
