<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/brain/css/style.css">

</head>
<body>
<div id="main">
<p><title>leetcode/container_with_most_water</title>
<h1>container_with_most_water</h1>
<a href="/brain/dz">dz</a> / <a href="/brain/dz/leetcode">leetcode</a> / <a href="/brain/dz/leetcode/container_with_most_water">container_with_most_water</a>
<p></p>
<h2>Summary</h2>
<p>
You are given an integer array height of length n. There  are n vertical lines drawn such that the two endpoints of  the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a  container, such that the container contains the most  water. Return the maximum amount of water a container can store.
</p>
<h2>Node Tree</h2>
<ul>
<li>
<a href=#intuition>intuition</a><ul>
<li>
<a href=#intuition_brute_force>intuition_brute_force</a><ul>
<li>
<a href=#intuition_brute_force_v2>intuition_brute_force_v2</a></li>
</ul>
</li>
<li>
<a href=#intuition_brute_force_v2>intuition_brute_force_v2</a></li>
<li>
<a href=#intuition_post_hints>intuition_post_hints</a><ul>
<li>
<a href=#while_loop_not_for_loop>while_loop_not_for_loop</a></li>
<li>
<a href=#proof_harder_than_implementation>proof_harder_than_implementation</a></li>
<li>
<a href=#two_pointer>two_pointer</a><ul>
<li>
<a href=#while_loop_not_for_loop>while_loop_not_for_loop</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href=#URL>URL</a></li>
<li>
<a href=#does_sorting_help>does_sorting_help</a></li>
<li>
<a href=#editorial>editorial</a><ul>
<li>
<a href=#proof>proof</a><ul>
<li>
<a href=#proof_by_elimination>proof_by_elimination</a></li>
<li>
<a href=#proof_harder_than_implementation>proof_harder_than_implementation</a></li>
</ul>
</li>
<li>
<a href=#two_pointer>two_pointer</a><ul>
<li>
<a href=#while_loop_not_for_loop>while_loop_not_for_loop</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>Nodes</h2>
<table border="1px">
<tr>
<td colspan=2>
<a href=#URL>URL</a><a id="URL"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
URL
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://leetcode.com/problems/container-with-most-water/">https://leetcode.com/problems/container-with-most-water/</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#intuition>intuition</a><a id="intuition"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
This one took a moment for me to understand. The input array is a set of heights. A rectangular area is formed by taking any two heights, and multiplying the smallest height by the distance between eachother. The largest one maximizes the distance and the heights.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#intuition_brute_force>intuition_brute_force</a>, <a href=#intuition_brute_force_v2>intuition_brute_force_v2</a>, <a href=#intuition_post_hints>intuition_post_hints</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#intuition_brute_force>intuition_brute_force</a><a id="intuition_brute_force"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Brute force solution involves finding the area of every combination, and keeping track of the maximum area.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#intuition_brute_force_v2>intuition_brute_force_v2</a> (iteration)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition>intuition</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#intuition_brute_force_v2>intuition_brute_force_v2</a><a id="intuition_brute_force_v2"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
For any two heights, the smallest is chosen, which means you can skip some computations. For example, only comparing a given height with heights greater than itself. This cuts the pairs in half.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition>intuition</a>, <a href=#intuition_brute_force>intuition_brute_force</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#does_sorting_help>does_sorting_help</a><a id="does_sorting_help"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
If the list was sorted, would this help with performance? The largest height could be tested with all the other heights (n - 1). The second largest with the other heights (n - 2), (n - 1) + (n - 2) + (n - 3) ... There's probably some equation for this, but I think it's more efficient.
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#intuition_post_hints>intuition_post_hints</a><a id="intuition_post_hints"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Hints about moving left and right. It's not quite divide and conquer, but I think I remember an algorithm talking about this. Start at the maximum distance (start/end of array), and move inwards towards the center. At each step, you move the one that points towards the lower line. I think it can be proved that this works without missing any big heights.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#while_loop_not_for_loop>while_loop_not_for_loop</a> (I was thinking about a for loop, not a while loop), <a href=#proof_harder_than_implementation>proof_harder_than_implementation</a> (even though I was mostly correct, I didn't understand why I was correct), <a href=#two_pointer>two_pointer</a> (Turns out I was on the right track)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition>intuition</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#editorial>editorial</a><a id="editorial"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
LeetCode Editorial
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#proof>proof</a> (elaboration on solution discussed here), <a href=#two_pointer>two_pointer</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#proof>proof</a><a id="proof"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Post I found with the solution (two-pointer) and the proof.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#proof_by_elimination>proof_by_elimination</a>, <a href=#proof_harder_than_implementation>proof_harder_than_implementation</a>
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#editorial>editorial</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://leimao.github.io/blog/Proof-Container-With-Most-Water-Problem/">https://leimao.github.io/blog/Proof-Container-With-Most-Water-Problem/</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#two_pointer>two_pointer</a><a id="two_pointer"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
They call this the "two-pointer" solution, and it's pretty much what I thought up after looking at the hints.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#while_loop_not_for_loop>while_loop_not_for_loop</a>
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#editorial>editorial</a>, <a href=#intuition_post_hints>intuition_post_hints</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#while_loop_not_for_loop>while_loop_not_for_loop</a><a id="while_loop_not_for_loop"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
The thing I didn't quite get right with my intuition was that it would be something that moves towards the center, so you'd use a for-loop that would go N/2 steps. Of course, if I had actually worked it out, it would clearly not behave like that. Instead, it's a while loop that's runs as long as the left is smaller than the right. It converges in O(N) time, single pass.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#two_pointer>two_pointer</a>, <a href=#intuition_post_hints>intuition_post_hints</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#proof_by_elimination>proof_by_elimination</a><a id="proof_by_elimination"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
The proof described here is succintly described as "proof by elimination". It goes through the two pointer problem, and shows how each iteration uniquely eliminates a certain number of candidates.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#proof>proof</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#proof_harder_than_implementation>proof_harder_than_implementation</a><a id="proof_harder_than_implementation"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
I agree with the conclusion presented here, which is essentially that you can come up with a solution pretty quickly that passes the tests, but not know formally why or how it works.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#proof>proof</a>, <a href=#intuition_post_hints>intuition_post_hints</a>
</td>
</tr>
</table><br>
</p>
</div>
</body>
</html>
