<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/brain/css/style.css">

</head>
<body>
<div id="main">
<p><title>leetcode/31_next_permutation</title>
<h1>31_next_permutation</h1>
<a href="/brain/dz">dz</a> / <a href="/brain/dz/leetcode">leetcode</a> / <a href="/brain/dz/leetcode/31_next_permutation">31_next_permutation</a>
<p></p>
<h2>Summary</h2>
<p>
A permutation of an array of integers is an arrangement  of its members into a sequence or linear order. For example, for arr = [1,2,3], the following are all the  permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3,  1], [3,1,2], [3,2,1]. The next permutation of an array of integers is the next  lexicographically greater permutation of its integer.  More formally, if all the permutations of the array are  sorted in one container according to their  lexicographical order, then the next permutation of that  array is the permutation that follows it in the sorted  container. If such arrangement is not possible, the array  must be rearranged as the lowest possible order (i.e.,  sorted in ascending order). For example, the next permutation of arr = [1,2,3] is  [1,3,2]. Similarly, the next permutation of arr = [2,3,1] is  [3,1,2]. While the next permutation of arr = [3,2,1] is [1,2,3]  because [3,2,1] does not have a lexicographical larger  rearrangement. Given an array of integers nums, find the next  permutation of nums. The replacement must be in place and use only constant  extra memory.
</p>
<h2>Node Tree</h2>
<ul>
<li>
<a href=#URL>URL</a></li>
<li>
<a href=#editorial>editorial</a><ul>
<li>
<a href=#permutations_wikipedia>permutations_wikipedia</a></li>
<li>
<a href=#approach_1_brute_force>approach_1_brute_force</a></li>
</ul>
</li>
<li>
<a href=#intuition>intuition</a><ul>
<li>
<a href=#recursion_maybe>recursion_maybe</a></li>
<li>
<a href=#upfront_reading>upfront_reading</a><ul>
<li>
<a href=#next_permutation_def>next_permutation_def</a></li>
</ul>
</li>
<li>
<a href=#what_does_4_look_like>what_does_4_look_like</a><ul>
<li>
<a href=#sweep_to_swap_point>sweep_to_swap_point</a><ul>
<li>
<a href=#sweep_swap_ex>sweep_swap_ex</a><ul>
<li>
<a href=#recursion_maybe>recursion_maybe</a></li>
</ul>
</li>
<li>
<a href=#approach_2_single_pass>approach_2_single_pass</a><ul>
<li>
<a href=#how_to_visualize_this>how_to_visualize_this</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href=#largest_permutation>largest_permutation</a><ul>
<li>
<a href=#reverse_smallest_to_largest>reverse_smallest_to_largest</a><ul>
<li>
<a href=#approach_2_single_pass>approach_2_single_pass</a><ul>
<li>
<a href=#how_to_visualize_this>how_to_visualize_this</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href=#smallest_permutation>smallest_permutation</a><ul>
<li>
<a href=#reverse_smallest_to_largest>reverse_smallest_to_largest</a><ul>
<li>
<a href=#approach_2_single_pass>approach_2_single_pass</a><ul>
<li>
<a href=#how_to_visualize_this>how_to_visualize_this</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href=#approach_2_single_pass>approach_2_single_pass</a><ul>
<li>
<a href=#how_to_visualize_this>how_to_visualize_this</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>Nodes</h2>
<table border="1px">
<tr>
<td colspan=2>
<a href=#URL>URL</a><a id="URL"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
URL
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://leetcode.com/problems/next-permutation">https://leetcode.com/problems/next-permutation</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#intuition>intuition</a><a id="intuition"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
intuition
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#recursion_maybe>recursion_maybe</a> (feels like it could be expressed recursively), <a href=#upfront_reading>upfront_reading</a>, <a href=#what_does_4_look_like>what_does_4_look_like</a>, <a href=#largest_permutation>largest_permutation</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#upfront_reading>upfront_reading</a><a id="upfront_reading"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Lots of upfront reading. Reading now.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#next_permutation_def>next_permutation_def</a>
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition>intuition</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#next_permutation_def>next_permutation_def</a><a id="next_permutation_def"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
This is establishing a formal definition with examples. So it's basically saying there's an order (for integers, it's just their numerical values?), and you need to determine what the next largest one in the sequence is. There's also the edge case where there is no greater sequence and you "wrap-around" to the smallest permutation.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#upfront_reading>upfront_reading</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#largest_permutation>largest_permutation</a><a id="largest_permutation"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
"lexographically" speaking, a permutation ABC is greatest if A&gt;=B&gt;=C.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#reverse_smallest_to_largest>reverse_smallest_to_largest</a>, <a href=#smallest_permutation>smallest_permutation</a> (ergo), <a href=#approach_2_single_pass>approach_2_single_pass</a> (got this relationship)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition>intuition</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#smallest_permutation>smallest_permutation</a><a id="smallest_permutation"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Consequently, the smallest permutation ABC is A&lt;=B&lt;=C.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#reverse_smallest_to_largest>reverse_smallest_to_largest</a>
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#largest_permutation>largest_permutation</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#reverse_smallest_to_largest>reverse_smallest_to_largest</a><a id="reverse_smallest_to_largest"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
The smallest permutation can be obtained by reversing the order of the permutation. And vice versa.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#approach_2_single_pass>approach_2_single_pass</a> (interestingly, the solution here involved using this property)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#smallest_permutation>smallest_permutation</a>, <a href=#largest_permutation>largest_permutation</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#what_does_4_look_like>what_does_4_look_like</a><a id="what_does_4_look_like"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
These examples are all in 3. But what would 4 look like? Supposing I have 1234 (the smallest). What would the next one be? 1243 is my guess, because it feels like counting. 1324 comes next. then 1342, 1423, 1432, 2134, 2314.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#sweep_to_swap_point>sweep_to_swap_point</a>
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition>intuition</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#sweep_to_swap_point>sweep_to_swap_point</a><a id="sweep_to_swap_point"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Okay, I'm seeing a pattern. Starting from the right, move until you hit a point where the left value is less than the right value. This left value becomes the swap point and swaps with the rightmost (least significant) value. Sort all the values to the right until they are in ascending order left to right.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#sweep_swap_ex>sweep_swap_ex</a> (example.), <a href=#approach_2_single_pass>approach_2_single_pass</a> (on the right track)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#what_does_4_look_like>what_does_4_look_like</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#sweep_swap_ex>sweep_swap_ex</a><a id="sweep_swap_ex"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Next point after 1243. rightmost is 3. the index at the value 2 is the swap point because 2&lt;4. Swap to become 1342, then sort the last 2 indices to be 1324.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#recursion_maybe>recursion_maybe</a> (possibly expressed recursively?)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#sweep_to_swap_point>sweep_to_swap_point</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#recursion_maybe>recursion_maybe</a><a id="recursion_maybe"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
I belive the rightmost value will always be the least signficant value, and this will be swapped with some other value. In my previous attempt, I swapped, then sorted in two steps, but I bet you could recursively swap until some end condition is met.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition>intuition</a>, <a href=#sweep_swap_ex>sweep_swap_ex</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#editorial>editorial</a><a id="editorial"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
editorial
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#permutations_wikipedia>permutations_wikipedia</a> (followup), <a href=#approach_1_brute_force>approach_1_brute_force</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#approach_1_brute_force>approach_1_brute_force</a><a id="approach_1_brute_force"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
The brute force algorithm would be to generate all possible permutations in order, and find the next one. This one is only hypothetically introduced, as it would be exceedingly inefficient to practically use.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#editorial>editorial</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#approach_2_single_pass>approach_2_single_pass</a><a id="approach_2_single_pass"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
I got far enough to understand that you needed to find a pair of values starting from the right where the right value is greater than the left value. I was incorrect that the rightmost value would be the value to swap. You actually take the leftmost value, and find the next largest value after that in the rightmost segment. The trickiest logical leap here was knowing how to reversing the rightmost segment after making the swap. Before the swap, everything up to the found left value is the greatest possible subset-permutation, which has the property A&gt;=B&gt;=C. Reversing this wraps-around to the smallest permutation CBA, C&lt;=B&lt;=A. Here's the tricky bit: when the swap between the left value and the next greatest value in the right segment happens, this property still holds.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#how_to_visualize_this>how_to_visualize_this</a>
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#largest_permutation>largest_permutation</a>, <a href=#sweep_to_swap_point>sweep_to_swap_point</a>, <a href=#reverse_smallest_to_largest>reverse_smallest_to_largest</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#how_to_visualize_this>how_to_visualize_this</a><a id="how_to_visualize_this"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
There's a lot of intuition one needs to build up to understand this problem. I don't know if I could have made these leaps or have been able to do everything correctly.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#approach_2_single_pass>approach_2_single_pass</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#permutations_wikipedia>permutations_wikipedia</a><a id="permutations_wikipedia"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
The "Permutations in Computing" section has a bit on this sort of problem called "Generation in lexicographic order", which is probably worth a read to better understand this.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#editorial>editorial</a>
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/Permutation#Permutations_in_computing">https://en.wikipedia.org/wiki/Permutation#Permutations_in_computing</a>
</td>
</tr>
</table><br>
</p>
</div>
</body>
</html>
