<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/brain/css/style.css">

</head>
<body>
<div id="main">
<p><title>leetcode/41_first_missing_positive</title>
<h1>41_first_missing_positive</h1>
<a href="/brain/dz">dz</a> / <a href="/brain/dz/leetcode">leetcode</a> / <a href="/brain/dz/leetcode/41_first_missing_positive">41_first_missing_positive</a>
<p></p>
<h2>Summary</h2>
<p>
Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums. You must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.
</p>
<h2>Node Tree</h2>
<ul>
<li>
<a href=#URL>URL</a></li>
<li>
<a href=#editorial>editorial</a><ul>
<li>
<a href=#1_index_as_hash_key>1_index_as_hash_key</a><ul>
<li>
<a href=#remove_non_positive>remove_non_positive</a><ul>
<li>
<a href=#can_get_of_numbers_larger_than_n>can_get_of_numbers_larger_than_n</a><ul>
<li>
<a href=#toggle_negative_numbers_in_place>toggle_negative_numbers_in_place</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href=#use_hash_map_non_constant>use_hash_map_non_constant</a><ul>
<li>
<a href=#toggle_negative_numbers_in_place>toggle_negative_numbers_in_place</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href=#intuition>intuition</a><ul>
<li>
<a href=#attempt_1>attempt_1</a></li>
<li>
<a href=#constant_space>constant_space</a></li>
<li>
<a href=#how_to_account_for_not_present>how_to_account_for_not_present</a><ul>
<li>
<a href=#what_does_sorting_get_you>what_does_sorting_get_you</a><ul>
<li>
<a href=#sorted_approach>sorted_approach</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href=#non_constant_space>non_constant_space</a><ul>
<li>
<a href=#some_kind_of_binary_tree_check>some_kind_of_binary_tree_check</a></li>
<li>
<a href=#use_a_data_structure>use_a_data_structure</a><ul>
<li>
<a href=#some_kind_of_binary_tree_check>some_kind_of_binary_tree_check</a></li>
<li>
<a href=#use_hash_map_non_constant>use_hash_map_non_constant</a><ul>
<li>
<a href=#toggle_negative_numbers_in_place>toggle_negative_numbers_in_place</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>Nodes</h2>
<table border="1px">
<tr>
<td colspan=2>
<a href=#URL>URL</a><a id="URL"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
URL
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://leetcode.com/problems/first-missing-positive">https://leetcode.com/problems/first-missing-positive</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#intuition>intuition</a><a id="intuition"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
intuition
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#attempt_1>attempt_1</a> (wrong because it fails to recognize the "not present"), <a href=#constant_space>constant_space</a>, <a href=#how_to_account_for_not_present>how_to_account_for_not_present</a>, <a href=#non_constant_space>non_constant_space</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#attempt_1>attempt_1</a><a id="attempt_1"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Find the minimum integer greater than zero, call in M, M-(M-1) gives the answer.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition>intuition</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#how_to_account_for_not_present>how_to_account_for_not_present</a><a id="how_to_account_for_not_present"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
How does one account for "not present" in unsorted array?
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#what_does_sorting_get_you>what_does_sorting_get_you</a>
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition>intuition</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#what_does_sorting_get_you>what_does_sorting_get_you</a><a id="what_does_sorting_get_you"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
What does sorting get you? Does that count?
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#sorted_approach>sorted_approach</a>
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#how_to_account_for_not_present>how_to_account_for_not_present</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#sorted_approach>sorted_approach</a><a id="sorted_approach"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
if list is pre-sorted, one could do a linear sweep of sorts. The first missing positive integer would be a jump greater than 0.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#what_does_sorting_get_you>what_does_sorting_get_you</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#non_constant_space>non_constant_space</a><a id="non_constant_space"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
one hint says to think about non constant space...
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#some_kind_of_binary_tree_check>some_kind_of_binary_tree_check</a> (hint says to think about trying to rework it in constant space), <a href=#use_a_data_structure>use_a_data_structure</a>
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition>intuition</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#use_a_data_structure>use_a_data_structure</a><a id="use_a_data_structure"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
I bet this involves a data structure. Some kind of tree. You could populate the tree in one pass, then check the tree for holes.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#some_kind_of_binary_tree_check>some_kind_of_binary_tree_check</a>, <a href=#use_hash_map_non_constant>use_hash_map_non_constant</a> (I was thinking about trees not hash maps. oops)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#non_constant_space>non_constant_space</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#constant_space>constant_space</a><a id="constant_space"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
constant space
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition>intuition</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#some_kind_of_binary_tree_check>some_kind_of_binary_tree_check</a><a id="some_kind_of_binary_tree_check"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Instead of having it be an actual tree, you might be able to rework it so it only saves one item at a time, and have it do some kind of special check in the loop. The hint also reminds that O(n)=O(2n), so that would suggest that there could also be a sweep.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#non_constant_space>non_constant_space</a>, <a href=#use_a_data_structure>use_a_data_structure</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#editorial>editorial</a><a id="editorial"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
editorial
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#1_index_as_hash_key>1_index_as_hash_key</a>
</td>
</tr>
</table><br>
<p>2024-05-01 16:09:24 I just want to go on the record and say how friggin stupid this problem is. The solution is way too clever and I don't think anyone should be expected to simply come up with this out of thin air.</p>
<table border="1px">
<tr>
<td colspan=2>
<a href=#1_index_as_hash_key>1_index_as_hash_key</a><a id="1_index_as_hash_key"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
approach 1: index as hash key
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#remove_non_positive>remove_non_positive</a>, <a href=#use_hash_map_non_constant>use_hash_map_non_constant</a> (non-constant simpler solution)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#editorial>editorial</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#remove_non_positive>remove_non_positive</a><a id="remove_non_positive"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Removing non-positive integers can be done by replacing them in place with 1. Check for 1 first, and if 1 is not there, then it was going to be your answer to begin with
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#can_get_of_numbers_larger_than_n>can_get_of_numbers_larger_than_n</a>
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#1_index_as_hash_key>1_index_as_hash_key</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#can_get_of_numbers_larger_than_n>can_get_of_numbers_larger_than_n</a><a id="can_get_of_numbers_larger_than_n"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
can also get rid of numbers larger than n, but I don't understand this
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#toggle_negative_numbers_in_place>toggle_negative_numbers_in_place</a> (relies on this I think)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#remove_non_positive>remove_non_positive</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#use_hash_map_non_constant>use_hash_map_non_constant</a><a id="use_hash_map_non_constant"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
hash map positive number -&gt; its presence.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#toggle_negative_numbers_in_place>toggle_negative_numbers_in_place</a> (derived from this)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#1_index_as_hash_key>1_index_as_hash_key</a>, <a href=#use_a_data_structure>use_a_data_structure</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#toggle_negative_numbers_in_place>toggle_negative_numbers_in_place</a><a id="toggle_negative_numbers_in_place"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
The trick here is to use the array itself as a structure to determine if the number is present or not. Say you find the number 3, you'd toggle the value x[3] to be negative, which is a way of knowing that this number exists. So, you're leveraging the negative bit flag, and the mutable nature of the array in order to keep the space constant.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#use_hash_map_non_constant>use_hash_map_non_constant</a>, <a href=#can_get_of_numbers_larger_than_n>can_get_of_numbers_larger_than_n</a>
</td>
</tr>
</table><br>
</p>
</div>
</body>
</html>
