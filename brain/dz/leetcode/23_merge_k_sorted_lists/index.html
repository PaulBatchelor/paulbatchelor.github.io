<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/brain/css/style.css">

</head>
<body>
<div id="main">
<p><title>leetcode/23_merge_k_sorted_lists</title>
<h1>23_merge_k_sorted_lists</h1>
<a href="/brain/dz">dz</a> / <a href="/brain/dz/leetcode">leetcode</a> / <a href="/brain/dz/leetcode/23_merge_k_sorted_lists">23_merge_k_sorted_lists</a>
<p></p>
<h2>Summary</h2>
<p>
23. Merge K sorted listes You are given an array of k linked-lists lists, each  linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.
</p>
<h2>Node Tree</h2>
<ul>
<li>
<a href=#URL>URL</a></li>
<li>
<a href=#editorial>editorial</a><ul>
<li>
<a href=#k_way_merge>k_way_merge</a></li>
<li>
<a href=#collect_and_sort_brute_force>collect_and_sort_brute_force</a></li>
<li>
<a href=#compare_one_by_one>compare_one_by_one</a><ul>
<li>
<a href=#compare_one_by_one_priority_queue>compare_one_by_one_priority_queue</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href=#intuition>intuition</a><ul>
<li>
<a href=#top_item_next>top_item_next</a></li>
<li>
<a href=#brute_force>brute_force</a><ul>
<li>
<a href=#collect_and_sort_brute_force>collect_and_sort_brute_force</a></li>
<li>
<a href=#compare_one_by_one>compare_one_by_one</a><ul>
<li>
<a href=#compare_one_by_one_priority_queue>compare_one_by_one_priority_queue</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>Nodes</h2>
<table border="1px">
<tr>
<td colspan=2>
<a href=#URL>URL</a><a id="URL"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
URL
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://leetcode.com/problems/merge-k-sorted-lists/">https://leetcode.com/problems/merge-k-sorted-lists/</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#intuition>intuition</a><a id="intuition"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
My intuition says to think of the linked list as an implementation detail, and to focus on the algorithm first.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#top_item_next>top_item_next</a>, <a href=#brute_force>brute_force</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#top_item_next>top_item_next</a><a id="top_item_next"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Since they are all pre-sorted, we can know that at any given point in time, the next item in the list is the first item of any of the k lists (the head)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition>intuition</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#brute_force>brute_force</a><a id="brute_force"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
A potential brute force algorithm would involve in each iteration finding the smallest head from each of the k lists, popping it off, and inserting it into a new list. this has a performance of O(max(list[i])*k).
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#collect_and_sort_brute_force>collect_and_sort_brute_force</a> (simpler concept), <a href=#compare_one_by_one>compare_one_by_one</a> (Similar to what I was thinking about.)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#intuition>intuition</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#editorial>editorial</a><a id="editorial"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
editorial
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#k_way_merge>k_way_merge</a> (follow-up reading, this is more information than the editorial), <a href=#collect_and_sort_brute_force>collect_and_sort_brute_force</a>, <a href=#compare_one_by_one>compare_one_by_one</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#collect_and_sort_brute_force>collect_and_sort_brute_force</a><a id="collect_and_sort_brute_force"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
The brute force approach suggested here involves simply appending all the items into some kind of list object, and then using some sorting algorithm (built into the language) to sort it. Nothing really to it.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#editorial>editorial</a>, <a href=#brute_force>brute_force</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#compare_one_by_one>compare_one_by_one</a><a id="compare_one_by_one"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
Compare every k nodes (head of every linked list), and get the node with the smallest value. Append to list.
</td>
</tr>
<tr>
<td>
children
</td>
<td>
<a href=#compare_one_by_one_priority_queue>compare_one_by_one_priority_queue</a> (Optimizes approach with prioirty queue)
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#editorial>editorial</a>, <a href=#brute_force>brute_force</a>
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#compare_one_by_one_priority_queue>compare_one_by_one_priority_queue</a><a id="compare_one_by_one_priority_queue"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
This seems to use a priority queue to do the sorting.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#compare_one_by_one>compare_one_by_one</a>
</td>
</tr>
<tr>
<td>
remarks
</td>
<td>
Solution not explained here, only python code
</td>
</tr>
</table><br>
<table border="1px">
<tr>
<td colspan=2>
<a href=#k_way_merge>k_way_merge</a><a id="k_way_merge"></a>
</td>
</tr>
<tr>
<td>
content
</td>
<td>
k-way merge: a specific type of sequence merge algorithms that specialize in taking in k sorted lists and merging them into a single sorted list.
</td>
</tr>
<tr>
<td>
parents
</td>
<td>
<a href=#editorial>editorial</a>
</td>
</tr>
<tr>
<td>
remarks
</td>
<td>
This gives way more information about the underlying algorithm than LC
</td>
</tr>
<tr>
<td>
hyperlink
</td>
<td>
<a href="https://en.wikipedia.org/wiki/K-way_merge_algorithm">https://en.wikipedia.org/wiki/K-way_merge_algorithm</a>
</td>
</tr>
</table><br>
</p>
</div>
</body>
</html>
