<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/brain/css/style.css">

</head>
<body>
<div id="main">
<title>The Art Of Computer Programming</title>
<h1>The Art Of Computer Programming</h1>
<p>Notes for The Art of Computer Programming series
by Donald E. Knuth.
</p>

<h2>Chapter 1: Basic Concepts</h2>


<h3>1.1 Algorithms</h3>


<h3>1.2 Mathematical Preliminaries</h3>


<h3>1.3 MIX</h3>

<p>See: <a href="/brain/MIX">MIX</a> and <a href="/brain/MIXAL">MIXAL</a>.
</p>

<h3>1.4 Some fundamental programming routines</h3>


<h2>Chapter 2: Information Structures</h2>


<h3>2.2 Linear Lists</h3>

<p>Data usually has much more structural data than we actually want to represent directly in a computer.  [gpuolfjer]
</p>
<p>Consider not only the data structure, but the class of operations to be done on the data.  [gfawddqwk]
</p>
<p>Linear List: sequence of nodes whose essential structure properties involve only the relative positions between items as they appear in a line.  [gpddodpju]
</p>
<p>Linear List Operations: Access, Insert, Delete, Combine, Split, Copy (List), Get Number Of Nodes, Sort, Search.  [guwwkfilp]
</p>
<p>Linear List Types: Stack: insert/delete at end of list, Queue: Insertions made at one end, deletions made at the other end, Deque: insert/delete at both ends.  [gkwwskdla]
</p>
<p>A deque is more general than a stack or queue.  [gdhlrslwo]
</p>
<p>Stacks are particularly useful for the processing of languages with a nested structure.  [gadqiousq]
</p>
<p>What is a Schachtelsatze? (!TAOCP vol1, pg 241).  [gurrlfdfu]
</p>
<p>Stacks generally occur most frequently in connection with explicitly or implicitly recursive algorithms.  [gukeuflup]
</p>
<p>Kind of like how the book references chapters that haven't been published yet. Long term thinking indeed.  [gpadakoqp]
</p>
<p>Special terms for stacks: top of stack, bottom of stack.  [gqesljhpf]
</p>
<p>Knuth does not like push/pop terminology. "The brevity of words 'push' and 'pop' has its advantages, but these terms falsely imply a motion of the whole list within computer memory. Nothing is physically pushed down; items are added onto the top, as in hnaystacks or stacks of boxes".  [gfjdpalhd]
</p>
<p>Terminology for queues: front and rear.  [gidppesse]
</p>
<p>Terminology for deques: left and right.  [gdlfuuhsl]
</p>
<p>Descriptive words in English for stack/deque/queue algorithms: "up-down" for stacks, "waiting in line" for queues, and "left right" for deques.  [giihdlrko]
</p>
<p>Simplest and most natural way to keep a linear list inside a computer is to put the list items in consecutive locations, one node after the other.  [gfshpdwdq]
</p>
<p>LOC(x[j + 1]) = LOC(x[j]) + c. C is the number of words per node.  [gqkiqahdl]
</p>
<p>In general: LOC(X[j]) = L0 + Cj.  [glaahlsrd]
</p>
<p>Sequential allocation is quite convenient for dealing with a stack.  [gpaujjaid]
</p>
<p>T is stack pointer, place Y on top of stack: T <- T+1; X[T] = Y;  [gfpihkaii]
</p>
<p>Queues and Deques get a little bit tricker. Uses two pointers called F and R.  [ghorpjsaj]
</p>
<p>Rear Insert: R <- R+1; X[R] <- Y;  [gasfrlkad]
</p>
<p>Front Remove: F <- F + 1; Y <- X[F]; if F = R, then set F <- R <- 0.  [gpdkedeoh]
</p>
<p>If R stays ahead of F, this approach takes up a lot of space.  [gufwkfufj]
</p>
<p>Better approach: set M nodes aside, arranged implicitely in a circle: if R = M then R <- 1, else R <- R + 1; X[R] <- Y.  And: If F = M, then F <- 1, else F <- F + 1; Y <- X[F].  [gaoahuoai]
</p>
<p>Actions above assume nothing goes wrong, which is quite unrealistic! To fix this, add underflow and overflow.  [gjjfieeai]
</p>
<p>Work on exersize 1. Apparently discusses nontrival aspect of this simple queuing mechanism.  [godkaides]
</p>
<p>What to do when underflow/overflow occurs?  [gqqeokksw]
</p>
<p>Underflow might be meaningful: remove items until underflow occurs.  [gjafhqalh]
</p>
<p>One would hate to give up when only one overflow occurs with room remaining in other lists.  [grupqrljh]
</p>
<p>If a program uses two lists, they can grown towards eachother. One expands to the left, the other expands to the right.  [gdawwwhrk]
</p>
<p>There is no way to store three or more lists with variable size such that: A. overflow happens only when the size of all lists exceeds total space. B. Each list has fixed location for bottom element. In order to satisfy A, give up B.  [gfauerqeq]
</p>
<p>Allow bottom elements of list to change positions.  [gqhepfrfh]
</p>
<p>No absolute memory address for L0. Not a constant.  [guhjuorhk]
</p>
<p>Study and figure out and explain MIX code in figure 8, pg 246.  [gpelqkeaa]
</p>
<p>Important Special Case: Each variable sized list is a stack.  [gfllokifw]
</p>
<p>Insert: TOP[i] <- TOP[i] + 1; if TOP[i] > BASE[i + 1], then OVERFLOW, else set CONTENTS(TOP[i]) <- Y.  [gqeifqkaj]
</p>
<p>Delete: if TOP[i] = BASE[i], then UNDERFLOW, else set Y <- CONTENTS(TOP[i]), TOP[i] <- TOP[i] - 1.  [gpqfeelwq]
</p>
<p>Note that BASE[i + 1] is (i + 1)st stack.  [grrufquio]
</p>
<p>When OVERFLOW occurs, repack memory. Some ways to do this outlined, intended for linear lists allocated sequentially.  [gwrjfqfrr]
</p>
<p>1 of 3 possibilities can happen when handling OVERFLOW:  [gjauskpsl]
</p>
<p>A. find smallest k i <= N and TOP[k] < BASE[k + 1], if it exists. Then move up a notch: set CONTENTS(L + 1) <- CONTENTS(L) for TOP[k] >= L > BASE[i + 1].  [giqiilwjd]
</p>
<p>I need to better grok how these shifts work here.  [gfswskahl]
</p>
<p>B. No k can be found like in A, but a k is found: largest k for 1 <= k < i and TOP[k] < BASE[k + 1]. Move down: set CONTENTS(L - 1) <- CONTENTS(L) for BASE[k + 1] < L < TOP[i].  [grkdkeqhk]
</p>
<p>C. TOP[k] = BASE[k + 1] for all k != i. There is no room. Give up.  [gwuwluiqq]
</p>
<p>Choosing better initial conditions helps avoid overflows in certain situations. However, it can save at most a fixed number of overflows.  [grrpfuofo]
</p>
<p>Improved Method: make room for more than one entry each time memory is repacked.  [gapfuweko]
</p>
<p>J. Garwick: Suggests complete repackinmg of memory when overflow occurs.  [guhsuswds]
</p>
<p>Algorithm G: Reallocate Sequential Tables. (pg 248).  [ghhwiiiku]
</p>
<p>Algorithm G: reallocate sequential tables (pg 248). If total memory not exceeded, will be re-arranged to make operation CONTENTS(TOP[i]) <- Y possible.  [groueskur]
</p>
<p>Most interesting part of algorithm G is repacking process. It is nontrivial due to all the shifting up and down.  [ghrrkhfqr]
</p>
<p>Algorithm R: relocate sequential tables. (pg 249). Based on easily verified fact that the data to be moved downward can't overlap with any data that is to be moved upwards or that will stay put.  [goadujkwr]
</p>
<p>Mathematical analysis of dynamic storage allocation like what is being done above (algo G + R) is difficult.  [glpddswfi]
</p>
<p>Some theory that can be derived for tables that only grow by insertion. Deletion and subsequent insertion to cancel effect ignored.  [gkuapwdiu]
</p>
<p>Moral of the story: a very large number of moves to be made if reasonably large number of items put into table. This is the price of packing many sequential tables tightly.  [gsqlhafeo]
</p>
<p>When memory is only half loaded, it tiends to require minimal arrangement with algorithm G.  [ghqhjrowj]
</p>
<p>Almost full memory: Algorithm R takes a while. OVERFLOW much more likely.  [gjhqehiwf]
</p>
<p>If many variable sized tables are used in a program, don't expect to use up 100% of memory before storage is exceeded.  [geafqlpde]
</p>
</p>

<h3>2.3 Trees</h3>


<h3>2.4 Multilinked Structures</h3>


<h3>2.5 Dynamic Storage Allocation</h3>

</div>
</body>
</html>
