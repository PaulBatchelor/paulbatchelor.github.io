<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/brain/css/style.css">

</head>
<body>
<div id="main">
<title>The Art Of Computer Programming</title>
<h1>The Art Of Computer Programming</h1>
<p>Notes for The Art of Computer Programming series
by Donald E. Knuth.
</p>

<h2>Chapter 1: Basic Concepts</h2>


<h3>1.1 Algorithms</h3>


<h3>1.2 Mathematical Preliminaries</h3>


<h3>1.3 MIX</h3>

<p>See: <a href="/brain/MIX">MIX</a> and <a href="/brain/MIXAL">MIXAL</a>.
</p>

<h3>1.4 Some fundamental programming routines</h3>


<h2>Chapter 2: Information Structures</h2>


<h3>2.2 Linear Lists</h3>


<h4>2.2.2 Sequential Allocation</h4>

<p>Data usually has much more structural data than we actually want to represent directly in a computer.  [gpuolfjer]
</p>
<p>Consider not only the data structure, but the class of operations to be done on the data.  [gfawddqwk]
</p>
<p>Linear List: sequence of nodes whose essential structure properties involve only the relative positions between items as they appear in a line.  [gpddodpju]
</p>
<p>Linear List Operations: Access, Insert, Delete, Combine, Split, Copy (List), Get Number Of Nodes, Sort, Search.  [guwwkfilp]
</p>
<p>Linear List Types: Stack: insert/delete at end of list, Queue: Insertions made at one end, deletions made at the other end, Deque: insert/delete at both ends.  [gkwwskdla]
</p>
<p>A deque is more general than a stack or queue.  [gdhlrslwo]
</p>
<p>Stacks are particularly useful for the processing of languages with a nested structure.  [gadqiousq]
</p>
<p>What is a Schachtelsatze? (!TAOCP vol1, pg 241).  [gurrlfdfu]
</p>
<p>Stacks generally occur most frequently in connection with explicitly or implicitly recursive algorithms.  [gukeuflup]
</p>
<p>Kind of like how the book references chapters that haven't been published yet. Long term thinking indeed.  [gpadakoqp]
</p>
<p>Special terms for stacks: top of stack, bottom of stack.  [gqesljhpf]
</p>
<p>Knuth does not like push/pop terminology. "The brevity of words 'push' and 'pop' has its advantages, but these terms falsely imply a motion of the whole list within computer memory. Nothing is physically pushed down; items are added onto the top, as in hnaystacks or stacks of boxes".  [gfjdpalhd]
</p>
<p>Terminology for queues: front and rear.  [gidppesse]
</p>
<p>Terminology for deques: left and right.  [gdlfuuhsl]
</p>
<p>Descriptive words in English for stack/deque/queue algorithms: "up-down" for stacks, "waiting in line" for queues, and "left right" for deques.  [giihdlrko]
</p>
<p>Simplest and most natural way to keep a linear list inside a computer is to put the list items in consecutive locations, one node after the other.  [gfshpdwdq]
</p>
<p>LOC(x[j + 1]) = LOC(x[j]) + c. C is the number of words per node.  [gqkiqahdl]
</p>
<p>In general: LOC(X[j]) = L0 + Cj.  [glaahlsrd]
</p>
<p>Sequential allocation is quite convenient for dealing with a stack.  [gpaujjaid]
</p>
<p>T is stack pointer, place Y on top of stack: T <- T+1; X[T] = Y;  [gfpihkaii]
</p>
<p>Queues and Deques get a little bit tricker. Uses two pointers called F and R.  [ghorpjsaj]
</p>
<p>Rear Insert: R <- R+1; X[R] <- Y;  [gasfrlkad]
</p>
<p>Front Remove: F <- F + 1; Y <- X[F]; if F = R, then set F <- R <- 0.  [gpdkedeoh]
</p>
<p>If R stays ahead of F, this approach takes up a lot of space.  [gufwkfufj]
</p>
<p>Better approach: set M nodes aside, arranged implicitely in a circle: if R = M then R <- 1, else R <- R + 1; X[R] <- Y.  And: If F = M, then F <- 1, else F <- F + 1; Y <- X[F].  [gaoahuoai]
</p>
<p>Actions above assume nothing goes wrong, which is quite unrealistic! To fix this, add underflow and overflow.  [gjjfieeai]
</p>
<p>Work on exersize 1. Apparently discusses nontrival aspect of this simple queuing mechanism.  [godkaides]
</p>
<p>What to do when underflow/overflow occurs?  [gqqeokksw]
</p>
<p>Underflow might be meaningful: remove items until underflow occurs.  [gjafhqalh]
</p>
<p>One would hate to give up when only one overflow occurs with room remaining in other lists.  [grupqrljh]
</p>
<p>If a program uses two lists, they can grown towards eachother. One expands to the left, the other expands to the right.  [gdawwwhrk]
</p>
<p>There is no way to store three or more lists with variable size such that: A. overflow happens only when the size of all lists exceeds total space. B. Each list has fixed location for bottom element. In order to satisfy A, give up B.  [gfauerqeq]
</p>
<p>Allow bottom elements of list to change positions.  [gqhepfrfh]
</p>
<p>No absolute memory address for L0. Not a constant.  [guhjuorhk]
</p>
<p>Study and figure out and explain MIX code in figure 8, pg 246.  [gpelqkeaa]
</p>
<p>Important Special Case: Each variable sized list is a stack.  [gfllokifw]
</p>
<p>Insert: TOP[i] <- TOP[i] + 1; if TOP[i] > BASE[i + 1], then OVERFLOW, else set CONTENTS(TOP[i]) <- Y.  [gqeifqkaj]
</p>
<p>Delete: if TOP[i] = BASE[i], then UNDERFLOW, else set Y <- CONTENTS(TOP[i]), TOP[i] <- TOP[i] - 1.  [gpqfeelwq]
</p>
<p>Note that BASE[i + 1] is (i + 1)st stack.  [grrufquio]
</p>
<p>When OVERFLOW occurs, repack memory. Some ways to do this outlined, intended for linear lists allocated sequentially.  [gwrjfqfrr]
</p>
<p>1 of 3 possibilities can happen when handling OVERFLOW:  [gjauskpsl]
</p>
<p>A. find smallest k i <= N and TOP[k] < BASE[k + 1], if it exists. Then move up a notch: set CONTENTS(L + 1) <- CONTENTS(L) for TOP[k] >= L > BASE[i + 1].  [giqiilwjd]
</p>
<p>I need to better grok how these shifts work here.  [gfswskahl]
</p>
<p>B. No k can be found like in A, but a k is found: largest k for 1 <= k < i and TOP[k] < BASE[k + 1]. Move down: set CONTENTS(L - 1) <- CONTENTS(L) for BASE[k + 1] < L < TOP[i].  [grkdkeqhk]
</p>
<p>C. TOP[k] = BASE[k + 1] for all k != i. There is no room. Give up.  [gwuwluiqq]
</p>
<p>Choosing better initial conditions helps avoid overflows in certain situations. However, it can save at most a fixed number of overflows.  [grrpfuofo]
</p>
<p>Improved Method: make room for more than one entry each time memory is repacked.  [gapfuweko]
</p>
<p>J. Garwick: Suggests complete repackinmg of memory when overflow occurs.  [guhsuswds]
</p>
<p>Algorithm G: Reallocate Sequential Tables. (pg 248).  [ghhwiiiku]
</p>
<p>Algorithm G: reallocate sequential tables (pg 248). If total memory not exceeded, will be re-arranged to make operation CONTENTS(TOP[i]) <- Y possible.  [groueskur]
</p>
<p>Most interesting part of algorithm G is repacking process. It is nontrivial due to all the shifting up and down.  [ghrrkhfqr]
</p>
<p>Algorithm R: relocate sequential tables. (pg 249). Based on easily verified fact that the data to be moved downward can't overlap with any data that is to be moved upwards or that will stay put.  [goadujkwr]
</p>
<p>Mathematical analysis of dynamic storage allocation like what is being done above (algo G + R) is difficult.  [glpddswfi]
</p>
<p>Some theory that can be derived for tables that only grow by insertion. Deletion and subsequent insertion to cancel effect ignored.  [gkuapwdiu]
</p>
<p>Moral of the story: a very large number of moves to be made if reasonably large number of items put into table. This is the price of packing many sequential tables tightly.  [gsqlhafeo]
</p>
<p>When memory is only half loaded, it tiends to require minimal arrangement with algorithm G.  [ghqhjrowj]
</p>
<p>Almost full memory: Algorithm R takes a while. OVERFLOW much more likely.  [gjhqehiwf]
</p>
<p>If many variable sized tables are used in a program, don't expect to use up 100% of memory before storage is exceeded.  [geafqlpde]
</p>
</p>

<h4>2.2.3 Linked Allocation</h4>

<p>Instead of sequential list, use a more flexible scheme consisting of a node containing a link to next node in list.  [gfqhouwee]
</p>
<p>Linked memory takes up more space, due to the links.  [gjwlauhar]
</p>
<p>But there is also implicit gain: tables can overlap, sharing common parts.  [gdqdhphqk]
</p>
<p>In many cases, sequential memory is less efficient, will often leave lots of unused space.  [gaiodwapa]
</p>
<p>Easy to delete an item from linked list. Sequential allocation generally implies moving a large part of the list into different locations.  [gsulpooae]
</p>
<p>Easy to insert item into the midst of a list with linking scheme. non-trivial with sequential table.  [gpsokfrkw]
</p>
<p>References are much faster in sequential case. usefulness of linked list predicated on the fact that a large majority of applications want to walk through lists linearly, not randomly.  [gujkeqqii]
</p>
<p>Linked lists can be split/joined easily.  [ghiejwkis]
</p>
<p>Linked lists lend themselves better to more intricate structures than simple linear lists. Variable number of variable sized lists, any node can point to start of new list, nodes can be linked together in several orders corresponding to different lists, etc.  [gowpjqroe]
</p>
<p>Simple operations, such as proceding sequentially through list, are typically slightly faster with sequential lists.  [gdpqohdis]
</p>
<p>Linking technique frees one from the consecutive nature of comptuer memory.  [gkjdkpise]
</p>
<p>AVAIL list/stack: list of available space, used with some mechanism for finding empty spacve for new node.  [gwqdpqafa]
</p>
<p>Set address of x to new node: X<-AVAIL, AVAIL<-LINK(AVAIL). Shorthand notation for this is X<=AVAIL.  [glapfifup]
</p>
<p>Node deleted, no longer needed: LINK(x)<-AVAIL, AVAIL<-X. Shorthand is AVAIL<=X.  [gapjfqapd]
</p>
<p>Storage pool: the set of all nodes that can be allocated.  [gujrdjrld]
</p>
<p>"We terminate the progrma with regrets"  [gahppwilf]
</p>
<p>Things omitted from initial discussion of AVAIL: how to setup, test for overflow, managing sizxe of storage pool.  [geisoirew]
</p>
<p>Current implemetnation/discussion of pools assume nodes of equal sizxe, different siees discusess 2.6.  [gelfowepo]
</p>
<p>Simplest kind of linked list is a stack.  [ghduofpah]
</p>
<p>Insert Y to top of stack with pointer P: P <- AVAIL, INFO(P) <- Y, LINKE(P) <- T, T <- P  [gijqpjkpr]
</p>
<p>Pop Y off stack: If T<code>NUL, then UNDERFLOW, otherwise set P<-T, T<-LINK(P), Y<-INFO(P), AVAIL<</code>P. Note: "<=" operator here puts P back into pool of free nodes.  [gffeijhkw]
</p>
<p>Study MIX program 10 (pg 258)  [gsdlrrrpw]
</p>
<p>Insertion/deletion operations involve cyclic permutation of 3 links.  [gauqfsjqs]
</p>
<p>P is AVAIL value before insertion (and P not NULL): AVAIL has previous value LINK(P). LINK(P) has previous value T. T has previous value AVAIL. AVAIL->T->LINK(P)->AVAIL  [gppkddeel]
</p>
<p>Deletion P is T before, P not NULL, Y<-INFO(P): AVAIL->LINK(P)->T->AVAIL.  [gqdrudhqj]
</p>
<p>Cyclic aspect not really relevant, important point is that precisely 3 links are permuted in these operations.  [gwihfphwl]
</p>
<p>Linked allocation applies in a particularly convenient way to queues.  [gpajaeqou]
</p>
<p>Make sure to handle empty lists properly. This is a common programmer error. "specify all conditions carefully".  [giuhdwhep]
</p>
<p>Another error: forgetting to change some of the links when structure s being maniupoulated.  [gpuiuuaou]
</p>
<p>Policty for empty queue: F eq NULL, R eq LOC(F).  [gjqhdpwki]
</p>
<p>Queue deletion: If F eq NULL, UNDERFLOW else set P<-F, Y<-INFO(P), AVAIL<=P and if F eq NULL, then set R<-LOC(F)  [gqdiaijuu]
</p>
<p>R is changed when queue becomes empty, this is the boundary condition.  [grpkhsiid]
</p>
<p>Not the only way to represent queues in a linearly linked fashion. Other ways are discussed later (see ex. 30)  [gqokolwei]
</p>
<p>So far, discussions on performing operations on tables have been abstract, no programs in which techinques are used, no onto practical examples!  [goweijarh]
</p>
<p>Topological sorting: important process in network problems, PERT charts, even linguistics.  [ghrwfsjpj]
</p>
<p>Topological sort is potentially useful with problems involving <code>partial ordering</code>.  [goedljiro]
</p>
<p>Partial ordering of set S is relation between objects of S, denoted by symbol (Paul: curvy less than equal to? looks like <=)  [gsssjhifq]
</p>
<p>Satisfies following properties for S (will use <= to represent notation used in book): Transitivity: x<<code>y and y<</code>z, x<<code>z. Antisymmetry: x<</code>y and y<<code>x, x</code>y. Reflexivity: x<=x.  [giqwshpsr]
</p>
<p>x<=y reads as "x preceds or equals y".  [gfjiqpeld]
</p>
<p>y!<=z reads as "y does not precede z".  [glophdeqa]
</p>
<p>PERT networks "x must be done before y".  [gksqduolw]
</p>
<p>Antisymmetry propety means there are no closed loops or paths that close on themselves. Problem of topological sort: emed the partial order in a linear orer.  [ghdrdsiqe]
</p>
<p>linear sequence a1, a2, ... an, aj<=ak, j<k.  [gussprewh]
</p>
<p>Algorithm proves tha this operation is possible for every partial ordering.  [gljeoapdo]
</p>
<p>Topological sort example: glossary of technical terms. Find a way to arrange the words in the glossary so that no term is used before it is defined.  [grqsrjpaf]
</p>
<p>Topological sort process: take object that isn't proceded by any other object in the ordering. Place first in output and remove from set S. repeat until whole set has been sorted.  [giqflkrij]
</p>
<p>algo T: topological sort (pg 265): inputs a sequence of relations j<=k, indicating that object j precedes k in a certin partial orering. output is set of objects embedded in a linear order.  [glijuswfo]
</p>
<p>Try algo T by hand on input 18 (264-265)  [geaqldlok]
</p>
<p>Combo of linked list and sequential allocation.  [gqeopjkri]
</p>
<p>Sequential memory used for main table, because it makes references to random parts of tables in T3.  [goioquosk]
</p>
<p>linked memory: tables of "immediate successors" no particular order in input.  [godlerdwl]
</p>
<p>Analysis of algo T: simple using Kirchoff's law.  [gurjjlrja]
</p>
<p>Exeuction time has approximate form $c2 n$. $m$ is number of relations, $n$ is number of objects. and $c2$ are constants.  [geikppuaf]
</p>
<p>Topological sorting technique similar to T (but without the important features of queue links): published by A.B Kahn.  [gakupokkq]
</p>
<p>Even better topological sort algorithm in 7.4.1 (not printed yet?)  [gkruuhfhh]
</p>
</p>

<h4>2.2.4 Circular Lists</h4>

<p>Circularly linked list: links back to first item instead of NULL.  [gsddqdjwf]
</p>
<p>Makes it possible to access all of the list starting form any point.  [gjfifiaqo]
</p>
<p>Important primitive operations: A. insert Y at left, B. insert Y at right, C. set y to left node and delete.  [ghhjowlsl]
</p>
<p>A. Insert Y at left: P<=AVAIL, INFO(P)<-Y, LINK(P)<-PTR, LINK<-(PTR)<-P. PTR: link variable that points to rightmost node in list. LINK(PTR): points to leftmost node in list.  [gsdoisewq]
</p>
<p>B. Insert Y at right: insert Y at left, then PTR<-P.  [gfjlpuepa]
</p>
<p>C. Set Y to left node and elete: P<-LINK(PTR), Y<-INFO(P), LINK(PTR)<-LINK(P), AVAIL<=P.  [gojujlewf]
</p>
<p>Operations above do not consider empty list can be handled if empty list handled by making PTR NULL.  [gwdkeejde]
</p>
<p>Operations give actions of output-restricted deque. Therefore circular list can be used as stack of queue.  [gliqqhkri]
</p>
<p>Operations A+C stack. Operations B + C: queue.  [guwppqeef]
</p>
<p>Erase a list (put all items on AVAIL): IF PTR ne NULL, then AVAIL <-> LINK(PTR). "<->" denotes P<-AVAIL, AVAIL <- LINK(PTR), LINK(PTR)<-P.  [gwrdqjoos]
</p>
<p>Insert entire list L2 at the right of L1: if PTR2 ne NULL, then: (if PTR1 ne NULL, then LINK(PTR1)<->LINK(PTR2)) SET PTR1<-PTR2, PTR2<-NULL.  [gffhewhid]
</p>
<p>Assumes PTR1 and PTR2 point to disjoint circular lists L1 and L2.  [gpffqaphw]
</p>
<p>Splitting circular list in 2: with above, can correspond to concatentation/deconcation of strings.  [gesdkowpd]
</p>
<p>Circular list with one pointer to rear node is equivalent to linear list with two pointers to front/rear.  [girraiwlu]
</p>
<p>How to find end of list when there is circular symmetry? Iterate throgh list, stop when start found again. Or, add special recognizable node as stopping place: list head.  [guuoqwjpd]
</p>
<p>List head makes it possible (though not efficient) to get to any point in the list from any other point.  [gqpqreawa]
</p>
<p>Example use of circular lists: arithmetic on polynomials in variables x,y,z with integer coefficeints.  [gqalakajw]
</p>
<p>Linked alocation works well: polynomials can grow to unpredictable size. May want to represent many polynomials in memory at once.  [grkflhppw]
</p>
<p>Algorithm A: addition of polynomials (pg 276).  [gdowdafld]
</p>
<p>Noteworthy feature of algorithm A: manner in which variable Q1 folows Q around the list.  [gosjqqprr]
</p>
<p>Algorithm M: multiplication of polynomials (pg 277).  [gwjssukqf]
</p>
<p>Algorithm M analogous to Algorithm A.  [giklwfafk]
</p>
</p>

<h3>2.2.5 Doubly Linked Lists</h3>


<h3>2.3 Trees</h3>


<h3>2.4 Multilinked Structures</h3>


<h3>2.5 Dynamic Storage Allocation</h3>

</div>
</body>
</html>
