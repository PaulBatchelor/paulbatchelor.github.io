<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<link rel="stylesheet" href="/brain/css/style.css">

</head>
<body>
<div id="main">
<title>SICP logs</title>
<h1>SICP logs</h1>
<p><b>[b4dd6d67] 2021-12-11-06-39</b>: really hoping that busting through a book the first time 'round without fully understanding everything is an okay approach. I want to think of it as map-building for the second time 'round.
</p>
<p><b>[66d2627c] 2021-12-11-06-38</b>: stumbling my way through section 2.2. Onto 2.3 (symbols).
</p>
<p><b>[164a2255] 2021-12-11-06-31</b>: message passing: a style of programming found in languages such as LISP/Scheme which involve the ability to manipulate procedures as objects (which automatically provies the ability to represent compound data).
</p>
<p><b>[83af25bf] 2021-12-11-06-27</b>: abstraction barriers: being able to isolate different levels of a system using abstraction.
</p>
<p><b>[b9ba3e65] 2021-12-06-16-25</b>: "a signal processing engineer would find it natural to conceptualize these processes in terms of signals flowing through a cascade of stages, each of which implmements part of the program plan"
</p>
<p><b>[57174bf8] 2021-12-06-16-21</b>: it also says to look at count-leaves, so, onto that as well...
</p>
<p><b>[6a1d2aeb] 2021-12-06-16-20</b>: mapping over trees isn't as bad as I thought it would be conceptually. scale-tree makes perfect sense in terms of expected inputs and outputs. looking at the procedure itself more closely, and comparing it to scale-list from the previous section.
</p>
<p><b>[707f3801] 2021-12-06-15-49</b>: Going to have a look at 2.2 more closely, as there are concepts and things there that are being referenced later.
</p>
<p><b>[21b998b6] 2021-12-06-15-47</b>: skimming around, and I am very much looking forward to what "picture language" is. applying this expressiveness to creative pursuits is really what this is all about.
</p>
<p><b>[6bd70dd7] 2021-12-06-15-44</b>: the structures presented in chapter 2 are mostly familiar to me so far. Though, "mapping over trees" is something I'm going to want to look at a bit closer if I'm going to grok that scheme code. All this code I'd like to come back to and study more closely here. I like the LISP.
</p>
<p><b>[287d1e13] 2021-12-03-15-22</b>: starting to realizing a distinction between text editing and notation. With Scheme, a notation system is created that happens to sort of translate okay to text that text editors can write. but, not really.
</p>
<p><b>[e1f92e95] 2021-12-03-15-15</b>: probing the intro of chapter 2
</p>
<p><b>[6e9d2920] 2021-12-03-15-15</b>: okay, 1.3 starts to get a little bit mathy towards the end. I'm skimming mostly right now, but to actually grok this I'm going to have to sit down and study the examples a bit more closely.
</p>
<p><b>[d745713f] 2021-12-03-15-10</b>: half-interval method described in 1.3.3 superficially reminds me of divide-and-conquer algorithms stuff. might be, might not be. I'm not looking too closely at this point.
</p>
<p><b>[c63fb9f2] 2021-12-03-10-43</b>: 1.3: computing cubes vs the ability to express the concept of cubing. I like that kind of distinction.
</p>
<p><b>[8bfaceec] 2021-12-03-10-25</b>: it seems that orders of growth can measure things in <code>steps</code> (time) and <code>space</code>. recursive factorial required O(N) in steps and space. iterative factorial was O(N) in steps, O(1) in space. I never considered space before.
</p>
<p><b>[5c4fd45e] 2021-12-03-10-20</b>: order of growth: a notion used to describe the rate at which a process consumes computational resources. This is obtained via the gross measure of resources required by a process as the inputs become larger.
</p>
<p><b>[50275e78] 2021-12-03-10-18</b>: the "counting change" problem smells like a dynamic programming problem. something I am very inexperienced at. worth looking at more closely.
</p>
<p><b>[60a162f4] 2021-12-03-10-17</b>: tree recursion: a common pattern of computation. A recursive process whose evolution looks like a tree. in (<a href="/brain/SICP">SICP</a>), the fibonacci algorithm is used as an example of a process with tree recursion.
</p>
<p><b>[5e49582e] 2021-12-03-10-14</b>: note to self: excercise 1.9 is worth working out by hand at some point.
</p>
<p><b>[78e125e0] 2021-12-03-10-12</b>: there's a difference between a recursive <code>procedure</code> and a recursive <code>process</code>. A recursive procedure is only syntactical self-referential. recursive process talks more about pattern of evolution.
</p>
<p><b>[2d39add0] 2021-12-03-10-09</b>: iterative processes does not grow and shrink the way recursive processes do.
</p>
<p><b>[df8a770b] 2021-12-03-10-09</b>: linear iterative process: an interative process whose growth is linear.
</p>
<p><b>[3213c89c] 2021-12-03-10-07</b>: iterative process: a process whose state can be summarized by a fixed number of state variables, together with a fixed rule that describes how the state variables should be updated as the process moves from state to state and an optional end test that specifies conditions under which the process should terminate.
</p>
<p><b>[8d060b80] 2021-12-03-10-05</b>: linear recursive process: a recursive process that keeps track of a chain of deferred operations. This chain has linear growth.
</p>
<p><b>[df9039dd] 2021-12-03-10-04</b>: recursive process: a process defined by a chain of deferred operations.
</p>
<p><b>[0dec860e] 2021-12-03-10-04</b>: deferred operations: in recursion, operations that are created while a process expands an expression, and are performed during the contraction.
</p>
<p><b>[bf1c5770] 2021-12-03-09-56</b>:  1.1.7: square roots by newtons method... worth looking at more closely.
</p>
<p><b>[6b13fa56] 2021-12-03-09-53</b>: imperative descriptions: how-to descriptions. computer scientists are usually concerned with this (vs "what is").
</p>
<p><b>[43977097] 2021-12-03-09-52</b>: imperative description: "what" description. mathematics are concerned with this (vs "how to").
</p>
<p><b>[0a1e66b2] 2021-12-03-09-48</b>: predicate: procedures that return true or false.
</p>
<p><b>[3c37b7af] 2021-12-03-09-47</b>: consequent expression: the value of the corresponding expression associated with a predicate that is true. used in conditional expressions.
</p>
<p><b>[8347a6a9] 2021-12-03-09-14</b>: clause: in lisp, a parenthesized pair of expressions that follow the cond symbol.
</p>
<p><b>[4e8e776f] 2021-12-03-09-12</b>: case analysis: a special form in lisp that can make tests and perform different operations depending on the result of the test.
</p>
<p><b>[4128c915] 2021-12-03-09-09</b>: applicative-order evaluation: an evaluation method that evaluates the arguments and then applies. this is the method that the scheme interpreter uses.
</p>
<p><b>[5170f643] 2021-12-03-09-08</b>: normal order evaluation: an evaluation method that fully expands and then reduces.
</p>
<p><b>[cc905d10] 2021-12-03-09-05</b>: procedure definitions: a compound operation that can be given a name and then referred as a unit.
</p>
<p><b>[60c6c350] 2021-12-03-09-00</b>: special forms: exceptions to the general evaluation rule. <code>define</code> in scheme is an example of a special form.
</p>
<p><b>[4eeaa860] 2021-12-03-08-58</b>: recursive: evaluation rule that includes, as one of its steps, the need to invoke the rule itself.
</p>
<p><b>[ef93d5f9] 2021-12-03-08-56</b>: environment: some sort of memory in the interpreter that keeps track of name-object pairs. more precisely called the global environment.
</p>
<p><b>[f7831585] 2021-12-03-08-55</b>: read-eval-print loop: the operation cycle of interpreter. read an expression from the terminal, evalulate the expression, and print the result.
</p>
<p><b>[482364c0] 2021-12-03-08-53</b>: pretty-printing: a formatting convention in which each long combination is written so that the operands are aligned vertically.
</p>
<p><b>[d4e8ec69] 2021-12-03-08-53</b>: nested: to have combinations whose elements are themselves combinations.
</p>
<p><b>[4f640f70] 2021-12-03-08-52</b>: prefix notation: convention of placing operator to the left of the operands.
</p>
<p><b>[eb7bdf99] 2021-12-03-08-52</b>: operand: the other elements following the operator.
</p>
<p><b>[5fefc499] 2021-12-03-08-51</b>: operator: the leftmost element in the list.
</p>
<p><b>[6eac2bec] 2021-12-03-08-51</b>: combinations: expressions in lisp formed by delimiting a list of expression within parentheses in order to denote procedure application.
</p>
<p><b>[b65c0ef8] 2021-12-03-08-50</b>: you type an expression, and the interpreter responds by displaying the result of its evaluating that expression.
</p>
<p><b>[cd67834a] 2021-12-03-08-49</b>: means of abstraction: compound elements can be named and manipulated as units
</p>
<p><b>[532c2c17] 2021-12-03-08-48</b>: means of combination: compound elements are built from simpler ones.
</p>
<p><b>[cd16f788] 2021-12-03-08-48</b>: primitive expression: the simplest entities the language is concerned with.
</p>
<p><b>[70be8912] 2021-12-03-08-46</b>: beginning the first chapter today. skimming it, as it covers a lot of fundamental stuff I am pretty familiar with already. I think I will take notes on some of the keywords though./
</p>
<p><b>[a9db07bc] 2021-12-02-15-57</b>: SICP is going to be the first book to tackle in the (<a href="/brain/TYCS">TYCS</a>) series.
</p>
</div>
</body>
</html>
