<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/brain/css/style.css">

</head>
<body>
<div id="main">
<title>Rust Book</title>
<h1>Rust Book</h1>

<h2>Overview</h2>

<p>Various notes and thoughts regarding the Rust Book.
</p>

<h2>Chapter 1: How to install rust</h2>

<p>I was pleasantly surprised that I could get things working
on Alpine without too much issue.
</p>

<h2>Chapter 2: hands-on intro to rust</h2>

<p>I intially skipped this, then went back just to get used
to building projects with cargo.
</p>

<h2>Chapter 3: Rust features similar to other languages</h2>

<p>Yeah, this mostly felt familiar.
</p>

<h2>Chapter 4: Ownership</h2>

<p>I thought this was introduced pretty well. I have a feeling
that this will get tricky quickly in practice though. Already
it is having me re-think how I'd port some of the
functionality of graforge to Rust.
</p>

<h2>Chapter 5: Structs and Methods</h2>

<p>Reasonably familiar C-ish concepts.
</p>

<h2>Chapter 6: Enums, Match, etc</h2>

<p>This kind of looks like a case switch if you squint. I've had
experience with pattern matching from FAUST, which I believe
is where it is heading. Will be interested to see what that
looks like.
</p>
<p>Overall, I feel like this is more powerful than it looks.
</p>

<h2>Chapter 7: Modules</h2>

<p>Packages, Crates, and Modules. Relative and absolute paths.
The <code>use</code> statement. Private vs Public code.
</p>

<h2>Chapter 8: Common Collection Data Structures</h2>

<p>A jumble of common data structs.
</p>
<p>Vectors: creating, updating, out-of-scope/dropping, reading,
iterating, using an enum to store multiple types in a
vector.
</p>
<p>Strings: these are challenging for newcomers to grok! Many
different types of strings.
</p>
<p>Hashmaps: kind of what you'd expect. Rust uses a hash
algorithm by default that is a trades performance
for security (SipHash).
</p>

<h2>Chapter 9: Error Handling</h2>

<p>Recoverable and unrecoverable.
</p>
<p>Panic backtraces. Recoverable errors using the <code>Result</code> type.
Using the <code>match</code> operator to match errors. <code>unwrap</code> and
<code>expect</code>. Error propagation, with an example
starting verbosely with match and adding syntactic sugar
to make things clearer. Introduction to the <code>?</code> operator.
Best practices for when to panic or not to panic. Creating
custom types for validation.
</p>

<h2>Chapter 10: Generics, Traits, and Lifetimes</h2>

<p>This is a very meaty chapter! generic type
parameters (apply code to different types),
traits and trait bounds (even though types are
generic, ensure that they'll have the correct
behavior the code needs), and generic lifetime
parameters (ensures that code won't have dangling
references).
</p>
<p>Generics: the one feature everybody loves to talk about
Go <b>not</b> having.
</p>
<p>Generics in: Structs, Enums, Method definitions. The
way generics are mixed up in 10-11 is kind of confusing to
me.
</p>
<p>Generics do not add any additional overhead (but I bet
the compile time gets a penalty). Some explanation for
how this works.
</p>
<p>Traits: kind of like interfaces in other languages (makes me
think of Go? Been a while since I wrote any Go.)
</p>
<p>Using tweets vs news article summaries as an example.
Default implementations. Traits as parameters.
</p>
<p>Trait bounds, and trait bounds syntax. Using trait bounds
to conditionally implement methods.
</p>
<p>Lifetimes: the scope for which a reference is valid.
</p>
<p>Dangling references, Borrow Checker, Generic lifetimes in
functions, Lifetime annotation syntax, annotations in function
signatures, thinking in terms of lifetimes, lifetime elision,
annotations in method defintions, static lifetimes.
</p>

<h2>Chapter 11: Testing</h2>

<p>AKA writing Automated Tests. How to write tests. The anatomy
of a test function. The assert macros, assert_eq! and
assert_neq!. Custom failure messages. Panic checks. Using
Result. Parallel vs consecutive tests. Showing function
output. Running tests by name (partial matches run can
run multiple tests). Tests that are usually ignored.
</p>
<p>Test Organization. Unit tests. Integration tests.
</p>

<h2>Chapter 12: Implementing A Toy Grep</h2>

<p>Minigrep, etc.
</p>

<h2>Chapter 13: Closures and Iterators</h2>

<p>Closures: a function-like construct you can store in a
variable.
</p>
<p>Iterator: a way of processing a series of elements.
</p>
<p>First introduces closure through refactoring a fictional
code for a workout app. Functions, to closures, to closures
with cached parameters. Narrow scoped closure means
compiler can infer a lot of things (no type annotations
required usually). Closure notation. Lazy evaluation,
function types. Different ways of capturing environment
with closures: FnOnce, FnMut, Fn.
</p>
<p>Iterators are lazy, and won't do anything if it
doesn't have to. Iterators is a trait in Rust, that
has at least one method called "next". "Consume the
iterator": or using up the iterator. Other iterator
methods like "map". Closures that capture environment.
Custom Iterator traits.
</p>
<p>Minigrep from previous chapter is refactored to use
closures/iterators.
</p>
<p>Performance test: loops vs iterators. Iterators win
the benchmark! Iterators are zero-cost abstractions.
</p>
<p>Audio Decoder! Looks like some kind of LPC. Efficient
high level abstractions for otherwise low-level code.
</p>

<h2>Chapter 14: Cargo In-Depth</h2>

<p>Release profiles. Crates.io, and how to publish there.
special comments for documentation, testing inline
examples in comments. pub use for exporting convenient
API. Settingup crates.io account and getting ready to
publish... once it's up there, it's up there. Using yank
to remove (disable?) versions in crates.io. Cargo
workspaces. Installing binaries with "cargo install".
</p>

<h2>Chapter 15: Smart Pointers</h2>

<p>TBD.
</p>

<h2>Chapter 16: Different Models of Concurrency</h2>

<p>TBD.
</p>

<h2>Chapter 17: Object Oriented Programming</h2>

<p>TBD.
</p>

<h2>Chapter 18: Patterns and Pattern Matching</h2>

<p>TBD.
</p>

<h2>Chapter 19: Advanced Topics</h2>

<p>TBD.
</p>

<h2>Chapter 20: A multi-threaded webserver</h2>

<p>TBD.
</p>

<h2>Messages</h2>

<p>Any messages tagged with the group <code>rustbook</code>.
</p>
<p><b>[9e6f08cc] 2022-03-19-10-40</b>: memory safety in rust does not guarantee prevention of memory leaks. reference cycles can leak memory.
</p>
<p><b>[238f19aa] 2022-03-19-10-39</b>: memory leak: a situation where memory is allocated but not cleaned up.
</p>
<p><b>[7403a55a] 2022-03-19-06-34</b>: mock objects: specific types of test doubles that record what happens during a test so you can assert that the correct actions took place.
</p>
<p><b>[ca92867a] 2022-03-19-06-34</b>: test double: a type used in place of another type during testing.
</p>
<p><b>[4bad641c] 2022-03-19-06-21</b>: By default, Rust checks the borrowing rules at compile time, which allows bugs and errors to be caught sooner. Checking borrowing rules at runtime (such as RefCell) will enable certain kinds of memory-safe scenarios. If something goes wrong in the program, it will panic.
</p>
<p><b>[d4d5d479] 2022-03-19-06-16</b>: interior mutability: a design pattern in Rust that allows you to mutate data even when there are immutable references to that data.
</p>
<p><b>[b0fe79fc] 2022-03-19-06-13</b>: Rc::clone() doesn't make a deep copy like regular clone(). It only increases the reference count.
</p>
<p><b>[6881b6f5] 2022-03-19-06-09</b>: realizing that graforge uses reference counting.
</p>
<p><b>[469bd78d] 2022-03-19-06-04</b>: constructor: a function that creates an instance.
</p>
<p><b>[adc76cb5] 2022-03-19-06-03</b>: destructor: a function that cleans up an instance.
</p>
<p><b>[e2405e70] 2022-03-19-05-58</b>: the <code>Drop</code> trait customizes what happens when a value is about to go out of scope.
</p>
<p><b>[6a5c9992] 2022-03-19-05-56</b>: you can coerce a mutable reference to be an immutable one, but not the other way around.
</p>
<p><b>[c00cbfbc] 2022-03-19-05-51</b>: (maybe I should just finish this section. ha)
</p>
<p><b>[dc4660b9] 2022-03-19-05-51</b>: I seem to understand that deref coercion is a conversion process applied to arguments. "syntactic" sugar, for what otherwise seems to be very messy looking code.
</p>
<p><b>[e3cdb777] 2022-03-19-05-46</b>: trying to grok <code>deref coercion</code>.
</p>
<p><b>[9a5170a3] 2022-03-19-05-42</b>: without the <code>Deref</code> trait, the compiler can only dereference <code>&</code> references.
</p>
<p><b>[8a4fca26] 2022-03-19-05-39</b>: dereference operator: in Rust, this is an operator represented with <code>*</code>. Implemented the <code>Deref</code> trait allows you to customize the trait of the derefernce operator.
</p>
<p><b>[83d56902] 2022-03-15-06-29</b>: Boxes seem to be the most 'basic' smart pointer type, compared to the other smart pointer types.
</p>
<p><b>[3d8317af] 2022-03-15-06-23</b>: note to self: chapter says if generics were used, any type could be used. Does that mean they all have to be the same type? Or can there be multiple types? Thinking ahead about my needs for my Rust DSP stuff.
</p>
<p><b>[88bb61d9] 2022-03-15-06-20</b>: recursive types are reminding me of the chicken/egg problems that happen when building linked list structures in C. Looking at the cons structure being defined right now.
</p>
<p><b>[4985c98b] 2022-03-15-06-16</b>: recursive type: a type whose value can have as part of itself another value of the same type.
</p>
<p><b>[2c68e052] 2022-03-15-06-12</b>: also stay tuned: interior mutability pattern and reference cycles. coming to a (<a href="/brain/glossary">glossary</a>) near you!
</p>
<p><b>[a9e2e072] 2022-03-15-06-11</b>: many kinds of smart pointers in Rust. The ones focused on in the rust book are the most common: Box (Heap), Rc (reference counting for multiple ownership), Ref and RefMut, accesed through RefCell, that accesess rules at runtime rather than compile time
</p>
<p><b>[a3305a4f] 2022-03-15-06-08</b>: reference counting (pointer type): a smart pointer type that enables you to have multiple owners of data by keeping track of the number of owners and, when no owners remain, cleaning up the data.
</p>
<p><b>[06d653bb] 2022-03-15-06-06</b>: smart pointer: data structures that not only act like a pointer but also have additional metadata and capabilities.
</p>
<p><b>[a8c4f5e4] 2022-03-15-06-05</b>: pointer: a general concept for a variable that contains an address in memory.
</p>
<p><b>[217d5774] 2022-03-15-06-04</b>: okay, onto smart pointers now.
</p>
<p><b>[3d83ae31] 2022-03-15-05-59</b>: finished crates chapter. backtracking.
</p>
<p><b>[fb02b5ea] 2022-03-15-05-58</b>: binary target: runnable program that is created if the crate has a src/main.rs file or another file speciefied as a binary, as opposed to a library target that isn't runnable on its own but is suitable for for including within other programs.
</p>
<p><b>[0218368c] 2022-03-14-13-04</b>: "the yank feature is not intended for deleting accidentally uploaded secrets. If that happens, you must reset those secrets immediately". I mean, I think I understand the motivations for this, but yikes.
</p>
<p><b>[79c0e9c3] 2022-03-14-13-02</b>: I wonder if the underlying software for crates.io is open source?
</p>
<p><b>[94696815] 2022-03-14-13-01</b>: centralization of packages (crates.io) makes me go "eh?" a little bit. I wonder if there are ways to make local package repos, or some other kind of decentralized structure.
</p>
<p><b>[9fb9f90d] 2022-03-14-12-58</b>: things like 'pub use' feel like one of those things that can get complicated quickly.
</p>
<p><b>[43029bac] 2022-03-14-11-37</b>: the way the docs are so integrated into the rest of the tooling (like tests) is very cool. I like how standardized it is.
</p>
<p><b>[b27a65db] 2022-03-14-07-09</b>: Read 58% percent of the Rustbook. why does this book feel like it's taking forever to read? Well, more than halfway, so progress.
</p>
<p><b>[45037dfa] 2022-03-14-07-04</b>: documentation comment: in Rust, a particular comment format used for inline code documentation.
</p>
<p><b>[c7a1f6cd] 2022-03-14-07-02</b>: interesting that optimization levels are 0-3, like GCC/Clang. Not sure if that is deliberate or related.
</p>
<p><b>[4fffa851] 2022-03-14-07-00</b>: two main release profiles in cargo: debug and release. seems pretty similar distinctions/tradeoffs to release/debug.
</p>
<p><b>[ab7519f2] 2022-03-14-06-59</b>: release profile: predefined and customizable profile with different configurations that allow a programmer to have more control over various options for compiling code.
</p>
<p><b>[be4d97dc] 2022-03-14-06-58</b>: onto cargo + crates chapter
</p>
<p><b>[5008a900] 2022-03-14-06-53</b>: consuming adaptors: in the context of iterators, methods that use up the iterator when called. Methods that call "next" on an iterator are consuming adaptors.
</p>
<p><b>[c32db956] 2022-03-14-06-40</b>: done with iterators/closures chapter. rewinding and writing up a blurb/summary in my (<a href="#">rust_book</a>) page.
</p>
<p><b>[57f31eda] 2022-03-14-06-39</b>: unrolling: an optimization that removes the overhead of the loop controlling code and instead generates repetitive code for each iteration of the loop.
</p>
<p><b>[44398914] 2022-03-14-06-38</b>: as the book describes, it is indeed nice to see the ways low-level DSP code can take advantage of high-level abstractions (with zero cost). I'm always skeptical about that sort of stuff (are you <b>sure</b> this is the right abstraction or way to think about it?, etc) but hey open mind.
</p>
<p><b>[1269cf3f] 2022-03-14-06-36</b>: hey look! audio domain stuff. (audio decoder on pdf page 363)
</p>
<p><b>[50ec3e49] 2022-03-14-06-27</b>: zero-overhead: the term Bjarne Stroustrup uses in his book "Foundations of C++" (2012) to describe in C++ what Rustaceans would call "Zero-Cost".
</p>
<p><b>[6383c5c3] 2022-03-14-06-25</b>: zero-cost abstraction: In the Rust Programming Language, an abstraction that imposes no additional runtime overhead.
</p>
<p><b>[9b8cad7a] 2022-03-14-06-15</b>: the "static" lifetime seems to refer to types like string constants. Is this a special lifetime name?
</p>
<p><b>[4354bf80] 2022-03-14-05-59</b>: consume the iterator.
</p>
<p><b>[31f83086] 2022-03-13-15-28</b>: iterator adapter: other methods in the Iterator struct that allow you to change iterators into different kinds of iterators.
</p>
<p><b>[2e86b780] 2022-03-13-15-21</b>: iterators in Rust are lazy, meaning they have no effect until you call methods that consume the iterator to use it up.
</p>
<p><b>[8cd7c4df] 2022-03-13-15-19</b>: closures that can capture their environment are useful in the context of iterators.
</p>
<p><b>[4d14ad01] 2022-03-13-15-17</b>: closures can explicitely take ownership of a value using the keyword <code>move</code>. Apparently this gets discussed in later chapters revolving around concurrency.
</p>
<p><b>[976f4dc3] 2022-03-13-15-13</b>: Fn borrows values from the environment immutably.
</p>
<p><b>[82d6819f] 2022-03-13-15-13</b>: FnMut can change the environment because it mutably borrows values.
</p>
<p><b>[0c380d10] 2022-03-13-15-12</b>: FnOnce consumes the variables from its enclosing scope, taking ownership, and moving them into the closure when it is defined. It can't take ownership of the variables more than once, so it is only called once.
</p>
<p><b>[4a99dd84] 2022-03-13-15-10</b>: closures can capture their environment. functions do not.
</p>
<p><b>[0a520eb4] 2022-03-13-15-02</b>: All closures implmement at least one of the traits: <code>Fn</code>, <code>FnMut</code>, or <code>FnOnce</code>.
</p>
<p><b>[00cc4560] 2022-03-13-15-00</b>: lazy evaluation: also known as memoization, the ability for a closure to compute a value only when needed to, and to other wise use a cached value.
</p>
<p><b>[9385ed0e] 2022-03-13-14-56</b>: with closures, you don't need type annotations because with their narrow scope, the compiler can usually figure it out.
</p>
<p><b>[97ef22f5] 2022-03-13-14-52</b>: the syntax for closures in rust was inspired by the closure definitions in Smalltalk and Ruby
</p>
<p><b>[2b916421] 2022-03-13-14-45</b>: iterators and closures are functional concepts specifically discussed because they are important to writing idiomatic code that is <b>fast</b>. (other functional things like pattern matching also exist in Rust, but are not covered in this chapter).
</p>
<p><b>[5c308281] 2022-03-13-14-43</b>: Iterators: a way of processing a series of elements
</p>
<p><b>[aae46a95] 2022-03-13-14-43</b>: Closure: A function-like constant you can store in a variable.
</p>
<p><b>[d63a15ee] 2022-03-11-17-39</b>: "iterators" and "closures" aren't entirely foreign sounding concepts to me. so that's nice.
</p>
<p><b>[db7114f6] 2022-03-11-17-38</b>: done with this minigrep chapter. now onto iterators and closures.
</p>
<p><b>[26334780] 2022-03-10-15-33</b>: the 'if let' syntax used to handle errors in the minigrep chapter is a little foreign looking to me, but it sort of makes sense in a fuzzy way.
</p>
<p><b>[b26d31ef] 2022-03-09-12-36</b>: constructors are idiomatic Rust. In other words, instead of making a function called "foo_new", have a function associated with the struct called Foo::new.
</p>
<p><b>[8446e980] 2022-03-09-12-32</b>: "we now define Config to contain owned String values". The use of the word "owned" sounds like such a rustism to me.
</p>
<p><b>[f4ae0721] 2022-03-08-17-01</b>: primitive obsession: using primitive values when a complex type would be more appopriate.
</p>
<p><b>[e0beb107] 2022-03-08-14-18</b>: maybe not though... still grokking
</p>
<p><b>[50218d56] 2022-03-08-14-17</b>: noticing the use of '&' to denote a reference I think? seems a lot more explicit than in C.
</p>
<p><b>[c44cd4a7] 2022-03-08-14-14</b>: it says to split things into main.rs and lib.rs. But what happens when lib.rs gets too big? is there a best practice for that?
</p>
<p><b>[8dd2c8be] 2022-03-08-14-13</b>: "Separations of Concerns for Binary Projects" glad there's insight for stuff like this. It feels relevant to the Boing DSP project I've been thinking about.
</p>
<p><b>[edb29cb2] 2022-03-08-14-12</b>: now reading chapter 12: Implementing a Toy Grep. My setup makes it convenient to read and type at the same time now. Since they both are well-lit e-ink displays, my eyes should be comfortable.
</p>
<p><b>[f73855c4] 2022-03-08-13-48</b>: gooseneck arrived! remarkable now can be read while I type on my e-ink display. it's all coming together now...
</p>
<p><b>[789b68e0] 2022-03-08-13-22</b>: I'm realizing my remarkable is too far away from my computer, and I need to turn my head a lot. I have purchased a goose neck stand that can attach to my tiny table so that I can both type and read at the same time. This is needed in particular for the GREP chapter.
</p>
<p><b>[ad8ace1b] 2022-02-24-09-34</b>: wrote blurb on chapter 11 (testing). chapter 12 looks like more of a hands-on chapter.
</p>
<p><b>[42cd3730] 2022-02-24-09-33</b>: integration tests: check that many parts of the library work together correctly. Use the library's public API similar to how external code will use it.
</p>
<p><b>[6ab3efa5] 2022-02-24-09-32</b>: unit test: excersize different parts of a library separately. Can test private implementation details.
</p>
<p><b>[1d2009a7] 2022-02-24-09-26</b>: correctness: the extent to which code does what it is intended to do.
</p>
<p><b>[6a6cee19] 2022-02-05-14-48</b>: the <code>longest_with_announcement</code> function at the end of chapter 10 looks quite dense, and worth studying for later IMO.
</p>
<p><b>[ddebee31] 2022-02-05-14-47</b>: "in the future, even fewer lifetime annotations might be required". so, I'm assuming these become tedious to manage.
</p>
<p><b>[037aefd1] 2022-02-05-14-46</b>: "violation of memory safety"
</p>
<p><b>[46c4e62b] 2022-02-05-14-45</b>: does rust make implicit calls to malloc (or equivalent)? thinking about realtime performance. does one have to be mindful of this?
</p>
<p><b>[17f298af] 2022-02-05-14-44</b>: lifetimes are indicated by an apostrophe ('), and apparently are expected to be all lowercase and very short. Is this idiomatic then?
</p>
<p><b>[2caf952c] 2022-02-05-14-42</b>: the main aim of lifetimes is to prevent dangling references.
</p>
<p><b>[af69c8da] 2022-02-05-14-42</b>: lifetime: the scope for which a reference is valid.
</p>
<p><b>[5c367ac9] 2022-02-05-14-40</b>: finished reading about lifetimes in chapter 10, thus concluding chapter 10. circling back and reviewing.
</p>
<p><b>[2197880c] 2022-01-31-14-17</b>: lifetimes: a generic in Rust that ensure that references are valid as long as they are needed to be.
</p>
<p><b>[191ab8cb] 2022-01-31-14-14</b>: blanket implementations: implementations of a trait on any type that satisfies the trait bounds.
</p>
<p><b>[9e4d3468] 2022-01-31-14-11</b>: trait bound: a special form in Rust that is used when traits are parameters. It's a long form, and often there's synactic sugar for it "impl Trait".
</p>
<p><b>[241ebf26] 2022-01-31-14-08</b>: lol. It seems I'm still getting tripped up on where "impl" was defined. I guess it's chapter 5? Will have to look back I guess. It's sinking in at this point.
</p>
<p><b>[9348ce70] 2022-01-31-14-08</b>: traits apparently are like interfaces in other languages, not that I use many high-level languages. But I do seem to recall Go having something called interfaces that were very similar to Traits.
</p>
<p><b>[28c5f9a0] 2022-01-31-13-52</b>: Rust traits seem very much the thing to use if I want to implement something similar to the node interface I wrote for graforge in C.
</p>
<p><b>[7927212e] 2022-01-31-13-51</b>: trait: similar to interfaces in other languages, a mechanism used in Rust that tells the Rust compiler about the functionality a particular type has and can share with other types. Can be used to define shared behavior in an abstract way.
</p>
<p><b>[1cd7c915] 2022-01-31-13-50</b>: monomorphization: the process of turning generic code into specific code by filling in the concrete types that are used when compiled.
</p>
<p><b>[35649cf0] 2022-01-31-13-49</b>: it's interesting to know that there's no performance overhead in using generics. I've heard that compilation times are slow though, so I wonder if there's a penalty there?
</p>
<p><b>[de90e203] 2022-01-31-13-48</b>: I am confused by code example 10-11. I wrote the comment "okay... this could get complicated quickly". It looks like I was getting tripped up by all the generic variables T, U, V, and W and how they relate.
</p>
<p><b>[e6513dac] 2022-01-31-13-44</b>: I guess "impl" was used already in chapter 5 when implementing methods in structs. I clearly have forgotten that already.
</p>
<p><b>[da18bfe2] 2022-01-31-13-43</b>: Generics in Enums are a little bit strange to me. I'm really used to C Enums. Giving them types all of a sudden confuses me.
</p>
<p><b>[76ecb7e8] 2022-01-31-13-41</b>: integer and floating point notation is often interchangeable in so many languages, I wasn't yet sure if they could be interchangeable in 10-6. Next page answered my question.
</p>
<p><b>[0f569073] 2022-01-31-13-36</b>: The generics chapter is a pretty meaty chapter. Found my way up to lifetimes, and thought it was a good time to review and re-read my scribbles.
</p>
<p><b>[a7c61ce5] 2022-01-24-16-40</b>: onto chapter 10. halfway through pretty much!
</p>
<p><b>[bf3b83a5] 2022-01-24-16-35</b>: backtrace: a list of all the functions that have been called to get to this point.
</p>
<p><b>[2dad3c26] 2022-01-24-10-51</b>: now on error handling
</p>
<p><b>[18e613ec] 2022-01-24-10-50</b>: SipHash: default hash used in Rust, designed to be resilient against DoS attacks. This algorithm is a tradeoff of security over performance.
</p>
<p><b>[9b8e4cc5] 2022-01-24-10-49</b>: hashmap uses SipHash by default, which favors security over performance. this can be changed with something called a <code>hasher</code>.
</p>
<p><b>[94328768] 2022-01-24-10-49</b>: hashmaps. the example in the book uses a hashmap to store scores as integers. but there is no type definition. so is the type annotation implied?
</p>
<p><b>[3dae3dab] 2022-01-24-10-47</b>: grapheme cluster: a unit of measurement for strings in Rust. A close analagy would be a letter. Things like Devanagari script that use diacritics can have grapheme clusters with a variable number of bytes.
</p>
<p><b>[6a03fca4] 2022-01-24-10-45</b>: rust considers strings to be bytes, scalar values, and grapheme clusters (letters, more or less).
</p>
<p><b>[dc41ca67] 2022-01-24-10-44</b>: strings are painful for programmers coming from C-like languages because strings are just byte arrays and thats the end of the conversation. Meanwhile, Rust aims to support strings as things that embed language, which goes beyond just ASCII and byte streams.
</p>
<p><b>[aad7c228] 2022-01-24-10-42</b>: enums are how you get vectors of multiple types. will have to look at that more closely.
</p>
<p><b>[3e4a56a1] 2022-01-24-10-41</b>: May have to check out the Rustonomicon
</p>
<p><b>[014627e0] 2022-01-24-10-41</b>: vectors seem very familiar (as in flexible arrays, not math vectors). bounds checking and the like seems to be trickier than usual.
</p>
<p><b>[92101953] 2022-01-24-10-38</b>: am now in the rustbook chapter on various collections. I have read now, now I am logging various notes here.
</p>
<p><b>[13a42462] 2022-01-20-13-04</b>: rustbook just dropped the concept of <code>deref coercion</code>, which apparently gets discussed more in detail in chapter 15. It sounds similar to recasting and type punning in C, but more formal and strict (obviously).
</p>
<p><b>[09a6efbd] 2022-01-20-12-59</b>: type annotation: in rust, this refers to explicitely labelling what something is, such as <code><i32></code>.
</p>
<p><b>[1507a56a] 2022-01-12-09-58</b>: next paragraph uses the word 'convention'. methinks so.
</p>
<p><b>[7446f271] 2022-01-12-09-57</b>: does idiomatic <code></code> conventional?
</p>
<p><b>[e5076bc4] 2022-01-12-09-50</b>: "enums aren't useful unless their variants are public". need to remember what an enum variant is.
</p>
<p><b>[d2969975] 2022-01-12-09-45</b>: I'm still how super is working with serveorder without the namespace?
</p>
<p><b>[7b3cc1a5] 2022-01-12-09-34</b>: privacy boundary: the line that encapsulates the implementation details isn't allowed to know about, or rely on.
</p>
<p><b>[9b810c9b] 2022-01-11-15-11</b>: to look up items in a module tree, rust employs both <b>relative</b> and <b>absolute</b> paths. <b>absolute</b> is done using a crate name or the literal <code>crate</code>. A relative path starts from the current path and uses <code>self</code>, <code>super</code>, or an identifier in the current module.
</p>
<p><b>[b103efb5] 2022-01-11-15-07</b>: modules nest. huh. interesting.
</p>
<p><b>[4370bd89] 2022-01-11-15-04</b>: create a new library restaurant: <code>cargo new --lib restaurant</code>.
</p>
<p><b>[cb67d041] 2022-01-11-15-02</b>: privacy (rust): in the context of modules, the determination whether an item can be used by outside code (public) or not.
</p>
<p><b>[cc3aca12] 2022-01-11-15-01</b>: modules (rust): thing that organizes code within a crate into groups for readability and easy reuse.
</p>
<p><b>[949d3606] 2022-01-11-14-57</b>: package: one or more crates that provide a set of functionality.
</p>
<p><b>[91a05de6] 2022-01-11-14-56</b>: crate: a binary or library.
</p>
<p><b>[2fc9309e] 2022-01-11-14-56</b>: crate root: source file that the rust compiler starts from and makes up the root module of your crate.
</p>
<p><b>[b380fa20] 2022-01-10-16-36</b>: currently at chapter 7. also took the time to update the (<a href="/brain/rustbook">rustbook</a>) page with chapters and some quick words. it turns out the Rust Book PDF I made doesn't have the TOC or any mention of chapter number after the intro?
</p>
<p><b>[39a15e21] 2022-01-05-11-13</b>: oh. now the page is okay. weird. ugh.
</p>
<p><b>[416423a4] 2022-01-05-11-12</b>: not sure why this (<a href="/brain/rustbook">rustbook</a>) page renders small text on mobile. stupid web.
</p>
<p><b>[17c89f14] 2022-01-05-10-18</b>: made this rustbook label.
</p>
</div>
</body>
</html>
