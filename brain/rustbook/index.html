<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/brain/css/style.css">

</head>
<body>
<div id="main">
<title>Rust Book</title>
<h1>Rust Book</h1>

<h2>Overview</h2>

<p>Various notes and thoughts regarding the Rust Book.
</p>

<h2>Chapter 1: How to install rust</h2>

<p>I was pleasantly surprised that I could get things working
on Alpine without too much issue.
</p>

<h2>Chapter 2: hands-on intro to rust</h2>

<p>I intially skipped this, then went back just to get used
to building projects with cargo.
</p>

<h2>Chapter 3: Rust features similar to other languages</h2>

<p>Yeah, this mostly felt familiar.
</p>

<h2>Chapter 4: Ownership</h2>

<p>I thought this was introduced pretty well. I have a feeling
that this will get tricky quickly in practice though. Already
it is having me re-think how I'd port some of the
functionality of graforge to Rust.
</p>

<h2>Chapter 5: Structs and Methods</h2>

<p>Reasonably familiar C-ish concepts.
</p>

<h2>Chapter 6: Enums, Match, etc</h2>

<p>This kind of looks like a case switch if you squint. I've had
experience with pattern matching from FAUST, which I believe
is where it is heading. Will be interested to see what that
looks like.
</p>
<p>Overall, I feel like this is more powerful than it looks.
</p>

<h2>Chapter 7: Modules</h2>

<p>Packages, Crates, and Modules. Relative and absolute paths.
The <code>use</code> statement. Private vs Public code.
</p>

<h2>Chapter 8: Common Collection Data Structures</h2>

<p>A jumble of common data structs.
</p>
<p>Vectors: creating, updating, out-of-scope/dropping, reading,
iterating, using an enum to store multiple types in a
vector.
</p>
<p>Strings: these are challenging for newcomers to grok! Many
different types of strings.
</p>
<p>Hashmaps: kind of what you'd expect. Rust uses a hash
algorithm by default that is a trades performance
for security (SipHash).
</p>

<h2>Chapter 9: Error Handling</h2>

<p>Recoverable and unrecoverable.
</p>
<p>Panic backtraces. Recoverable errors using the <code>Result</code> type.
Using the <code>match</code> operator to match errors. <code>unwrap</code> and
<code>expect</code>. Error propagation, with an example
starting verbosely with match and adding syntactic sugar
to make things clearer. Introduction to the <code>?</code> operator.
Best practices for when to panic or not to panic. Creating
custom types for validation.
</p>

<h2>Chapter 10: Generics, Traits, and Lifetimes</h2>

<p>This is a very meaty chapter! generic type
parameters (apply code to different types),
traits and trait bounds (even though types are
generic, ensure that they'll have the correct
behavior the code needs), and generic lifetime
parameters (ensures that code won't have dangling
references).
</p>
<p>Generics: the one feature everybody loves to talk about
Go <b>not</b> having.
</p>
<p>Generics in: Structs, Enums, Method definitions. The
way generics are mixed up in 10-11 is kind of confusing to
me.
</p>
<p>Generics do not add any additional overhead (but I bet
the compile time gets a penalty). Some explanation for
how this works.
</p>
<p>Traits: kind of like interfaces in other languages (makes me
think of Go? Been a while since I wrote any Go.)
</p>
<p>Using tweets vs news article summaries as an example.
Default implementations. Traits as parameters.
</p>
<p>Trait bounds, and trait bounds syntax. Using trait bounds
to conditionally implement methods.
</p>
<p>Lifetimes: the scope for which a reference is valid.
</p>
<p>Dangling references, Borrow Checker, Generic lifetimes in
functions, Lifetime annotation syntax, annotations in function
signatures, thinking in terms of lifetimes, lifetime elision,
annotations in method defintions, static lifetimes.
</p>

<h2>Chapter 11: Testing</h2>

<p>TBD.
</p>

<h2>Chapter 12: Implementing A Toy Grep</h2>

<p>TBD.
</p>

<h2>Chapter 13: Closures and Iterators</h2>

<p>TBD.
</p>

<h2>Chapter 14: Cargo In-Depth</h2>

<p>TBD.
</p>

<h2>Chapter 15: Smart Pointers</h2>

<p>TBD.
</p>

<h2>Chapter 16: Different Models of Concurrency</h2>

<p>TBD.
</p>

<h2>Chapter 17: Object Oriented Programming</h2>

<p>TBD.
</p>

<h2>Chapter 18: Patterns and Pattern Matching</h2>

<p>TBD.
</p>

<h2>Chapter 19: Advanced Topics</h2>

<p>TBD.
</p>

<h2>Chapter 20: A multi-threaded webserver</h2>

<p>TBD.
</p>

<h2>Messages</h2>

<p>Any messages tagged with the group <code>rustbook</code>.
</p>
<p><b>[ad8ace1b] 2022-02-24-09-34</b>: wrote blurb on chapter 11 (testing). chapter 12 looks like more of a hands-on chapter.
</p>
<p><b>[42cd3730] 2022-02-24-09-33</b>: integration tests: check that many parts of the library work together correctly. Use the library's public API similar to how external code will use it.
</p>
<p><b>[6ab3efa5] 2022-02-24-09-32</b>: unit test: excersize different parts of a library separately. Can test private implementation details.
</p>
<p><b>[1d2009a7] 2022-02-24-09-26</b>: correctness: the extent to which code does what it is intended to do.
</p>
<p><b>[6a6cee19] 2022-02-05-14-48</b>: the <code>longest_with_announcement</code> function at the end of chapter 10 looks quite dense, and worth studying for later IMO.
</p>
<p><b>[ddebee31] 2022-02-05-14-47</b>: "in the future, even fewer lifetime annotations might be required". so, I'm assuming these become tedious to manage.
</p>
<p><b>[037aefd1] 2022-02-05-14-46</b>: "violation of memory safety"
</p>
<p><b>[46c4e62b] 2022-02-05-14-45</b>: does rust make implicit calls to malloc (or equivalent)? thinking about realtime performance. does one have to be mindful of this?
</p>
<p><b>[17f298af] 2022-02-05-14-44</b>: lifetimes are indicated by an apostrophe ('), and apparently are expected to be all lowercase and very short. Is this idiomatic then?
</p>
<p><b>[2caf952c] 2022-02-05-14-42</b>: the main aim of lifetimes is to prevent dangling references.
</p>
<p><b>[af69c8da] 2022-02-05-14-42</b>: lifetime: the scope for which a reference is valid.
</p>
<p><b>[5c367ac9] 2022-02-05-14-40</b>: finished reading about lifetimes in chapter 10, thus concluding chapter 10. circling back and reviewing.
</p>
<p><b>[2197880c] 2022-01-31-14-17</b>: lifetimes: a generic in Rust that ensure that references are valid as long as they are needed to be.
</p>
<p><b>[191ab8cb] 2022-01-31-14-14</b>: blanket implementations: implementations of a trait on any type that satisfies the trait bounds.
</p>
<p><b>[9e4d3468] 2022-01-31-14-11</b>: trait bound: a special form in Rust that is used when traits are parameters. It's a long form, and often there's synactic sugar for it "impl Trait".
</p>
<p><b>[241ebf26] 2022-01-31-14-08</b>: lol. It seems I'm still getting tripped up on where "impl" was defined. I guess it's chapter 5? Will have to look back I guess. It's sinking in at this point.
</p>
<p><b>[9348ce70] 2022-01-31-14-08</b>: traits apparently are like interfaces in other languages, not that I use many high-level languages. But I do seem to recall Go having something called interfaces that were very similar to Traits.
</p>
<p><b>[28c5f9a0] 2022-01-31-13-52</b>: Rust traits seem very much the thing to use if I want to implement something similar to the node interface I wrote for graforge in C.
</p>
<p><b>[7927212e] 2022-01-31-13-51</b>: trait: similar to interfaces in other languages, a mechanism used in Rust that tells the Rust compiler about the functionality a particular type has and can share with other types. Can be used to define shared behavior in an abstract way.
</p>
<p><b>[1cd7c915] 2022-01-31-13-50</b>: monomorphization: the process of turning generic code into specific code by filling in the concrete types that are used when compiled.
</p>
<p><b>[35649cf0] 2022-01-31-13-49</b>: it's interesting to know that there's no performance overhead in using generics. I've heard that compilation times are slow though, so I wonder if there's a penalty there?
</p>
<p><b>[de90e203] 2022-01-31-13-48</b>: I am confused by code example 10-11. I wrote the comment "okay... this could get complicated quickly". It looks like I was getting tripped up by all the generic variables T, U, V, and W and how they relate.
</p>
<p><b>[e6513dac] 2022-01-31-13-44</b>: I guess "impl" was used already in chapter 5 when implementing methods in structs. I clearly have forgotten that already.
</p>
<p><b>[da18bfe2] 2022-01-31-13-43</b>: Generics in Enums are a little bit strange to me. I'm really used to C Enums. Giving them types all of a sudden confuses me.
</p>
<p><b>[76ecb7e8] 2022-01-31-13-41</b>: integer and floating point notation is often interchangeable in so many languages, I wasn't yet sure if they could be interchangeable in 10-6. Next page answered my question.
</p>
<p><b>[0f569073] 2022-01-31-13-36</b>: The generics chapter is a pretty meaty chapter. Found my way up to lifetimes, and thought it was a good time to review and re-read my scribbles.
</p>
<p><b>[a7c61ce5] 2022-01-24-16-40</b>: onto chapter 10. halfway through pretty much!
</p>
<p><b>[bf3b83a5] 2022-01-24-16-35</b>: backtrace: a list of all the functions that have been called to get to this point.
</p>
<p><b>[2dad3c26] 2022-01-24-10-51</b>: now on error handling
</p>
<p><b>[18e613ec] 2022-01-24-10-50</b>: SipHash: default hash used in Rust, designed to be resilient against DoS attacks. This algorithm is a tradeoff of security over performance.
</p>
<p><b>[9b8e4cc5] 2022-01-24-10-49</b>: hashmap uses SipHash by default, which favors security over performance. this can be changed with something called a <code>hasher</code>.
</p>
<p><b>[94328768] 2022-01-24-10-49</b>: hashmaps. the example in the book uses a hashmap to store scores as integers. but there is no type definition. so is the type annotation implied?
</p>
<p><b>[3dae3dab] 2022-01-24-10-47</b>: grapheme cluster: a unit of measurement for strings in Rust. A close analagy would be a letter. Things like Devanagari script that use diacritics can have grapheme clusters with a variable number of bytes.
</p>
<p><b>[6a03fca4] 2022-01-24-10-45</b>: rust considers strings to be bytes, scalar values, and grapheme clusters (letters, more or less).
</p>
<p><b>[dc41ca67] 2022-01-24-10-44</b>: strings are painful for programmers coming from C-like languages because strings are just byte arrays and thats the end of the conversation. Meanwhile, Rust aims to support strings as things that embed language, which goes beyond just ASCII and byte streams.
</p>
<p><b>[aad7c228] 2022-01-24-10-42</b>: enums are how you get vectors of multiple types. will have to look at that more closely.
</p>
<p><b>[3e4a56a1] 2022-01-24-10-41</b>: May have to check out the Rustonomicon
</p>
<p><b>[014627e0] 2022-01-24-10-41</b>: vectors seem very familiar (as in flexible arrays, not math vectors). bounds checking and the like seems to be trickier than usual.
</p>
<p><b>[92101953] 2022-01-24-10-38</b>: am now in the rustbook chapter on various collections. I have read now, now I am logging various notes here.
</p>
<p><b>[13a42462] 2022-01-20-13-04</b>: rustbook just dropped the concept of <code>deref coercion</code>, which apparently gets discussed more in detail in chapter 15. It sounds similar to recasting and type punning in C, but more formal and strict (obviously).
</p>
<p><b>[09a6efbd] 2022-01-20-12-59</b>: type annotation: in rust, this refers to explicitely labelling what something is, such as <code><i32></code>.
</p>
<p><b>[1507a56a] 2022-01-12-09-58</b>: next paragraph uses the word 'convention'. methinks so.
</p>
<p><b>[7446f271] 2022-01-12-09-57</b>: does idiomatic <code></code> conventional?
</p>
<p><b>[e5076bc4] 2022-01-12-09-50</b>: "enums aren't useful unless their variants are public". need to remember what an enum variant is.
</p>
<p><b>[d2969975] 2022-01-12-09-45</b>: I'm still how super is working with serveorder without the namespace?
</p>
<p><b>[7b3cc1a5] 2022-01-12-09-34</b>: privacy boundary: the line that encapsulates the implementation details isn't allowed to know about, or rely on.
</p>
<p><b>[9b810c9b] 2022-01-11-15-11</b>: to look up items in a module tree, rust employs both <b>relative</b> and <b>absolute</b> paths. <b>absolute</b> is done using a crate name or the literal <code>crate</code>. A relative path starts from the current path and uses <code>self</code>, <code>super</code>, or an identifier in the current module.
</p>
<p><b>[b103efb5] 2022-01-11-15-07</b>: modules nest. huh. interesting.
</p>
<p><b>[4370bd89] 2022-01-11-15-04</b>: create a new library restaurant: <code>cargo new --lib restaurant</code>.
</p>
<p><b>[cb67d041] 2022-01-11-15-02</b>: privacy (rust): in the context of modules, the determination whether an item can be used by outside code (public) or not.
</p>
<p><b>[cc3aca12] 2022-01-11-15-01</b>: modules (rust): thing that organizes code within a crate into groups for readability and easy reuse.
</p>
<p><b>[949d3606] 2022-01-11-14-57</b>: package: one or more crates that provide a set of functionality.
</p>
<p><b>[91a05de6] 2022-01-11-14-56</b>: crate: a binary or library.
</p>
<p><b>[2fc9309e] 2022-01-11-14-56</b>: crate root: source file that the rust compiler starts from and makes up the root module of your crate.
</p>
<p><b>[b380fa20] 2022-01-10-16-36</b>: currently at chapter 7. also took the time to update the (<a href="/brain/rustbook">rustbook</a>) page with chapters and some quick words. it turns out the Rust Book PDF I made doesn't have the TOC or any mention of chapter number after the intro?
</p>
<p><b>[39a15e21] 2022-01-05-11-13</b>: oh. now the page is okay. weird. ugh.
</p>
<p><b>[416423a4] 2022-01-05-11-12</b>: not sure why this (<a href="/brain/rustbook">rustbook</a>) page renders small text on mobile. stupid web.
</p>
<p><b>[17c89f14] 2022-01-05-10-18</b>: made this rustbook label.
</p>
</div>
</body>
</html>
