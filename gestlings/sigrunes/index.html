<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/gestlings/css/style.css">

</head>
<body>
<div id="main">
<p><title>Sigrunes (WIP)</title>
<h1>Sigrunes (WIP)</h1>
Signal Runes, or Sigrunes, are core unit generators from
sndkit that have a specific symbol associated with it,
known runes. The runes are used to help build up
compact visualizations of sndkit patches in a tree diagram
known as a Signal Tree, or Sigtree.
</p>
<p>In Lua, Sigrunes are nodes compatible with <a href="/gestlings/diagraf">diagraf</a>.
Sigrunes will also have additional information attached
to them concerning their associated glyph, probably
in the form of some bitmap (12x12 or 16x16, not sure yet).
</p>
<p>Incomplete work. For now, these just need to be runes.
</p>
<div><b><i>&lt;&lt;sigrunes.lua&gt;&gt;=</i></b></div><pre><code>Sigrunes = {}

S = Sigrunes

function S.butlp(n, p)
    n.input = n:param(0)
    n.cutoff = n:param(p.cutoff or 1000)
    n:lil("butlp zz zz")
    n:label("butlp")
end

function S.buthp(n, p)
    n.input = n:param(0)
    n.cutoff = n:param(p.cutoff or 1000)
    n:lil("buthp zz zz")
    n:label("buthp")
end

function S.wavout(n, p)
    local file = p.file or "test.wav"
    n.input = n:param(p.input or 0)
    n:lil(string.format("wavout zz %s", file))
    n:label("wavout")
end

function S.blsaw(n, p)
    n.freq = n:param(p.freq or 440)
    n:lil("blsaw zz")
    n:label("blsaw")
end

function S.blsquare(n, p)
    n:lil("blsquare zz")
    n.freq = n:param(p.freq or 440)
    n:label("blsquare")
end

function S.mul(n, p)
    n.a = n:param(p.a or 0)
    n.b = n:param(p.b or 0)
    n:lil("mul zz zz")
    n:label("mul")
end

function S.add(n, p)
    n.a = n:param(p.a or 0)
    n.b = n:param(p.b or 0)
    n:lil("add zz zz")
    n:label("add")
end

function S.add(n, p)
    n.a = n:param(p.a or 0)
    n.b = n:param(p.b or 0)
    n:lil("add zz zz")
    n:label("add")
end

function S.sub(n, p)
    n.a = n:param(p.a or 0)
    n.b = n:param(p.b or 0)
    n:lil("sub zz zz")
    n:label("sub")
end

function S.sine(n, p)
    n.freq = n:param(p.freq or 440)
    n.amp = n:param(p.amp or 0.5)
    n:lil("sine zz zz")
    n:label("sine")
end

function S.biscale(n, p)
    n.input = n:param(p.input or 0)
    n.min = n:param(p.min or 0)
    n.max = n:param(p.max or 1)
    n:lil("biscale zz zz zz")
    n:label("biscale")
end

function S.scale(n, p)
    n.input = n:param(p.input or 0)
    n.min = n:param(p.min or 0)
    n.max = n:param(p.max or 1)
    n:lil("scale zz zz zz")
    n:label("scale")
end

function S.getter(n, p)
    n.cab = p.cab
    n.data.gen = function(self)
        return self.cab:getstr()
    end

    n.data.constant = false
    n:label("getter")
end

function S.setter(n, p)
    n.input = n:param(0)
    local sig = p.sig
    n.cab = sig:new()

    n.data.gen = function(self)
        return self.cab:hold(self.data.g.eval)
    end

    n.data.constant = false
    n:label("setter")
end

function S.releaser(n, p)
    n.cab = p.cab

    n.data.gen = function(self)
        return self.cab:unhold(self.data.g.eval)
    end

    n.data.constant = false
    n:label("releaser")
end

function S.metro(n, p)
    n.rate = n:param(p.rate or 1)
    n:lil("metro zz")
    n:label("metro")
end

function S.env(n, p)
    n.trig = n:param(0)
    n.atk = n:param(p.atk or 0.001)
    n.dec = n:param(p.dec or 0.01)
    n.rel = n:param(p.rel or 0.1)
    n:lil("env zz zz zz zz")
    n:label("env")
end

function S.noise(n, p)
    n:lil("noise")
    n:label("noise")
end

function S.peakeq(n, p)
    n.input = n:param(0)
    n.freq = n:param(p.freq or 1000)
    n.bw = n:param(p.bw or 1000)
    n.gain = n:param(p.gain or 1)
    n:lil("peakeq zz zz zz zz")
    n:label("peakeq")
end

function S.mtof(n, p)
    n.input = n:param(p.input or 0)
    n:lil("mtof zz")
    n:label("mtof")
end

function S.butbp(n, p)
    n.input = n:param(0)
    n.freq = n:param(p.freq or 1000)
    n.bw = n:param(p.bw or 1000)
    n:lil("butbp zz zz zz")
    n:label("butbp")
end

function S.crossfade(n, p)
    n.a = n:param(p.a or 0)
    n.b = n:param(p.b or 1)
    n.pos  = n:param(p.pos or 0)
    n:lil("crossfade zz zz zz")
    n:label("crossfade")
end

function S.dblin(n, p)
    n.db = n:param(p.db or 0)
    n:lil("dblin zz")
    n:label("dblin")
end

function S.rline(n, p)
    n.min = n:param(p.min or 0)
    n.max = n:param(p.max or 1)
    n.rate = n:param(p.rate or 3)
    n:lil("rline zz zz zz")
    n:label("rline")
end


&lt;&lt;nodes&gt;&gt;

dummy = {}
dummy.eval = lil
function dummy:lil(str)
    self.eval(str)
end

function dummy:param(v)
    if type(v) == "function" then
        v(self.eval)
    elseif type(v) == "table" and v.lilnode then
		self.eval(v.lilstr)
    else
        self.eval("param " .. v)
    end
end

function dummy:label(str)

end


-- instead of using a sigrune node in a graph, evaluate it
-- by itself in-place
function S.node(n, p)
    p = p or {}
    return function (p)
        n(dummy, p)
    end
end

-- to use a node as a parameter inside of lilnode, call
-- paramnode
function S.paramnode(n, p)
    p = p or {}
    return function(p)
        return function (eval)
            -- eval is already in dummy
            n(dummy, p)
        end
    end
end

function S.node_debug(debug)
    if debug then
        dummy.eval = print
    else
        dummy.eval = lil
    end
end

return Sigrunes</pre></code>
<div><b><i>&lt;&lt;nodes&gt;&gt;=</i></b></div><pre><code>function S.phasor(n, p)
    n.rate = n:param(p.rate or 0)
    n.iphs = p.iphs or 0
    n:lil(string.format("phasor zz %g", n.iphs))
    n:label("phasor")
end</pre></code>
<p></p>
<p>TODO: gesture nodes might not be needed anymore...
use gest module instead
</p>
<div><b><i>&lt;&lt;nodes&gt;&gt;=</i></b></div><pre><code>function gestvmnode(glive, membuf, program, conductor)
    return string.format(
        "%s; [gmemsym [grab %s] %s]; %s; gestvmnode zz zz zz",
        glive, membuf, program, conductor)

end
function S.gesture(n, p)
	local glive = p.glive or "[glget [grab glive]]"
	local mem = p.mem or "mem"
	local name = p.name or "gst"

	program = 
		string.format("[gmemsym [grab %s] %s]", mem, name)
	n.glive = n:param(glive)
    n.conductor = n:param(p.conductor or 0)
    n:lil("gestvmnode zz " .. program .. " zz")
    n:label("gesture: " .. name)
end</pre></code>
<div><b><i>&lt;&lt;nodes&gt;&gt;=</i></b></div><pre><code>function S.fmpair(n, p)
    n.tab = n:param(p.tab)
    n.freq = n:param(p.freq or 440)
    n.car = n:param(p.car or 1)
    n.mod = n:param(p.mod or 1)
    n.mi = n:param(p.mi or 1)
    n.fdbk = n:param(p.fdbk or 0)
    n:lil("fmpair zz zz zz zz zz zz")
    n:label("fmpair")
end</pre></code>
<div><b><i>&lt;&lt;nodes&gt;&gt;=</i></b></div><pre><code>function S.envar(n, p)
    n.gate = n:param(p.gate or 0)
    n.atk = n:param(p.atk or 0.1)
    n.rel = n:param(p.rel or 0.1)
    n:lil("envar zz zz zz")
    n:label("envar")
end</pre></code>
<div><b><i>&lt;&lt;nodes&gt;&gt;=</i></b></div><pre><code>function S.osc(n, p)
    n.tab = n:param(p.tab)
    n.iphs = p.iphs or 0
    n.freq = n:param(p.freq or 440)
    n.amp = n:param(p.amp or 0.5)
    n:lil(string.format("osc zz zz zz %g", n.iphs))
    n:label("osc")
end</pre></code>
<div><b><i>&lt;&lt;nodes&gt;&gt;=</i></b></div><pre><code>function S.tgate(n, p)
    n.trig = n:param(p.trig or 0)
    n.dur = n:param(p.dur or 0.5)
    n:lil("tgate zz zz")
    n:label("tgate")
end</pre></code>
<div><b><i>&lt;&lt;nodes&gt;&gt;=</i></b></div><pre><code>function S.gtick(n, p)
    n.gate = n:param(p.gate or 0)
    n:lil("gtick zz")
    n:label("gtick")
end</pre></code>
<div><b><i>&lt;&lt;nodes&gt;&gt;=</i></b></div><pre><code>function S.smoother(n, p)
    n.input = n:param(p.input or 0)
    n.smooth = n:param(p.smooth or 0)
    n:lil("smoother zz zz")
    n:label("smoother")
end</pre></code>
</div>
</body>
</html>
