<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/gestlings/css/style.css">

</head>
<body>
<div id="main">
<title>TODO</title>
<h1>TODO</h1>
<p>Tasks for Gestlings. Updated automatically using <a href="/wiki/zetdo">zetdo</a>.
</p>
<p></p>

<h2>create interactive interface for exploring sound states in tubular</h2>

<a id="44919d9c"></a><p>UUID: <a href="#44919d9c">#44919d9c</a>.
</p>
<blockquote>
<p><b>2023-07-17 21:41:56</b>: it's a bit of an indulgence, but I can't resist making some procedurally generated bit-labels. 4-bits tall, and variable width. I want these to comply with kufic rules. It ends up being a FSM which shouldn't be too difficult to generate. If I can do this, it'll be easier to save shape states. Not having to think about naming shaves off some time and cognitive overhead.
</p>
<p><b>2023-07-16 20:01:48</b>: shapes are going to need some kind of label (randomly generated or curated), and those are going to be represented as symbols. brainstorming some potential symbols to add to blocky6 for this purpose.
</p>
<p><b>2023-07-16 18:03:07</b>: got a little sucked in with this interface. initial functionality is very engaging. I need a way to quickly save and retrieve shapes.
</p>
<p><b>2023-07-16 14:10:28</b>: at this point, I have all the components I need to actually start building out this interface. now I have to actually flesh this interface out.
</p>
<p><b>2023-07-07 13:30:35</b>: anyways, this is probably more of a line of thought for my bitrune editor task in gkjfhkfl. will ramble onwards there.
</p>
<p><b>2023-07-07 13:28:32</b>: what will be significantly different is the information density. The "slab" was already quite small at the 320x240 resolution (most likely upscaled on a framebuffer). The monome offers 16x8 resolution, which is barely enough to display a few fragments of information at a time. I'm struggling with how to approach this constraint.
</p>
<p><b>2023-07-07 13:25:42</b>: I'd like to think that the essence of bitrune and what it is for hasn't changed. Bitrune is about writing symbols down, and having the act of notation be the means of interfacing the systems underneath it.
</p>
<p><b>2023-07-07 13:21:41</b>: bitrune is going to be my editor for the gestlings. So, I've decided to pivot slightly. Instead of using a framebuffer for display, the grid is going to be used (my 16x8 grid). Obviously, this is going to change a few things in the plan.
</p>
<p><b>2023-07-07 13:20:01</b>: so, it's come to my attention that monome is making a 16x16 grid. These don't get made too often, and may be my only shot to acquire one. Finances are tight for me, so if I'm to get it, I need to use it.
</p>
<p><b>2023-07-01 16:12:14</b>: create gesture controlled table morpher that works with tubular
</p>
<p><b>2023-06-29 13:16:39</b>: bitrune initial editor
</p>
</blockquote>
<p>2 subtasks.
</p>
</p>

<h3>bitrune initial editor</h3>

<a id="6534637c"></a><p>UUID: <a href="#6534637c">#6534637c</a>.
</p>
<p>scope out and create bitrune: a text editor for symbols and slabs
</p>
<blockquote>
<p><b>2023-07-13 12:15:21</b>: wow, managed base64 encode/decode IO AND managed to get line breaks in there too.
</p>
<p><b>2023-07-13 10:11:03</b>: finishing touches for now. I'm sure there will be more I'll want to tweak later. But time is limited.
</p>
<p><b>2023-07-13 10:10:35</b>: in what I hope will be my last finishing touches to this editor, I am going to add base64 encoding/decoding to the IO. This will make it match the other assets in this system.
</p>
<p><b>2023-07-11 15:37:35</b>: initial lua components created. things seem to work.
</p>
<p><b>2023-07-11 14:18:23</b>: I think I have enough in place where I can begin to start to think about writing out the lua components and importing code into this repo.
</p>
<p><b>2023-07-10 18:19:11</b>: added an initial message buffer for evaluating lines. nothing for blocks yet.
</p>
<p><b>2023-07-10 17:07:31</b>: it's the worlds brittlest incomplete msgpack parser, but it works well enough for the keyshape config file
</p>
<p><b>2023-07-10 16:26:03</b>: going to attempt to get some keyboard shortcuts loaded from disk. will generate the data via messageback in a throw-away lua script, then write a parser that will load that data.
</p>
<p><b>2023-07-09 21:22:14</b>: I'm going to need to way to load keyboard shortcuts ("keyshapes") into the program. I'm thinking about barebones msgpack again, since I'm doing that already for the symbols file.
</p>
<p><b>2023-07-09 21:20:32</b>: the structure of the main() function is beginning to resemble what I was imagining for the lua program, so I think this is a pretty good stopping point for today.
</p>
<p><b>2023-07-09 19:16:53</b>: if I can get things split up right in C, I can begin porting those components over to this repo. at that point, I'll be able to rework the main control loop as a Lua program with smaller C subcomponents
</p>
<p><b>2023-07-09 19:15:48</b>: I'm about at the point where I need to start thinking about mnolth lua integration. mnolth already has grid keybindings, and I'd like to use that to manage the grid instead of libmonome directly. there's some magic involved with getting character input that would probably be best in C still.
</p>
<p><b>2023-07-09 16:34:09</b>: I added just enough msgpack to make it save/load an array of bytes. this will probably make things much easier down the line.
</p>
<p><b>2023-07-09 15:56:07</b>: basic load/save capabilities added. the filename is hard coded for now, but that's an easy fix for the future. It'd be interesting to see how easy it would be for lua to parse this. thinking about adding a tiny header that would make it a msgpack array.
</p>
<p><b>2023-07-08 15:45:02</b>: bitrune engine, ortho33, and grid all hooked up, so now there's basic editing and navigation capabilities.
</p>
<p><b>2023-07-08 12:07:18</b>: hooking up ortho33 to my monome grid proof of concept is a sensible next step probably
</p>
<p><b>2023-07-07 20:42:38</b>: I now have a basic navigation interface working on the grid. scrolling, cursor jumping, scroll jumping, and arrow keys for cursor movement. nearly ready to be hooked up to the editor engine and ortho33 input system
</p>
<p><b>2023-07-07 17:08:31</b>: as a proof of concept, I got a small uf2 font to display on the monome grid, and I was able to scroll on the x-axis using the BNR1 knob.
</p>
<p><b>2023-07-07 16:14:32</b>: going to make another symbol set from a uf2. This will be set up so that they are aligned to the top pixels.
</p>
<p><b>2023-07-07 14:04:50</b>: a good low-hanging fruit task is to see if there's a way to transfer a btprnt region to monome grid.
</p>
<p><b>2023-07-07 14:00:20</b>: Due to the information density constraints of the Grid, the concept of a multi-line "slab" may need to change to a single long line "scroll". Creating a viewport mechanic with scrollwheel will also need to be implemented. Also, this new change implies that all symbols will have a maximum height of 6.
</p>
<p><b>2023-07-07 13:56:13</b>: I've had a lot of thoughts about live coding languages for the grid over the last year. In many ways, this new development feels like a return to these ideas. It's tempting to throw out all the work I've made in the past few weeks and start over, but I think it would be more fruitful to try to still stay true to the bitrune vision.
</p>
<p><b>2023-07-07 13:49:05</b>: multiple rows might be a thing. that may be too much for such little information density.
</p>
<p><b>2023-07-07 13:45:23</b>: left/right movement and insert/remove should still be usable as before. An added feature will be the ability for the edit cursor to jump to a place in the current viewing window.
</p>
<p><b>2023-07-07 13:42:46</b>: An edit cursor will also be present, and can move from symbol to symbol, independently of the scroll. This will show up as a video inverter. If the 6-height symbols appear centered, the cursor will extend to the edges to be more visible.
</p>
<p><b>2023-07-07 13:40:52</b>: on the tape are symbols. Due to the restrictions of the 16x8 grid, the character height will most likely be fixed at 6 units (pixels?) high, and variable width.
</p>
<p><b>2023-07-07 13:38:23</b>: After much thinking since last night, the best thing I can come up with with the information density issue is to use a scrolling model. Imagine a turing-like tape of (practically) infinite length, and the Grid as a window that projects part of the tape like looking at microfilm. Using one of the many knobs in my position, one could quickly scroll through the tape and view its contents.
</p>
<p><b>2023-07-07 13:35:41</b>: The information density tradeoff is tough, and has always been the thing holding me back from using it more. While the 16x16 will help with that, it won't immediately overcome some of the hurdles.
</p>
<p><b>2023-07-07 13:33:05</b>: Like I mentioned previously in another comment thread, theres a 16x16 grid that's getting released, and I want it. But it's enough of a purchase that I will need to use it right away for the Gestlings project. A Grid has been sat on my desk for years, and it has been hardly anything more than a paperweight. Between now and July 14th, I'm going to push even harder to make this thing an active tool in my creative workflow.
</p>
<p><b>2023-07-06 20:34:02</b>: some stuff in ortho33 has been reworked. state logic is more decoupled from drawing. there's still a ways to go before it can be used to control the bitrune engine I built.
</p>
<p><b>2023-07-06 19:12:31</b>: okay, now going back to ortho33. this needs to be encapsulated so it can actually be re-used.
</p>
<p><b>2023-07-06 15:07:43</b>: hoping to finish up the initial engine. at that point, hook up to ortho33 for a curses proof of concept?
</p>
<p><b>2023-07-05 22:33:06</b>: not sure if I'm approaching the problem right, but the code seems slightly more elegant this way because I'm breaking actions up into smaller operations. Insert doesn't do anything but insert a character in the current row/symbol position, and change the length of the row by 1. The right movement updates the symbol position by 1. Both can be used independently.
</p>
<p><b>2023-07-05 22:30:12</b>: some initial sketches of code. something that happened while working it out was that "insert" turned into a compound of two verbs: something that actually does the insertion, and then a cursor movement. Without the cursor movement, things gets inserted to the right. So, "A,B,C" inserts would appear "C,B,A".
</p>
<p><b>2023-07-05 18:19:05</b>: A few more words now. I think I have enough here to code some stuff up.
</p>
<p><b>2023-07-05 13:54:39</b>: I have started creating words in playground/bitrune/engine.
</p>
<p><b>2023-07-05 13:21:02</b>: while it's tempting to jump right to rendering, a part of me first feels like I need to work out the interface and editing backend a little bit more. Creating a clean separation between the input method and the editing engine is going to be important.
</p>
<p><b>2023-07-05 13:18:36</b>: there's been lots of off-the-clock casual thinking yesterday. trying to push this into something actionable
</p>
<p><b>2023-07-01 16:11:51</b>: tubular just got done, and I need a way to more interactively sculpt states for it. setting things up well enough for this task would be great.
</p>
<p><b>2023-07-01 16:10:21</b>: there's a lot of small components already made here. uf2 font rendering, a proof of concept ortho33 handler, some SDL framebuffer code lying around which is very close to what is needed, etc. the trick is gluing this all together into something cohesive, and to focus things around an MVP that is actually helpful for the Gestlings.
</p>
</blockquote>
</p>

<h3>create gesture controlled table morpher that works with tubular</h3>

<a id="f4a31e9c"></a><p>UUID: <a href="#f4a31e9c">#f4a31e9c</a>.
</p>
<blockquote>
<p><b>2023-07-15 21:19:25</b>: sounds are working. I think I am done with the initial implementation.
</p>
<p><b>2023-07-15 19:40:42</b>: attempting to build in an interface for tract that preprocesses the DRM shape before applying it to the waveguide.
</p>
<p><b>2023-07-15 16:45:52</b>: this is super janky, but I'm storing the intermediate gesture results in a frame. I'm going to need to rework tubular to be able to take in this data and do the interpolation there.
</p>
<p><b>2023-07-15 16:42:52</b>: I got this far only to realize that audio-rate shaping won't work with the approach I'm doing. updating a single table in another node will make it control rate since it's not storing the previous crossfades. Going to have to rethink some things.
</p>
<p><b>2023-07-14 19:39:26</b>: conceptually, the idea isn't too difficult. When the gesture is computed for a sample, it updates the state an A and B value, as well as a interpolation coefficient that shows how much of each to use. Values become tables, and the coefficient blends the two tables into another table. That other table is then read by an instance of tubular.
</p>
<p><b>2023-07-14 19:34:11</b>: I am now at the point where I should start thinking about the actual synthesis portion. The morphing FM oscillator I made should provide some insights for what I've done in the past.
</p>
<p><b>2023-07-14 17:31:21</b>: I'm getting the sense that lua bindings might need to come next. For that auto-generated lookup table. It's all about getting the data organized right.
</p>
<p><b>2023-07-14 16:04:42</b>: with the lookup table I added to (<a href="/gestlings/path">path</a>) yesterday, I think I can generate ID values for each entry on-the-fly. symbols resolve to sequential indices, which can be used for constant time shape lookup. I'll need a way to export the symbol table to a lua table when the gesture gets compiled to TAL.
</p>
<p><b>2023-07-14 16:00:56</b>: base64 support added, so now it's compatible with the gestling asset format. Now to think about loading it into a meaningful C data struct.
</p>
<p><b>2023-07-14 14:53:16</b>: I'm realized I've made a commitment to use base64 AND msgpack in my assets, so now my components in C need to do this. a bit more technical overhead. maybe a little silly, but oh well.
</p>
<p><b>2023-07-14 14:38:43</b>: the 'tubular' model already has two DRM shapes in the test. these will be used as the baseline. I'll be calling this thingy 'shapemorf'
</p>
<p><b>2023-07-14 14:36:26</b>: working on generated an initial version of the lookup table format, a map in msgpack that maps keys to arrays of 8 16-bit unsigned ints corresponding to the DRM shape.
</p>
<p><b>2023-07-13 18:08:05</b>: thinking about it, the solution I'm liking the most for this is: make it possible for the gesture vertice values to be strings (symbols), and make it possible to resolve them using a look up table (lua table). msgpack is being used as the serialization format, so it shouldn't be too much of an adjustment. investigating the feasability of this approach now.
</p>
<p><b>2023-07-13 15:31:22</b>: current design roadblock is something I am calling the "symbol resolution issue". Gesture paths have 8-bit int values, but names for shapes should have something more meaningful than a number (most likely, it will be a symbol generated on-the-fly using the Bitrune interface). So, symbols should resolve to ID values. But, if maps get updated, does that mean all paths using that map should be updated as well?
</p>
<p><b>2023-07-13 14:27:21</b>: planning some things out for this.
</p>
<p><b>2023-07-01 16:12:56</b>: I need a way for tubular to morph between shapes via gesture, we can generalize this to be a table morpher where all the tables are the same size.
</p>
</blockquote>
</p>

<h2>move uf2.lua out of path folder</h2>

<a id="bbef33e0"></a><p>UUID: <a href="#bbef33e0">#bbef33e0</a>.
</p>
<blockquote>
<p><b>2023-06-05 17:00:21</b>: possibly put into util folder?
</p>
</blockquote>
</p>

<h2>port blipsqueak components into org files</h2>

<a id="ef267bf4"></a><p>UUID: <a href="#ef267bf4">#ef267bf4</a>.
</p>
<blockquote>
</blockquote>
</div>
</body>
</html>
