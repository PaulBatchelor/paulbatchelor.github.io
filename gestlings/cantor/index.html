<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/gestlings/css/style.css">

</head>
<body>
<div id="main">
<p><pre><code>function Sig:hold(lil_eval)
    -- can be a callback used to simulate holding
    lil_eval = lil_eval or lil_default
    if self.reg &gt;= 0 then
        error("can't hold, already holding")
    end

    -- regnxt actually has to be called to see if it is
    -- working

    local lstr = "param [regnxt 0]"
    -- if lil_eval ~= lil then
    --     lil_eval(lstr)
    -- end

    lil(lstr)


    local reg = pop()

    if reg &lt; 0 then
        error("invalid index")
    end

    -- hold/regset can be simulated without issue
    lil_eval({"hold", "zz"})
    -- lil_eval("hold zz # sig")
    lil_eval({"regset", "zz",reg})

    -- regmrk actually has to be called for it to work
    -- local lstr = string.format("regmrk %d", reg)
    local lstr = {"regmrk", reg}

    if lil_eval ~= lil then
        lil_eval(lstr)
    end

    lil(table.concat(lstr, " "))
    -- lil(string.format("regset zz %d; regmrk %d", reg, reg))

    self.reg = reg
end</pre></code>
<p><pre><code>local function lil_default(s)
    if type(s) == "table" then
        s = table.concat(s, " ")
    end
    lil(s)
end
function Graph:new(o)
    o = o or {}
    o.nverts = 0
    o.edges = {}
    o.nodes = {}
    o.sig = o.sig or sig

    if o.eval == nil then
        if o.debug then
            o.eval = print
        else
            o.eval = lil_default
        end
    end
    setmetatable(o, self)
    self.__index = self
    return o
end</pre></code>
<p><pre><code>seq = {
    {A, {1, 1}},
    {B, {2, 1}},
    {C, {2, 1}},
}</pre></code>
<p><pre><code>A2(BC)</pre></code>
<p><pre><code>function Node:compute()
    if self.data.gen ~= nil then
        -- TODO functions that return strings is kinda
        -- messy. sig breaks this. maybe fix?
        local str = self.data.gen(self)
        if str ~= nil then
            -- refactoring things so that eval string is
            -- represented as table of words instead of
            -- string literal
            -- if type(str) == "table" then
            --     str = table.concat(str, " ")
            -- end
            self.data.g.eval(str)
        end
    end
end</pre></code>
<p><pre><code>-- spoof the "node" interface from diagraf
function default_lil_eval(s)
    if type(s) == "table" then
        s = table.concat(s, " ")
    end
    lil(s)
end
dummy = {}
dummy.eval = default_lil_eval

-- this is a hack for the specifically gest node
-- the "glive" parameter for some reason has to be a string
-- it can't work as a callback when it is a parameter node
dummy.sigrune_dummy = true
function dummy:lil(str)
    -- if type(str) == "table" then
    --     str = table.concat(str, " ")
    -- end
    self.eval(str)
end

-- this is a shim for the Node:param() method
-- for some reason, this evals in-place. the current diagraf
-- node method returns something. I think this might be
-- outdated or something? I'll need to revisit.
function dummy:param(v)
    if type(v) == "function" then
        v(self.eval)
    elseif type(v) == "table" and v.lilnode then
		self.eval(v.lilstr)
    else
        self.eval({"param", v})
    end
end

function dummy:label(str)

end</pre></code>
<p><pre><code>function S.dblin(n, p)
    n.db = n:param(p.db or 0)
    n:lil("dblin zz")
    n:label("dblin")
end</pre></code>
<p><pre><code>function S.crossfade(n, p)
    n.a = n:param(p.a or 0)
    n.b = n:param(p.b or 1)
    n.pos  = n:param(p.pos or 0)
    n:lil({"crossfade", "zz", "zz", "zz"})
    n:label("crossfade")
end</pre></code>
<p><pre><code>function S.butbp(n, p)
    n.input = n:param(0)
    n.freq = n:param(p.freq or 1000)
    n.bw = n:param(p.bw or 1000)
    n:lil({"butbp", "zz", "zz", "zz"})
    n:label("butbp")
end</pre></code>
<p><pre><code>function S.mtof(n, p)
    n.input = n:param(p.input or 0)
    n:lil({"mtof", "zz"})
    n:label("mtof")
end</pre></code>
<p><pre><code>function S.peakeq(n, p)
    n.input = n:param(0)
    n.freq = n:param(p.freq or 1000)
    n.bw = n:param(p.bw or 1000)
    n.gain = n:param(p.gain or 1)
    n:lil("peakeq zz zz zz zz")
    n:label("peakeq")
end</pre></code>
<p><pre><code>function S.env(n, p)
    n.trig = n:param(0)
    n.atk = n:param(p.atk or 0.001)
    n.dec = n:param(p.dec or 0.01)
    n.rel = n:param(p.rel or 0.1)
    n:lil("env zz zz zz zz")
    n:label("env")
end</pre></code>
<p><pre><code>Whistle = {}

&lt;&lt;oscillator&gt;&gt;
return Whistle</pre></code>
<p><pre><code>Gest = {}

&lt;&lt;behavior_constants&gt;&gt;
&lt;&lt;gest&gt;&gt;
return Gest</pre></code>
<p><pre><code>function Gest:new(o)
    o = o or {}
    o.name = o.name or "glive"
    o.bufname = o.bufname or "mem"
    o.tal = o.tal or tal
    assert(o.tal ~= nil, "tal not found")
    setmetatable(o, self)
    self.__index = self
    return o
end</pre></code>
<p><pre><code>function Gest:create()
    lil("glnew " .. self.name)
    self.tal.membuf(self.bufname)
end</pre></code>
<p><pre><code>function Gest:compile(words)
    self.tal.compile_words(words,
        self.bufname,
        string.format("[glget [grab %s]]", self.name))
end</pre></code>
<p><pre><code>function Gest:compile_tal(program)
    self.tal.compile(program,
        self.bufname,
        string.format("[glget [grab %s]]", self.name))
end</pre></code>
<p><pre><code>function Gest:swapper()
    lil(string.format("glswapper [grab %s]", self.name))
end</pre></code>
<p><pre><code>function Gest:done()
    lil(string.format("gldone [grab %s]", self.name))
end</pre></code>
<p><pre><code>function Gest:get()
    return string.format("[glget [grab %s]]", self.name)
end</pre></code>
<p><pre><code>function Gest:node_old(program, conductor)
    local cnd = conductor or self.conductor
    if cnd == nil then
        error("conductor signal not defined")
    end

    lil(string.format(
        "gestvmnode %s [gmemsym [grab %s] %s] %s",
        self.get(self), self.bufname, program, cnd))
end</pre></code>
<p><pre><code>function Gest:nodestring(program, conductor)
    local cnd = conductor or self.conductor
    if cnd == nil then
        error("conductor signal not defined")
    end

    local s = string.format(
        "gestvmnode %s [gmemsym [grab %s] %s] %s",
        self.get(self), self.bufname, program, cnd)

    return s
end</pre></code>
<p><pre><code>function Gest:node()
	local glive = self.get(self)
	local mem = self.bufname
	local glivef =  function(self) return glive end
	local cndstr = self.conductor

    return function(n, p)
        local name = p.name or "gst"
        local program =
            string.format("[gmemsym [grab %s] %s]", mem, name)

        -- TODO: glivef makes this work as a regular node
        -- glive works as only a parameter node. Tests
        -- will break if glivef is used
        -- The quick fix is to just introduce a flag
        local is_param_node = n.sigrune_dummy or false
        if is_param_node then
            n.glive = n:param(glive)
        else
            n.glive = n:param(glivef)
        end

        n.conductor = n:param(p.conductor or cndstr)
        n:lil({"gestvmnode", "zz", program, "zz"})
        n:label("gesture: " .. name)
    end
end</pre></code>
<p><pre><code>function Gest.gest16fun(sr, core)
    return function (gst, name, cnd, mn, mx)
        local pn = sr.paramnode
        local lvl = core.liln

        local node = pn(sr.scale) {
            input = pn(sr.mul) {
                a = pn(gst:node()) {
                    name = name,
                    conductor = lvl(cnd:getstr())
                },
                b = 1.0 / 16.0
            },
            min = mn,
            max = mx
        }

        return node
	end
end</pre></code>
<p><pre><code>Gest.behavior = {
    linear = 0,
    step = 1,
    gliss_medium = 2,
    gliss = 3,
    gate_125 = 4,
    gate_25 = 5,
    gate_50 = 6 
}</pre></code>
<p><pre><code>function Gest:gmemsymstr(symbol)
	local mem = self.bufname
    local program = 
        string.format("gmemsym [grab %s] %s", mem, symbol)
    return program
end</pre></code>
<p><pre><code>Gest.behavior = {
    linear = 0,
    step = 1,
    gliss_medium = 2,
    gliss = 3,
    gate_125 = 4,
    gate_25 = 5,
    gate_50 = 6 
}</pre></code>
<p><pre><code>function Gest:gmemsymstr(symbol)
	local mem = self.bufname
    local program = 
        string.format("gmemsym [grab %s] %s", mem, symbol)
    return program
end</pre></code>
<p><pre><code>Sig = {}
function lil_default(s)
    if (type(s) == "table") then
        s = table.concat(s, " ")
    end

    lil(s)
end

&lt;&lt;sig&gt;&gt;
return Sig</pre></code>
<p><pre><code>function Sig:zero()
    if self.reg &gt;= 0 then
        error("A signal is already being held")
    end
    lil("zero")
    self.hold(self)
end</pre></code>
<p><pre><code>function Sig:throw(gain)
    if self.reg &lt; 0 then
        error("no signal")
    end

    lil("dup")
    self.send(self, gain)
end</pre></code>
<p><pre><code>function Gest.gest16fun(sr, core)
    return function (gst, name, cnd, mn, mx)
        local pn = sr.paramnode
        local lvl = core.liln

        local node = pn(sr.scale) {
            input = pn(sr.mul) {
                a = pn(gst:node()) {
                    name = name,
                    conductor = lvl(cnd:getstr())
                },
                b = 1.0 / 16.0
            },
            min = mn,
            max = mx
        }

        return node
	end
end</pre></code>
<p><pre><code>function Gest:node()
	local glive = self.get(self)
	local mem = self.bufname
	local glivef =  function(self) return glive end
	local cndstr = self.conductor

    return function(n, p)
        local name = p.name or "gst"
        local program =
            string.format("[gmemsym [grab %s] %s]", mem, name)

        -- TODO: glivef makes this work as a regular node
        -- glive works as only a parameter node. Tests
        -- will break if glivef is used
        -- The quick fix is to just introduce a flag
        local is_param_node = n.sigrune_dummy or false
        if is_param_node then
            n.glive = n:param(glive)
        else
            n.glive = n:param(glivef)
        end

        n.conductor = n:param(p.conductor or cndstr)
        n:lil({"gestvmnode", "zz", program, "zz"})
        n:label("gesture: " .. name)
    end
end</pre></code>
<p><pre><code>function Sig:hold(lil_eval)
    -- can be a callback used to simulate holding
    lil_eval = lil_eval or lil_default
    if self.reg &gt;= 0 then
        error("can't hold, already holding")
    end

    -- regnxt actually has to be called to see if it is
    -- working

    local lstr = "param [regnxt 0]"
    -- if lil_eval ~= lil then
    --     lil_eval(lstr)
    -- end

    lil(lstr)


    local reg = pop()

    if reg &lt; 0 then
        error("invalid index")
    end

    -- hold/regset can be simulated without issue
    lil_eval({"hold", "zz"})
    -- lil_eval("hold zz # sig")
    lil_eval({"regset", "zz",reg})

    -- regmrk actually has to be called for it to work
    -- local lstr = string.format("regmrk %d", reg)
    local lstr = {"regmrk", reg}

    if lil_eval ~= lil then
        lil_eval(lstr)
    end

    lil(table.concat(lstr, " "))
    -- lil(string.format("regset zz %d; regmrk %d", reg, reg))

    self.reg = reg
end</pre></code>
<p><pre><code>local M = {}

&lt;&lt;morpheme&gt;&gt;
return M</pre></code>
<p><pre><code>morpheme({
    a={{60, 3, 3}, {67, 1, 3}, {58, 2, 3}},
    b={{63, 1, 3}, {65, 1, 3}, {63, 1, 3}, {62, 1, 3}}
}, {1, 3})</pre></code>
<p><pre><code>{
    a={
        {60, {2, 3}, 3},
        {67, {2, 1}}, 3},
        {58, {1, 1}, 3}
    },
    b={
        {63, {4,3}, 3},
        {65, {4,3}, 3},
        {63, {4,3}, 3},
        {62, {4,3}, 3}
    }
}</pre></code>
<p><pre><code>&lt;&lt;lcm&gt;&gt;
function M.morpheme(m, r)
    -- Get lengths of each gesture path
    local lengths = {}

    for k, v in pairs(m) do
        lengths[k] = 0
        for _,x in pairs(v) do
            lengths[k] = lengths[k] + x[2]
        end
    end

    -- Find LCM of path lengths

    length_lcm = 0

    for _, v in pairs(lengths) do
        if length_lcm ~= 0 then
            length_lcm = lcm(length_lcm, v)
        else
            length_lcm = v
        end

    end

    out = {}

    -- rescale paths

    for k, v in pairs(m) do
        local s = length_lcm / lengths[k]
        local row = {}
        for i=1,#v do
            row[i] = {v[i][1], v[i][2]*s, v[i][3]}
        end
        out[k] = row
    end

    -- convert to rate multiplier

    for k,v in pairs(out) do
        -- out[k][2] = {length_lcm, out[k][2]}
        for i=1,#v do
            -- apply scaling value r and obtain multipler

            local num = length_lcm * r[1]
            local den = v[i][2] * r[2]

            -- simplify multiplier fractions, if possible

            local div = gcd(num, den)
            if div == 0 then div = 1 end

            num = num / div
            den = den / div

            -- make sure multiplier values are in range

            if (num &gt; 255 or den &gt; 255) then
                error(string.format(
                    "%s[%d]: multiplier (%d, %d) out of range",
                    k, i, num, den))
            end
            v[i][2] = {num, den}
        end
    end


    return out
end

&lt;&lt;helpers&gt;&gt;
</pre></code>
<p><pre><code>function gcd(m, n)
    while n ~= 0 do
        local q = m
        m = n
        n = q % n
    end
    return m
end

function lcm(m, n)
    return (m ~= 0 and n ~= 0) and
        m * n / gcd(m, n) or 0
end</pre></code>
<p><pre><code>function append_op(path, m, mp)
    for pname, p in pairs(m) do
        if mp[pname] == nil then
            mp[pname] = {}
        end
        for k, v in pairs(p) do
            table.insert(mp[pname], path.vertex(v))
        end
    end
end

function M.append(path, mp, r, m)
    append_op(path, M.morpheme(m, r), mp)
end

function M.appender(path)
    return function(mp, r, m)
        M.append(path, mp, r, m)
    end
end</pre></code>
<p><pre><code>function M.compile(tal, path, words, mp, head)
    head = head or {}
    for label, p in pairs(mp) do
        tal.label(words, label)
        if head[label] ~= nil then
            head[label](words)
        end
        path.path(tal, words, p)
        tal.jump(words, label)
    end
end</pre></code>
<p><pre><code>function M.articulate(path, tal, words, seq, head)
    local mp = {}

    for _,s in pairs(seq) do
        M.append(path, mp, s[2], s[1])
    end


    M.compile(tal, path, words, mp, head)
end</pre></code>
<p><pre><code>x = {
    "a": path1,
    "b": path2,
    "c": path3,
}

xt = template(x)

y = x {
    "b": path4
}</pre></code>
<p><pre><code>function M.template(m)
    return function(p)
        local o = {}
        for k,v in pairs(m) do
            o[k] = p[k] or v
        end
        return o
    end
end</pre></code>
<p><pre><code>function M.subset(m, a)
    local o = {}

    for _,v in pairs(a) do
        if m[v] == nil then
            error("Attribute '" .. v .. "' doesn't exist.")
        end
        o[a] = m[a]
    end

    return o
end</pre></code>
<p><pre><code>function M.merge(A, B)
    local o = {}

    for k,v in pairs(A) do
        o[k] = v
    end

    for k,v in pairs(B) do
        o[k] = v
    end

    return o
end</pre></code>
<p><pre><code>function M.morpheme_to_data(path, morpheme)
    local morpheme_data = {}

    for k,v in pairs(morpheme) do
        morpheme_data[k] = path.path_to_data(v)
    end

    return morpheme_data
end

function M.save(asset, path, morpheme, filename)
    asset:save(M.morpheme_to_data(path, morpheme), filename)
end

function M.load(asset, path, filename)
    local morpheme_data = asset:load(filename)

    local morpheme = {}

    for k, v in pairs(morpheme_data) do
        morpheme[k] = path.data_to_path(v)
    end
    -- local gpath = {}
    -- for _,v in pairs(path_data) do
    --     table.insert(gpath, Path.vertex(v))
    -- end

    return morpheme
end</pre></code>
<p><pre><code>Sig = {}
function lil_default(s)
    if (type(s) == "table") then
        s = table.concat(s, " ")
    end

    lil(s)
end

&lt;&lt;sig&gt;&gt;
return Sig</pre></code>
<p><pre><code>function Sig:new(o)
    o = o or {}
    o.reg = -1
    setmetatable(o, self)
    self.__index = self
    return o
end</pre></code>
<p><pre><code>function Sig:hold(lil_eval)
    -- can be a callback used to simulate holding
    lil_eval = lil_eval or lil_default
    if self.reg &gt;= 0 then
        error("can't hold, already holding")
    end

    -- regnxt actually has to be called to see if it is
    -- working

    local lstr = "param [regnxt 0]"
    -- if lil_eval ~= lil then
    --     lil_eval(lstr)
    -- end

    lil(lstr)


    local reg = pop()

    if reg &lt; 0 then
        error("invalid index")
    end

    -- hold/regset can be simulated without issue
    lil_eval({"hold", "zz"})
    -- lil_eval("hold zz # sig")
    lil_eval({"regset", "zz",reg})

    -- regmrk actually has to be called for it to work
    -- local lstr = string.format("regmrk %d", reg)
    local lstr = {"regmrk", reg}

    if lil_eval ~= lil then
        lil_eval(lstr)
    end

    lil(table.concat(lstr, " "))
    -- lil(string.format("regset zz %d; regmrk %d", reg, reg))

    self.reg = reg
end</pre></code>
<p><pre><code>function Sig:unhold(lil_eval)
    lil_eval = lil_eval or lil_default
    if self.reg &lt; 0 then
        error("no signal to unhold")
    end

    -- lil_eval(string.format("unhold [regget %d]; regclr %d",
    --    self.reg, self.reg))
    lil_eval({"regget", self.reg})
    lil_eval({"unhold", "zz"})
    lil_eval({"regclr", self.reg})

    self.reg = -1
end</pre></code>
<p><pre><code>function Sig:get(eval)
    if self.reg &lt; 0 then
        error("no signal")
    end

    if eval == nil then
        eval = lil
    end

    -- eval(string.format("regget %d", self.reg))
    local s = {"regget", self.reg}

    if eval == lil and type(s) ~= "string" then
        s = table.concat(s, " ")
    end

    eval(s)
end</pre></code>
<p><pre><code>function Sig:getstr()
    if self.reg &lt; 0 then
        error("no signal")
    end

    --return string.format("[regget %d]", self.reg)
    return {"regget", self.reg}
end</pre></code>
<p><pre><code>function Sig:zero()
    if self.reg &gt;= 0 then
        error("A signal is already being held")
    end
    lil("zero")
    self.hold(self)
end</pre></code>
<p><pre><code>function Sig:send(gain)
    if self.reg &lt; 0 then
        error("no signal")
    end

    gain = gain or 0

    lil(string.format("mix zz [regget %d] [dblin %g]",
        self.reg, gain))
end</pre></code>
<p><pre><code>function Sig:throw(gain)
    if self.reg &lt; 0 then
        error("no signal")
    end

    lil("dup")
    self.send(self, gain)
end</pre></code>
<p><pre><code>function Graph:vert()
    self.nverts = self.nverts + 1
    return self.nverts
end</pre></code>
<p><pre><code>function Graph:connect(node, input_id)
    local input = self.nodes[input_id]

    self.edge(self, node.data.id, input_id, 1)

    -- this input doesn't actually compute anything anymore
    input:disable()

    -- a linking node symlinks the node to be the input
    input.data.link = node.data.id
end</pre></code>
<p><pre><code>function Graph:compute(lst)
    if type(self.init) == "function" then
        self.init(self)
    end

    for _, i in pairs(lst) do
        local n = self.nodes[i]
        n:compute()
    end

    -- User-defined cleanup after computation
    if type(self.cleanup) == "function" then
        self.cleanup(self)
    end
end</pre></code>
<p><pre><code>function Node:constant(val)
    self.data.val = val
    self.data.constant = true
end

function Node:isconstant()
    return self.data.constant
end</pre></code>
<p><pre><code>function Path.data_to_path(path_data)
    local gpath = {}
    for _,v in pairs(path_data) do
        table.insert(gpath, Path.vertex(v))
    end
    return gpath
end

function Path.path_to_data(path)
    local path_data = {}
    for _,v in pairs(path) do
        table.insert(path_data, {
            v.val,
            v.dur,
            v.bhvr,
        })
    end

    return path_data
end</pre></code>
<p><pre><code>function M.merge(A, B)
    local o = {}

    for k,v in pairs(A) do
        o[k] = v
    end

    for k,v in pairs(B) do
        o[k] = v
    end

    return o
end</pre></code>
<p><pre><code>gates = {
    o = 1,
    c = 0,
}

function S.gatefun(morpho, str)
    return function (str)
        return morpho.eval(str, gates)
    end
end</pre></code>
<p><pre><code>function Gest:create()
    lil("glnew " .. self.name)
    self.tal.membuf(self.bufname)
end</pre></code>
<p><pre><code>function Gest:compile(words)
    self.tal.compile_words(words,
        self.bufname,
        string.format("[glget [grab %s]]", self.name))
end</pre></code>
<p><pre><code>function Gest:compile_tal(program)
    self.tal.compile(program,
        self.bufname,
        string.format("[glget [grab %s]]", self.name))
end</pre></code>
<p><pre><code>function Gest:swapper()
    lil(string.format("glswapper [grab %s]", self.name))
end</pre></code>
<p><pre><code>function Gest:done()
    lil(string.format("gldone [grab %s]", self.name))
end</pre></code>
<p><pre><code>function Gest:get()
    return string.format("[glget [grab %s]]", self.name)
end</pre></code>
<p><pre><code>Diagraf = {}

&lt;&lt;diagraf&gt;&gt;
return Diagraf</pre></code>
<p><pre><code>function Graph:vert()
    self.nverts = self.nverts + 1
    return self.nverts
end</pre></code>
<p><pre><code>Whistle = {}

&lt;&lt;oscillator&gt;&gt;
return Whistle</pre></code>
<p><pre><code>function Graph:dot(outfile)
    local printer = print
    local fp = nil

    if outfile ~= nil then
        fp = io.open(outfile, "w")
        printer = function(str)
            fp:write(str .. "\n")
        end
    end

    printer("digraph G {")
    printer("rankdir=LR")
    printer("layout=dot")

    for _,n in pairs(self.nodes) do
        if 
            n:disabled() == false and
            n.data.typestr ~= "releaser" and
            n.data.typestr ~= "getter" and
            n.data.typestr ~= "setter"
        then
            if n:isconstant() then
                printer(string.format("%d [label=%s]",
                    n.data.id, n.data.val))
            else
                if n.data.label ~= nil then
                    printer(string.format("%d [label=\"%s (%d)\"]",
                        n.data.id, n.data.label, n.data.id))
                else
                    printer(string.format("%d [label=\"N%d\"]",
                        n.data.id, n.data.id))
                end
            end
        end
    end
    for _, e in pairs(self.edges) do
        if e[3] == 1 then
            local n2 = self.nodes[e[2]]
            local n1 = self.nodes[e[1]]
            local loud = true

            if
                n1.data.typestr == "setter" or
                n2.data.typestr == "setter"
            then
                loud = false
            end

            local incoming = e[1]
            local outgoing = e[2]

            if n2:disabled() then
                outgoing = n2.data.parent

                n2 = self.nodes[outgoing]

                if n2.data.typestr == "setter" then
                    loud = false
                end
            end

            if n1.data.typestr == "getter" then
                incoming = n1.data.getter_parent
            end

            if n1:disabled() == false and loud == true then
                printer(string.format("%d -&gt; %d", incoming, outgoing))
            end
        end
    end
    printer("}")
    if outfile ~= nil then
        fp:close()
    end
end</pre></code>
<p><pre><code>function Path.AST_to_data(t)
    behaviors = {
        linear = 0,
        step = 1,
        gliss_medium = 2,
        gliss_large = 3,
        gliss_small = 4,
    }

    local ratemul = {1, 1}
    local behavior = behaviors["linear"]
    local gpath = {}

    for _,v in pairs(t) do
        local val = tonumber("0x" .. v.value[1] .. v.value[2])
        if v.behavior ~= nil then
            behavior = behaviors[v.behavior]
        end

        if v.ratemul ~= nil then
            if #v.ratemul == 2 then
                local num, den
                num = v.ratemul[1]
                num = tonumber("0x" .. num[1] .. num[2])
                den = v.ratemul[2]
                den = tonumber("0x" .. den[1] .. den[2])
                ratemul = {num, den}
            elseif #v.ratemul == 1 then
                local num, den
                num = v.ratemul[1]
                num = tonumber("0x" .. num[1] .. num[2])
                ratemul = num
            end
        end
        local vertex = {
            val,
            ratemul,
            behavior
        }
        table.insert(gpath, vertex)
    end
    return gpath
end</pre></code>
<p><pre><code>local Path = {}

&lt;&lt;path&gt;&gt;
return Path</pre></code>
<p><pre><code>function Path.vertex(v)
    x = {}

    x.val = v[1]
    x.dur = v[2]
    x.bhvr = v[3]

    return x
end</pre></code>
<p><pre><code>function Path.path(tal, words, path, lookup)
    for _, v in pairs(path)
    do
        if v.val ~= nil then
            local pathval = v.val

            if lookup ~= nil and type(pathval) == "string" then
                pathval = lookup[pathval]
            end

            tal.val(words, pathval)
        end

        if v.dur ~= nil then
            tal.dur(words, v.dur[1], v.dur[2])
        end

        if v.bhvr ~= nil then
            tal.behavior(words, v.bhvr)
        end
    end
end
</pre></code>
<p><pre><code>function Path.save(asset, gpath, filename)
    asset:save(gpath, filename)
end

function Path.load(asset, filename)
    local path_data = asset:load(filename)

    return Path.data_to_path(path_data)
end</pre></code>
<p><pre><code>function Path.data_to_path(path_data)
    local gpath = {}
    for _,v in pairs(path_data) do
        table.insert(gpath, Path.vertex(v))
    end
    return gpath
end

function Path.path_to_data(path)
    local path_data = {}
    for _,v in pairs(path) do
        table.insert(path_data, {
            v.val,
            v.dur,
            v.bhvr,
        })
    end

    return path_data
end</pre></code>
<p><pre><code>function Path.AST_to_data(t)
    behaviors = {
        linear = 0,
        step = 1,
        gliss_medium = 2,
        gliss_large = 3,
        gliss_small = 4,
    }

    local ratemul = {1, 1}
    local behavior = behaviors["linear"]
    local gpath = {}

    for _,v in pairs(t) do
        local val = tonumber("0x" .. v.value[1] .. v.value[2])
        if v.behavior ~= nil then
            behavior = behaviors[v.behavior]
        end

        if v.ratemul ~= nil then
            if #v.ratemul == 2 then
                local num, den
                num = v.ratemul[1]
                num = tonumber("0x" .. num[1] .. num[2])
                den = v.ratemul[2]
                den = tonumber("0x" .. den[1] .. den[2])
                ratemul = {num, den}
            elseif #v.ratemul == 1 then
                local num, den
                num = v.ratemul[1]
                num = tonumber("0x" .. num[1] .. num[2])
                ratemul = num
            end
        end
        local vertex = {
            val,
            ratemul,
            behavior
        }
        table.insert(gpath, vertex)
    end
    return gpath
end</pre></code>
<p><pre><code>&lt;&lt;scale_to_morphseq_bits&gt;&gt;
function Path.scale_to_morphseq(gpath, mseq)
    local seqdur = morphseq_dur(mseq)
    local pnorm = path_normalizer(gpath)
    local total_ratemul = fracmul(pnorm, seqdur)
    local gpath_rescaled =
        apply_ratemul(gpath, total_ratemul, Path.vertex)

    return gpath_rescaled
end</pre></code>
<p><pre><code>local function gcd(m, n)
    while n ~= 0 do
        local q = m
        m = n
        n = q % n
    end
    return m
end

local function lcm(m, n)
    return (m ~= 0 and n ~= 0) and
        m * n / gcd(m, n) or 0
end

local function fracadd(a, b)
    if a[2] == 0 then return b end
    if b[2] == 0 then return a end
    local s = lcm(a[2], b[2])
    local as = s / a[2]
    local bs = s / b[2]
    return {as*a[1] + bs*b[1], s}
end

local function reduce(a)
    out = a
    local s = gcd(out[1], out[2])

    if (s ~= 0) then
        out[1] = out[1] / s
        out[2] = out[2] / s
    end

    return out
end

function fracmul(a, b)
    local out = {a[1]*b[1], a[2]*b[2]}

    return reduce(out)
end

local function morphseq_dur(mseq)
    local total = {0, 0}
    for _, m in pairs(mseq) do
        local r = m[2]
        total = fracadd(total, r)
    end
    -- r is a ratemultiplier against a normalize
    -- path with dur 1. 2/1 is 2x faster, or dur 1/2.
    -- inverse to get duration
    -- this can be multiplied with normalized path
    -- to stretch/squash it out
    return {total[2], total[1]}
end

local function path_normalizer(p)
    local total = 0

    for _, v in pairs(p) do
        total = total + v[2]
    end

    return {total, 1}
end

local function apply_ratemul(p, r, vertexer)
    path_with_ratemul = {}

    for _,v in pairs(p) do
        local v_rm = {
            v[1],
            reduce({r[1], v[2]*r[2]}),
            v[3]
        }
        table.insert(path_with_ratemul, vertexer(v_rm))
    end

    return path_with_ratemul
end</pre></code>
<p><pre><code>function tal.halt(words)
    table.insert(words, "BRK")
end</pre></code>
<p><pre><code>function M.morpheme_to_data(path, morpheme)
    local morpheme_data = {}

    for k,v in pairs(morpheme) do
        morpheme_data[k] = path.path_to_data(v)
    end

    return morpheme_data
end

function M.save(asset, path, morpheme, filename)
    asset:save(M.morpheme_to_data(path, morpheme), filename)
end

function M.load(asset, path, filename)
    local morpheme_data = asset:load(filename)

    local morpheme = {}

    for k, v in pairs(morpheme_data) do
        morpheme[k] = path.data_to_path(v)
    end
    -- local gpath = {}
    -- for _,v in pairs(path_data) do
    --     table.insert(gpath, Path.vertex(v))
    -- end

    return morpheme
end</pre></code>
<p><pre><code>function Gest:nodestring(program, conductor)
    local cnd = conductor or self.conductor
    if cnd == nil then
        error("conductor signal not defined")
    end

    local s = string.format(
        "gestvmnode %s [gmemsym [grab %s] %s] %s",
        self.get(self), self.bufname, program, cnd)

    return s
end</pre></code>
<p><pre><code>step16 = {
    a = 0,
    b = 1,
    c = 2,
    d = 3,
    e = 4,
    f = 5,
    g = 6,
    h = 7,
    h = 8,
    i = 9,
    j = 10,
    k = 11,
    l = 12,
    m = 13,
    n = 14,
    o = 15,
    p = 16,
}

function S.seqfun(morpho, str)
    return function (str)
        return morpho.eval(str, step16)
    end
end</pre></code>
<p><pre><code>function Graph:compute(lst)
    if type(self.init) == "function" then
        self.init(self)
    end

    for _, i in pairs(lst) do
        local n = self.nodes[i]
        n:compute()
    end

    -- User-defined cleanup after computation
    if type(self.cleanup) == "function" then
        self.cleanup(self)
    end
end</pre></code>
<p><pre><code>S = {}

&lt;&lt;functions&gt;&gt;

return S</pre></code>
<p><pre><code>x = {
    "a": path1,
    "b": path2,
    "c": path3,
}

xt = template(x)

y = x {
    "b": path4
}</pre></code>
<p><pre><code>function Sig:throw(gain)
    if self.reg &lt; 0 then
        error("no signal")
    end

    lil("dup")
    self.send(self, gain)
end</pre></code>
<p><pre><code>function tal.interpolate(words, state)
    tal.num(words, state)
    tal.num(words, 0x2a)
    table.insert(words, "DEO")
end</pre></code>
<p><pre><code>&lt;&lt;procedures&gt;&gt;

patch =

&lt;&lt;sndkit_patch&gt;&gt;

program_words = {}


&lt;&lt;generate_macros&gt;&gt;

-- I forget what this is called
table.insert(program_words, "|0100")

mklabel(program_words, "mel")


&lt;&lt;vertex_shorthand_for_gesture_path&gt;&gt;

path =

&lt;&lt;gesture_path_as_lua_structure&gt;&gt;

mkpath(program_words, path)
mkjump(program_words, "mel")

program_tal = table.concat(program_words, " ")
compile_tal(program_tal)
lil(patch)</pre></code>
<p><pre><code>mkmacro(program_words, "NUM", {"#24", "DEO"})
mkmacro(program_words, "DEN", {"#25", "DEO"})
mkmacro(program_words, "NEXT", {"#26", "DEO"})
mkmacro(program_words, "NOTE", {"#33", "ADD", "NEXT"})
mkmacro(program_words, "BHVR", {"#27", "DEO"})</pre></code>
<p><pre><code>function mkmacro(words, name, program)
    table.insert(words, "%" .. name)
    table.insert(words, "{")
    for _,v in pairs(program)
    do
        table.insert(words, v)
    end
    table.insert(words, "}")
end

function mklabel(words, label)
    table.insert(words, "@" .. label)
end

function mknum(words, val)
    table.insert(words, "#" .. string.format("%02x", val))
end

function mknote(words, note)
    table.insert(words, "#" .. string.format("%02x", note))
    table.insert(words, "NOTE")
    table.insert(words, "BRK")
end

function mkdur(words, num, den)
    mknum(words, num)
    table.insert(words, "NUM")
    mknum(words, den)
    table.insert(words, "DEN")
end

function mkbehavior(words, id)
    mknum(words, id)
    table.insert(words, "BHVR")
end

function mkjump(words, label)
    table.insert(words, ";" .. label)
    table.insert(words, "JMP2")
end

function compile_tal(tal)
    lil([[
    gmemnew mem
    gestvmnew gvm
    ]])

    gestvm_compile("mem", program_tal)
    lil("gmemcpy [grab mem] [grab gvm]")
end</pre></code>
<p><pre><code>function mkpath(words, path)
    for _, v in pairs(path)
    do
        if v.note ~= nil then
            mknote(program_words, v.note)
        end

        if v.dur ~= nil then
            mkdur(program_words, v.dur[1], v.dur[2])
        end

        if v.bhvr ~= nil then
            mkbehavior(program_words, v.bhvr)
        end
    end
end</pre></code>
<p><pre><code>{
    v(7, {2,1}, 2),
    v(5),
    v(7),
    v(0, {2,5}),

    v(7, {2,1}, 2),
    v(10),
    v(9),
    v(5, {2,3}),

    v(3, {1, 1}, 3)
}</pre></code>
<p><pre><code>v = function (note, dur, behavior)
    x = {}

    x.note = note
    x.dur = dur
    x.bhvr = behavior

    return x
end</pre></code>
<p><pre><code>[[
phasor [expr 96 / 60] 0

hold zz
regset zz 0

gestvmnode [grab gvm] [gmemsym [grab mem] mel] [regget 0]

mtof zz
blsaw zz
mul zz 0.5

butlp zz 800

dup
dup
verbity zz zz 0.1 0.1 0.1
drop
mul zz [dblin -15]
dcblocker zz
add zz zz

unhold [regget 0]

wavouts zz simple_path.wav

computes 10
]]</pre></code>
<p><pre><code>function Warble.graph(params)
    local core = params.core or core
    local sr = params.sr or sigrunes
    local diagraf = params.diagraf or diagraf
    local sig = params.sig or sig

    local nd = sr.node
    local ln = core.liln
    local lf = core.lilf
    local plf = core.plilf

    local g = diagraf.Graph:new{sig=sig}

    g.init = function(grf)
        grf.eval({"gensine", "[tabnew 8192]"})
        -- grf.eval("param [regnxt 0]")
        lil("param [regnxt 0]")
        local tab = pop()
        -- grf.eval(string.format("regset zz %d; regmrk %d", tab, tab))
        grf.eval({"regset", "zz", tab})
        grf.eval({"regmrk", tab})
        grf.data = {}
        grf.data.tab = tab
    end

    local sintab = function(node, eval)
        local grf = node.data.g
        eval = eval or grf.eval
        local tab = grf.data.tab
        --eval(string.format("regget %d # sintab", tab))
        eval({"regget" , tab, "#sintab"})
    end

    ng = core.nodegen(diagraf.Node, g)
    pg = core.paramgen(ng)
    con = g:connector()
    prmf = core.paramf
    local p = params

    local pitch = pg(p.pitch or prmf(60), "pitch")
    local mi = pg(p.mi or prmf(1), "mod index")
    local car = pg(p.car or prmf(1), "car")
    local mod = pg(p.mod or prmf(1), "mod")
    local fdbk = pg(p.fdbk or prmf(0), "feedback")

    local pasp = p.asp or {}
    local asp = pg(pasp.val or prmf(0), "aspiration")
    local asp_gt = pg(pasp.gate or prmf(0), "aspiration gate")
    local asp_atk = pg(pasp.atk or prmf(0.1), "aspiration attack")
    local asp_rel = pg(pasp.rel or prmf(0.1), "aspiration release")
    local asp_dur = pg(pasp.dur or prmf(0.1), "aspiration env duration")
    local asp_gain = pg(pasp.gain or prmf(1.0), "aspiration gain")
    local asp_bw = pg(pasp.bw or prmf(100), "aspiration bandwidth")
    local asp_freq = pg(pasp.freq or prmf(500), "aspiration center frequency")

    local pamp = p.amp or {}
    local amp = pg(pamp.val or prmf(1), "amp")
    local a_gt = pg(pamp.gate or prmf(0), "amp gate")
    local a_atk = pg(pamp.atk or prmf(0.1), "amp attack")
    local a_rel = pg(pamp.rel or prmf(0.1), "amp release")
    local a_dur = pg(pamp.dur or prmf(0.1), "amp env duration")

    local pvib = p.vib or {}
    local vib_rate = pg(pvib.rate or prmf(6), "vibrato rate")
    local vib_depth = pg(pvib.depth or prmf(0.2), "vibrato depth")

    local fm = ng(sr.fmpair) {tab = sintab}

    con(mi, fm.mi)
    con(car, fm.car)
    con(mod, fm.mod)
    con(fdbk, fm.fdbk)

    local scaler = ng(sr.scale)

    local mul = ng(sr.mul)
    local add = ng(sr.add)
    local nz = ng(sr.noise)()

    local bpf = ng(sr.butbp)()

    con(asp_bw, bpf.bw)
    con(asp_freq, bpf.freq)

    local lpf = ng(sr.butlp) {
        freq = 1000,
    }

    con(nz, lpf.input)
    con(lpf, bpf.input)
    bpf_gain = mul()
    con(asp_gain, bpf_gain.b)
    con(bpf, bpf_gain.a)

    local envar = ng(sr.envar)

    local cf = ng(sr.crossfade) {}

    local cfenv = envar {}

    local sclcf = scaler {max = 1.0}

    con(asp_rel, cfenv.rel)
    con(asp_atk, cfenv.atk)

    tgate = ng(sr.tgate)
    gtick = ng(sr.gtick)

    cfenv_gtick = gtick()
    cfenv_tgate = tgate()

    con(asp_gt, cfenv_gtick.gate)
    con(cfenv_gtick, cfenv_tgate.trig)
    con(asp_dur, cfenv_tgate.dur)

    con(cfenv_tgate, cfenv.gate)
    con(asp, sclcf.min)
    con(cfenv, sclcf.input)
    con(sclcf, cf.pos)

    con(fm, cf.a)
    con(bpf_gain, cf.b)

    local generator = cf

    lfo = ng(sr.osc) {
        tab = sintab
    }

    con(vib_rate, lfo.freq)
    con(vib_depth, lfo.amp)

    vib = add()
    mtof = ng(sr.mtof)
    fm_freq = mtof()
    con(pitch, vib.a)
    con(lfo, vib.b)
    con(vib, fm_freq.input)
    con(fm_freq, fm.freq)

    sclamp = scaler {
        max = 1.0
    }

    con(amp, sclamp.min)

    ampenv = envar {}

    con(a_atk, ampenv.atk)
    con(a_rel, ampenv.rel)

    ampenv_gtick = gtick()
    ampenv_tgate = tgate()
    con(a_gt, ampenv_gtick.gate)
    con(ampenv_gtick, ampenv_tgate.trig)
    con(a_dur, ampenv_tgate.dur)

    con(ampenv_tgate, ampenv.gate)
    con(ampenv, sclamp.input)

    local ascl_mul = mul()
    con(generator, ascl_mul.a)
    con(sclamp, ascl_mul.b)

    g.cleanup = function(grf)
        local tab = grf.data.tab
        grf.eval({"regclr", tab})
    end
    return g
end</pre></code>
<p><pre><code>local tal = {}

&lt;&lt;cmds&gt;&gt;
return tal</pre></code>
<p><pre><code>function tal.macro(words, name, program)
    table.insert(words, "%" .. name)
    table.insert(words, "{")
    for _,v in pairs(program)
    do
        table.insert(words, v)
    end
    table.insert(words, "}")
end</pre></code>
<p><pre><code>function tal.label(words, label)
    table.insert(words, "@" .. label)
end</pre></code>
<p><pre><code>function tal.num(words, val)
    table.insert(words, "#" .. string.format("%02x", val))
end</pre></code>
<p><pre><code>function tal.val(words, val)
    tal.num(words, val)
    tal.num(words, 0x26)
    table.insert(words, "DEO")
    table.insert(words, "BRK")
end</pre></code>
<p><pre><code>function tal.halt(words)
    table.insert(words, "BRK")
end</pre></code>
<p><pre><code>function tal.dur(words, num, den)
    tal.num(words, num)
    tal.num(words, 0x24)
    table.insert(words, "DEO")
    tal.num(words, den)
    tal.num(words, 0x25)
    table.insert(words, "DEO")
end</pre></code>
<p><pre><code>function tal.behavior(words, id)
    tal.num(words, id)
    tal.num(words, 0x27)
    table.insert(words, "DEO")
end</pre></code>
<p><pre><code>function tal.jump(words, label)
    table.insert(words, ";" .. label)
    table.insert(words, "JMP2")
end</pre></code>
<p><pre><code>function tal.membuf(bufname)
    lil(string.format("gmemnew %s", bufname))
end</pre></code>
<p><pre><code>function tal.start(words)
    table.insert(words, "|0100")
end

-- I keep wanting to call it begin, not start
function tal.begin(words)
    tal.start(words)
end</pre></code>
<p><pre><code>function tal.compile_words(words, bufname, gvm)
    local program = table.concat(words, " ")
    tal.compile(program, bufname, gvm)
end</pre></code>
<p><pre><code>function tal.compile(program, bufname, gvm)
    gestvm_compile(bufname, program)
    lil("gmemcpy [grab " .. 
        bufname .. 
        "] " .. 
        gvm)
end</pre></code>
<p><pre><code>function tal.interpolate(words, state)
    tal.num(words, state)
    tal.num(words, 0x2a)
    table.insert(words, "DEO")
end</pre></code>
<p><pre><code>function Path.AST_to_data(t)
    behaviors = {
        linear = 0,
        step = 1,
        gliss_medium = 2,
        gliss_large = 3,
        gliss_small = 4,
    }

    local ratemul = {1, 1}
    local behavior = behaviors["linear"]
    local gpath = {}

    for _,v in pairs(t) do
        local val = tonumber("0x" .. v.value[1] .. v.value[2])
        if v.behavior ~= nil then
            behavior = behaviors[v.behavior]
        end

        if v.ratemul ~= nil then
            if #v.ratemul == 2 then
                local num, den
                num = v.ratemul[1]
                num = tonumber("0x" .. num[1] .. num[2])
                den = v.ratemul[2]
                den = tonumber("0x" .. den[1] .. den[2])
                ratemul = {num, den}
            elseif #v.ratemul == 1 then
                local num, den
                num = v.ratemul[1]
                num = tonumber("0x" .. num[1] .. num[2])
                ratemul = num
            end
        end
        local vertex = {
            val,
            ratemul,
            behavior
        }
        table.insert(gpath, vertex)
    end
    return gpath
end</pre></code>
<p><pre><code>&lt;&lt;lcm&gt;&gt;
function M.morpheme(m, r)
    -- Get lengths of each gesture path
    local lengths = {}

    for k, v in pairs(m) do
        lengths[k] = 0
        for _,x in pairs(v) do
            lengths[k] = lengths[k] + x[2]
        end
    end

    -- Find LCM of path lengths

    length_lcm = 0

    for _, v in pairs(lengths) do
        if length_lcm ~= 0 then
            length_lcm = lcm(length_lcm, v)
        else
            length_lcm = v
        end

    end

    out = {}

    -- rescale paths

    for k, v in pairs(m) do
        local s = length_lcm / lengths[k]
        local row = {}
        for i=1,#v do
            row[i] = {v[i][1], v[i][2]*s, v[i][3]}
        end
        out[k] = row
    end

    -- convert to rate multiplier

    for k,v in pairs(out) do
        -- out[k][2] = {length_lcm, out[k][2]}
        for i=1,#v do
            -- apply scaling value r and obtain multipler

            local num = length_lcm * r[1]
            local den = v[i][2] * r[2]

            -- simplify multiplier fractions, if possible

            local div = gcd(num, den)
            if div == 0 then div = 1 end

            num = num / div
            den = den / div

            -- make sure multiplier values are in range

            if (num &gt; 255 or den &gt; 255) then
                error(string.format(
                    "%s[%d]: multiplier (%d, %d) out of range",
                    k, i, num, den))
            end
            v[i][2] = {num, den}
        end
    end


    return out
end

&lt;&lt;helpers&gt;&gt;
</pre></code>
<p><pre><code>function M.morpheme_to_data(path, morpheme)
    local morpheme_data = {}

    for k,v in pairs(morpheme) do
        morpheme_data[k] = path.path_to_data(v)
    end

    return morpheme_data
end

function M.save(asset, path, morpheme, filename)
    asset:save(M.morpheme_to_data(path, morpheme), filename)
end

function M.load(asset, path, filename)
    local morpheme_data = asset:load(filename)

    local morpheme = {}

    for k, v in pairs(morpheme_data) do
        morpheme[k] = path.data_to_path(v)
    end
    -- local gpath = {}
    -- for _,v in pairs(path_data) do
    --     table.insert(gpath, Path.vertex(v))
    -- end

    return morpheme
end</pre></code>
<p><pre><code>function Graph:nsort_rec(l, n, i, lvl)
    lvl = lvl or 0
    if i &lt;= 0 then
        return i
    end
    -- print(string.format("l[%d]: expecting: node(%d)", i, n.data.id))
    if n.data.id ~= l[i] then
        -- print(string.format("l[%d] (%d) is not %d", i, l[i], n.data.id))
        for k = i, 1, -1 do
            local m = l[k]
            if m == n.data.id then
                local nk = self.nodes[l[k]]
                local ni = self.nodes[l[i]]
                local lk = nk.data.label or ""
                local li = ni.data.label or ""

                -- print(string.format(
                --     "swapping l[%d] %d (%s) and l[%d] %d (%s)\n",
                --         k, nk.data.id, lk, i, ni.data.id, li))
                local t = l[k]
                l[k] = l[i]
                l[i] = t
                break
            end
        end
    end

    i = i - 1

    if n.data.link ~= nil then
        i = self.nsort_rec(self,
            l, self.nodes[n.data.link], i, lvl + 1)
        return i
    end

    -- process params list in reverse, because sndkit
    -- uses LIFO stack and pops parameters in reverse
    -- syntactically, this makes stack syntax look like
    -- parameters are in "correct" order
    for p=#n.data.params, 1, -1 do
        i = self.nsort_rec(self, l, n.data.params[p], i, lvl + 1)
    end

    return i
end</pre></code>
<p><pre><code>Gest.behavior = {
    linear = 0,
    step = 1,
    gliss_medium = 2,
    gliss = 3,
    gate_125 = 4,
    gate_25 = 5,
    gate_50 = 6 
}</pre></code>
<p><pre><code>function Gest:gmemsymstr(symbol)
	local mem = self.bufname
    local program = 
        string.format("gmemsym [grab %s] %s", mem, symbol)
    return program
end</pre></code>
<p><pre><code>function Sig:get(eval)
    if self.reg &lt; 0 then
        error("no signal")
    end

    if eval == nil then
        eval = lil
    end

    -- eval(string.format("regget %d", self.reg))
    local s = {"regget", self.reg}

    if eval == lil and type(s) ~= "string" then
        s = table.concat(s, " ")
    end

    eval(s)
end</pre></code>
<p><pre><code>function Sig:getstr()
    if self.reg &lt; 0 then
        error("no signal")
    end

    --return string.format("[regget %d]", self.reg)
    return {"regget", self.reg}
end</pre></code>
<p><pre><code>function Sig:zero()
    if self.reg &gt;= 0 then
        error("A signal is already being held")
    end
    lil("zero")
    self.hold(self)
end</pre></code>
<p><pre><code>morpheme({
    a={{60, 3, 3}, {67, 1, 3}, {58, 2, 3}},
    b={{63, 1, 3}, {65, 1, 3}, {63, 1, 3}, {62, 1, 3}}
}, {1, 3})</pre></code>
<p><pre><code>{
    a={
        {60, {2, 3}, 3},
        {67, {2, 1}}, 3},
        {58, {1, 1}, 3}
    },
    b={
        {63, {4,3}, 3},
        {65, {4,3}, 3},
        {63, {4,3}, 3},
        {62, {4,3}, 3}
    }
}</pre></code>
<p><pre><code>function append_op(path, m, mp)
    for pname, p in pairs(m) do
        if mp[pname] == nil then
            mp[pname] = {}
        end
        for k, v in pairs(p) do
            table.insert(mp[pname], path.vertex(v))
        end
    end
end

function M.append(path, mp, r, m)
    append_op(path, M.morpheme(m, r), mp)
end

function M.appender(path)
    return function(mp, r, m)
        M.append(path, mp, r, m)
    end
end</pre></code>
<p><pre><code>Gest = {}

&lt;&lt;behavior_constants&gt;&gt;
&lt;&lt;gest&gt;&gt;
return Gest</pre></code>
<p><pre><code>function Gest:new(o)
    o = o or {}
    o.name = o.name or "glive"
    o.bufname = o.bufname or "mem"
    o.tal = o.tal or tal
    assert(o.tal ~= nil, "tal not found")
    setmetatable(o, self)
    self.__index = self
    return o
end</pre></code>
<p><pre><code>function Sig:unhold(lil_eval)
    lil_eval = lil_eval or lil_default
    if self.reg &lt; 0 then
        error("no signal to unhold")
    end

    -- lil_eval(string.format("unhold [regget %d]; regclr %d",
    --    self.reg, self.reg))
    lil_eval({"regget", self.reg})
    lil_eval({"unhold", "zz"})
    lil_eval({"regclr", self.reg})

    self.reg = -1
end</pre></code>
<p><pre><code>function Sig:get(eval)
    if self.reg &lt; 0 then
        error("no signal")
    end

    if eval == nil then
        eval = lil
    end

    -- eval(string.format("regget %d", self.reg))
    local s = {"regget", self.reg}

    if eval == lil and type(s) ~= "string" then
        s = table.concat(s, " ")
    end

    eval(s)
end</pre></code>
<p><pre><code>function Sig:new(o)
    o = o or {}
    o.reg = -1
    setmetatable(o, self)
    self.__index = self
    return o
end</pre></code>
<p><pre><code>function S.parse_tree(tree)
    local btab = {
        linear = 0,
        step = 1,
        gliss_medium = 2,
        gliss_big = 3,
        gliss_small = 4,
    }

    local behavior = btab["linear"]
    local dur = 1

    local gpath = {}

    for _,leaf in pairs(tree) do
        local v = {}

        if leaf.value == nil then
            error("leaf value is nil")
        end

        if leaf.behavior ~= nil then
            behavior = btab[leaf.behavior]
        end

        if leaf.dur ~= nil then
            local r = 0
            for _, digit in pairs(leaf.dur) do
                r = r * 8 + tonumber(digit)
            end
            dur = r
        end

        v[1] = tonumber(leaf.value)
        v[2] = dur
        v[3] = behavior
        table.insert(gpath, v)
    end

    return gpath
end</pre></code>
<p><pre><code>&lt;&lt;scale_to_morphseq_bits&gt;&gt;
function Path.scale_to_morphseq(gpath, mseq)
    local seqdur = morphseq_dur(mseq)
    local pnorm = path_normalizer(gpath)
    local total_ratemul = fracmul(pnorm, seqdur)
    local gpath_rescaled =
        apply_ratemul(gpath, total_ratemul, Path.vertex)

    return gpath_rescaled
end</pre></code>
<p><pre><code>function M.compile(tal, path, words, mp, head)
    head = head or {}
    for label, p in pairs(mp) do
        tal.label(words, label)
        if head[label] ~= nil then
            head[label](words)
        end
        path.path(tal, words, p)
        tal.jump(words, label)
    end
end</pre></code>
<p><pre><code>function Gest:node_old(program, conductor)
    local cnd = conductor or self.conductor
    if cnd == nil then
        error("conductor signal not defined")
    end

    lil(string.format(
        "gestvmnode %s [gmemsym [grab %s] %s] %s",
        self.get(self), self.bufname, program, cnd))
end</pre></code>
<p><pre><code>function Graph:connect(node, input_id)
    local input = self.nodes[input_id]

    self.edge(self, node.data.id, input_id, 1)

    -- this input doesn't actually compute anything anymore
    input:disable()

    -- a linking node symlinks the node to be the input
    input.data.link = node.data.id
end</pre></code>
<p><pre><code>function Gest.gest16fun(sr, core)
    return function (gst, name, cnd, mn, mx)
        local pn = sr.paramnode
        local lvl = core.liln

        local node = pn(sr.scale) {
            input = pn(sr.mul) {
                a = pn(gst:node()) {
                    name = name,
                    conductor = lvl(cnd:getstr())
                },
                b = 1.0 / 16.0
            },
            min = mn,
            max = mx
        }

        return node
	end
end</pre></code>
<p><pre><code>Gest = {}

&lt;&lt;behavior_constants&gt;&gt;
&lt;&lt;gest&gt;&gt;
return Gest</pre></code>
<p><pre><code>function Gest:new(o)
    o = o or {}
    o.name = o.name or "glive"
    o.bufname = o.bufname or "mem"
    o.tal = o.tal or tal
    assert(o.tal ~= nil, "tal not found")
    setmetatable(o, self)
    self.__index = self
    return o
end</pre></code>
<p><pre><code>&lt;&lt;procedures&gt;&gt;

patch =

&lt;&lt;sndkit_patch&gt;&gt;

program_words = {}


&lt;&lt;generate_macros&gt;&gt;

-- I forget what this is called
table.insert(program_words, "|0100")

mklabel(program_words, "mel")


&lt;&lt;vertex_shorthand_for_gesture_path&gt;&gt;

path =

&lt;&lt;gesture_path_as_lua_structure&gt;&gt;

mkpath(program_words, path)
mkjump(program_words, "mel")

program_tal = table.concat(program_words, " ")
compile_tal(program_tal)
lil(patch)</pre></code>
<p><pre><code>function mkpath(words, path)
    for _, v in pairs(path)
    do
        if v.note ~= nil then
            mknote(program_words, v.note)
        end

        if v.dur ~= nil then
            mkdur(program_words, v.dur[1], v.dur[2])
        end

        if v.bhvr ~= nil then
            mkbehavior(program_words, v.bhvr)
        end
    end
end</pre></code>
<p><pre><code>function Sig:send(gain)
    if self.reg &lt; 0 then
        error("no signal")
    end

    gain = gain or 0

    lil(string.format("mix zz [regget %d] [dblin %g]",
        self.reg, gain))
end</pre></code>
<p><pre><code>function gcd(m, n)
    while n ~= 0 do
        local q = m
        m = n
        n = q % n
    end
    return m
end

function lcm(m, n)
    return (m ~= 0 and n ~= 0) and
        m * n / gcd(m, n) or 0
end</pre></code>
<p><pre><code>function append_op(path, m, mp)
    for pname, p in pairs(m) do
        if mp[pname] == nil then
            mp[pname] = {}
        end
        for k, v in pairs(p) do
            table.insert(mp[pname], path.vertex(v))
        end
    end
end

function M.append(path, mp, r, m)
    append_op(path, M.morpheme(m, r), mp)
end

function M.appender(path)
    return function(mp, r, m)
        M.append(path, mp, r, m)
    end
end</pre></code>
<p><pre><code>function M.articulate(path, tal, words, seq, head)
    local mp = {}

    for _,s in pairs(seq) do
        M.append(path, mp, s[2], s[1])
    end


    M.compile(tal, path, words, mp, head)
end</pre></code>
<p><pre><code>function M.subset(m, a)
    local o = {}

    for _,v in pairs(a) do
        if m[v] == nil then
            error("Attribute '" .. v .. "' doesn't exist.")
        end
        o[a] = m[a]
    end

    return o
end</pre></code>
<p><pre><code>local function gcd(m, n)
    while n ~= 0 do
        local q = m
        m = n
        n = q % n
    end
    return m
end

local function lcm(m, n)
    return (m ~= 0 and n ~= 0) and
        m * n / gcd(m, n) or 0
end

local function fracadd(a, b)
    if a[2] == 0 then return b end
    if b[2] == 0 then return a end
    local s = lcm(a[2], b[2])
    local as = s / a[2]
    local bs = s / b[2]
    return {as*a[1] + bs*b[1], s}
end

local function reduce(a)
    out = a
    local s = gcd(out[1], out[2])

    if (s ~= 0) then
        out[1] = out[1] / s
        out[2] = out[2] / s
    end

    return out
end

function fracmul(a, b)
    local out = {a[1]*b[1], a[2]*b[2]}

    return reduce(out)
end

local function morphseq_dur(mseq)
    local total = {0, 0}
    for _, m in pairs(mseq) do
        local r = m[2]
        total = fracadd(total, r)
    end
    -- r is a ratemultiplier against a normalize
    -- path with dur 1. 2/1 is 2x faster, or dur 1/2.
    -- inverse to get duration
    -- this can be multiplied with normalized path
    -- to stretch/squash it out
    return {total[2], total[1]}
end

local function path_normalizer(p)
    local total = 0

    for _, v in pairs(p) do
        total = total + v[2]
    end

    return {total, 1}
end

local function apply_ratemul(p, r, vertexer)
    path_with_ratemul = {}

    for _,v in pairs(p) do
        local v_rm = {
            v[1],
            reduce({r[1], v[2]*r[2]}),
            v[3]
        }
        table.insert(path_with_ratemul, vertexer(v_rm))
    end

    return path_with_ratemul
end</pre></code>
<p><pre><code>function Gest:node()
	local glive = self.get(self)
	local mem = self.bufname
	local glivef =  function(self) return glive end
	local cndstr = self.conductor

    return function(n, p)
        local name = p.name or "gst"
        local program =
            string.format("[gmemsym [grab %s] %s]", mem, name)

        -- TODO: glivef makes this work as a regular node
        -- glive works as only a parameter node. Tests
        -- will break if glivef is used
        -- The quick fix is to just introduce a flag
        local is_param_node = n.sigrune_dummy or false
        if is_param_node then
            n.glive = n:param(glive)
        else
            n.glive = n:param(glivef)
        end

        n.conductor = n:param(p.conductor or cndstr)
        n:lil({"gestvmnode", "zz", program, "zz"})
        n:label("gesture: " .. name)
    end
end</pre></code>
<p><pre><code>local M = {}

&lt;&lt;morpheme&gt;&gt;
return M</pre></code>
<p><pre><code>function mkmacro(words, name, program)
    table.insert(words, "%" .. name)
    table.insert(words, "{")
    for _,v in pairs(program)
    do
        table.insert(words, v)
    end
    table.insert(words, "}")
end

function mklabel(words, label)
    table.insert(words, "@" .. label)
end

function mknum(words, val)
    table.insert(words, "#" .. string.format("%02x", val))
end

function mknote(words, note)
    table.insert(words, "#" .. string.format("%02x", note))
    table.insert(words, "NOTE")
    table.insert(words, "BRK")
end

function mkdur(words, num, den)
    mknum(words, num)
    table.insert(words, "NUM")
    mknum(words, den)
    table.insert(words, "DEN")
end

function mkbehavior(words, id)
    mknum(words, id)
    table.insert(words, "BHVR")
end

function mkjump(words, label)
    table.insert(words, ";" .. label)
    table.insert(words, "JMP2")
end

function compile_tal(tal)
    lil([[
    gmemnew mem
    gestvmnew gvm
    ]])

    gestvm_compile("mem", program_tal)
    lil("gmemcpy [grab mem] [grab gvm]")
end</pre></code>
<p><pre><code>Diagraf.Graph = {}
Graph = Diagraf.Graph

&lt;&lt;topsort&gt;&gt;
&lt;&lt;graph&gt;&gt;
</pre></code>
<p><pre><code>local Path = {}

&lt;&lt;path&gt;&gt;
return Path</pre></code>
<p><pre><code>function tal.num(words, val)
    table.insert(words, "#" .. string.format("%02x", val))
end</pre></code>
<p><pre><code>function tal.num(words, val)
    table.insert(words, "#" .. string.format("%02x", val))
end</pre></code>
<p><pre><code>mkmacro(program_words, "NUM", {"#24", "DEO"})
mkmacro(program_words, "DEN", {"#25", "DEO"})
mkmacro(program_words, "NEXT", {"#26", "DEO"})
mkmacro(program_words, "NOTE", {"#33", "ADD", "NEXT"})
mkmacro(program_words, "BHVR", {"#27", "DEO"})</pre></code>
<p><pre><code>                (  
   `</pre></code>
<p><pre><code>function tal.compile(program, bufname, gvm)
    gestvm_compile(bufname, program)
    lil("gmemcpy [grab " .. 
        bufname .. 
        "] " .. 
        gvm)
end</pre></code>
<p><pre><code>function Sig:getstr()
    if self.reg &lt; 0 then
        error("no signal")
    end

    --return string.format("[regget %d]", self.reg)
    return {"regget", self.reg}
end</pre></code>
<p><pre><code>function M.template(m)
    return function(p)
        local o = {}
        for k,v in pairs(m) do
            o[k] = p[k] or v
        end
        return o
    end
end</pre></code>
<p><pre><code>local tal = {}

&lt;&lt;cmds&gt;&gt;
return tal</pre></code>
<p><pre><code>function tal.label(words, label)
    table.insert(words, "@" .. label)
end</pre></code>
<p><pre><code>function Path.vertex(v)
    x = {}

    x.val = v[1]
    x.dur = v[2]
    x.bhvr = v[3]

    return x
end</pre></code>
<p><pre><code>[[
phasor [expr 96 / 60] 0

hold zz
regset zz 0

gestvmnode [grab gvm] [gmemsym [grab mem] mel] [regget 0]

mtof zz
blsaw zz
mul zz 0.5

butlp zz 800

dup
dup
verbity zz zz 0.1 0.1 0.1
drop
mul zz [dblin -15]
dcblocker zz
add zz zz

unhold [regget 0]

wavouts zz simple_path.wav

computes 10
]]</pre></code>
<p><pre><code>local tal = {}

&lt;&lt;cmds&gt;&gt;
return tal</pre></code>
<p><pre><code>v = function (note, dur, behavior)
    x = {}

    x.note = note
    x.dur = dur
    x.bhvr = behavior

    return x
end</pre></code>
<p><pre><code>[[
phasor [expr 96 / 60] 0

hold zz
regset zz 0

gestvmnode [grab gvm] [gmemsym [grab mem] mel] [regget 0]

mtof zz
blsaw zz
mul zz 0.5

butlp zz 800

dup
dup
verbity zz zz 0.1 0.1 0.1
drop
mul zz [dblin -15]
dcblocker zz
add zz zz

unhold [regget 0]

wavouts zz simple_path.wav

computes 10
]]</pre></code>
<p><pre><code>local M = {}

&lt;&lt;morpheme&gt;&gt;
return M</pre></code>
<p><pre><code>function Gest:get()
    return string.format("[glget [grab %s]]", self.name)
end</pre></code>
<p><pre><code>function Gest:create()
    lil("glnew " .. self.name)
    self.tal.membuf(self.bufname)
end</pre></code>
<p><pre><code>function Gest:swapper()
    lil(string.format("glswapper [grab %s]", self.name))
end</pre></code>
<p><pre><code>function Path.path(tal, words, path, lookup)
    for _, v in pairs(path)
    do
        if v.val ~= nil then
            local pathval = v.val

            if lookup ~= nil and type(pathval) == "string" then
                pathval = lookup[pathval]
            end

            tal.val(words, pathval)
        end

        if v.dur ~= nil then
            tal.dur(words, v.dur[1], v.dur[2])
        end

        if v.bhvr ~= nil then
            tal.behavior(words, v.bhvr)
        end
    end
end
</pre></code>
<p><pre><code>Warble = {}

&lt;&lt;warble&gt;&gt;
return Warble</pre></code>
<p><pre><code>NRT = {}

&lt;&lt;lpeg_constructs&gt;&gt;
&lt;&lt;solfvals&gt;&gt;
&lt;&lt;eval&gt;&gt;
return NRT</pre></code>
<p><pre><code>function Gest:done()
    lil(string.format("gldone [grab %s]", self.name))
end</pre></code>
<p><pre><code>function tal.halt(words)
    table.insert(words, "BRK")
end</pre></code>
<p><pre><code>function tal.behavior(words, id)
    tal.num(words, id)
    tal.num(words, 0x27)
    table.insert(words, "DEO")
end</pre></code>
<p><pre><code>function tal.jump(words, label)
    table.insert(words, ";" .. label)
    table.insert(words, "JMP2")
end</pre></code>
<p><pre><code>function tal.interpolate(words, state)
    tal.num(words, state)
    tal.num(words, 0x2a)
    table.insert(words, "DEO")
end</pre></code>
<p><pre><code>Whistle = {}

&lt;&lt;oscillator&gt;&gt;
return Whistle</pre></code>
<p><pre><code>function Whistle.graph(params)
    local sig = sig or params.sig
    local core = core or params.core
    local diagraf = diagraf or params.diagraf
    local node = diagraf.Node
    local g = diagraf.Graph:new{sig=sig, debug=params.debug}
    local sr = sigrunes or params.sigrunes

    local ng = core.nodegen(node, g)
    local pg = core.paramgen(ng)

    freq = pg(params.freq or core.paramf(440), "freq")

    con = g:connector()
    ns = ng(sr.noise)()
    lpf = ng(sr.butlp)()
    con(ns, lpf.input)
    amp = pg(params.amp or core.paramf(0.8), "amp")
    eq = ng(sr.peakeq) {
        freq=500,
        bw=250,
        gain=2
    }

    con(lpf, eq.input)
    timbre = pg(params.timbre or core.paramf(0.5), "timbre")
    mtofr = ng(sr.mtof)
    addr = ng(sr.add)
    subr = ng(sr.sub)
    mulr = ng(sr.mul)

    mtof1 = mtofr()
    con(freq, mtof1.input)

    add1 = addr{b=0.1}
    con(freq, add1.a)
    mtof2 = mtofr()
    con(add1, mtof2.input)

    sub1 = subr{b=0.1}
    con(freq, sub1.a)
    mtof3 = mtofr()
    con(sub1, mtof3.input)

    sub2 = subr()

    con(mtof2, sub2.a)
    con(mtof3, sub2.b)

    butbp = ng(sr.butbp)()
    con(eq, butbp.input)
    con(mtof1, butbp.freq)
    con(sub2, butbp.bw)

    dblin = ng(sr.dblin)({db=10})
    mul1 = mulr {}
    con(butbp, mul1.a)
    con(dblin, mul1.b)


    blsq = ng(sr.blsquare)()
    con(mtof1, blsq.freq)
    mul2 = mulr{b=0.5}
    butlp = ng(sr.butlp){cutoff=300}
    buthp = ng(sr.buthp) {cutoff=300}
    con(blsq, mul2.a)
    con(mul2, butlp.input)
    con(butlp, buthp.input)

    cf = ng(sr.crossfade)()

    con(mul1, cf.a)
    con(buthp, cf.b)
    con(timbre, cf.pos)

    mul3 = mulr()

    con(cf, mul3.a)
    con(amp, mul3.b)

    return g
end

function Whistle.osc(params)
    local g = Whistle.graph(params)
    local l = g:generate_nodelist()
    g:compute(l)
end</pre></code>
<p><pre><code>local Path = {}

&lt;&lt;path&gt;&gt;
return Path</pre></code>
<p><pre><code>5-     l        @	     e      5X	 _.     p             6]*[ef783eca] 2023-07-18-20-56*:       t    @I     \	([[/gestlings/weight][weight]])      x 
       p#  RU         *L                                                 u.U               (     z{     A@     F@     F@     F@     F@     F@     A@      $@                     (     w     A@     F@     A@     A@     A@     F@     A@      $@ -             (     z{     A@     F@     F@     F@     F@     F@     A@      $@                    (     2     A@     A@     A@     A@     A@     A@     A@      $@                     (          F@     F@     F@     F@     F@     F@     F@      $@            #        0(     f     A@     A@     A@     F@     A@     A@     A@      $@            *        `(     z{     A@     F@     F@     F@     F@     F@     A@      $@ point      1        (     w     A@     F@     A@     A@     A@     F@     A@      $@            8        (          F@     F@     F@     F@     F@     F@     F@      $@ -     ?         (     [     F@     A@     A@     A@     A@     A@     F@      $@            F        .  G   SELECT time, UUID, substr(value, 2) as task, substr(state, 9) as state              M        (          F@     F@     F@     F@     F@     F@     F@      $@            T        (     f     A@     A@     A@     F@     A@     A@     A@      $@            [        (          F@     F@     F@     F@     F@     F@     F@      $@            b        (     [     F@     A@     A@     A@     A@     A@     F@      $@ x          i        @(          F@     F@     F@     F@     F@     F@     F@      $@            p          #      #      #      "      "      "                                            w        p(     w     A@     F@     A@     A@     A@     F@     A@      $@            @/U        SELECT * FROM content WHERE id=13 AND program=10                  a        `  0   03|SELECT * FROM content WHERE id=13 AND program=10     
 SELECT * FROM blkref WHERE id=15 AND program=10                          p  /   "SELECT * FROM blkref WHERE id=15 AND program=10       SELECT * FROM blocks WHERE id=14 AND program=10%                               /   4YSELECT * FROM blocks WHERE id=14 AND program=10       SELECT * FROM blkref WHERE id=15 AND program=10                  #        0  /   "SELECT * FROM blkref WHERE id=15 AND program=10      ( SELECT * FROM blocks WHERE id=14 AND program=10       &-     -        P  /   4YSELECT * FROM blocks WHERE id=14 AND program=10      2 SELECT * FROM segments WHERE id=16 AND program=10                     K7        0  1   PSELECT * FROM segments WHERE id=16 AND program=10    &lt; SELECT * FROM headers WHERE id=17 AND program=10                  mA          0   ugSELECT * FROM headers WHERE id=17 AND program=10     F ** 3.2. &lt;a id="label"&gt;Label&lt;/a&gt;
         ?                K                         :h/ K-     P SELECT * FROM content WHERE id=18 AND program=10:h/             U         %              @    *   9                      Z     D-               @    *  @9                      _        0.  .   (messages group &opt typeflag genrefs limit)

      d     `%  *   ct0W(gen-tilemap filename gw gh ncols nrows)

      	    i        /     xH88(E-/            vn           0   !SELECT * FROM content WHERE id=18 AND program=10     s                                             x SELECT * FROM blkref WHERE id=19 AND program=10                                  sh/U        *[82fdf14c] 2023-07-31-15-50*:  (r  
        w.       
         RU         ,,                         G-                )           G-                   UG*[82fdf14c] 2023-07-31-15-50*:               @     "([[/gestlings/sigils][sigils]])                    |!protogestling_mockup                                   do_pN                                    +Saving/Loading Paths as Assets                     @l@Symbol Set and Grammar              I$          !   JGRescale Path to Morpheme Sequence    (    efghH-             CDEF           XYZ      ,          	           P"+           t.     0             aDsaving/loading paths as assets      4        PJ-     Hsaving/loading-paths-as-assets      N8 savingloading-paths-as-assetsp4Z.ht.     &lt;        P     Y(savingloading-paths-as-assets       @        K-     a*symbol set and grammar              D        PK-     (^symbol-set-and-grammar  `5-     RH          !   #rescale path to morpheme sequence    SL        K-  !   M rescale-path-to-morpheme-sequence    P             
            T        ,                 .                      X        L-     S.      P@      ?     \             Q[#+TITLE: The Gesture Path
   	    `             O&lt;a id="overview"&gt;Overview&lt;/a&gt;       d        P  #   91g* 1. &lt;a id="overview"&gt;Overview&lt;/a&gt;
  h    I-     @       m  H-   u.     l 
       8  RU         *L      u.      p &lt;a id="creating-a-vertex"&gt;Creating a Vertex&lt;/a&gt;             t 
   CT *  RU         *L       w.      ^x    ME: 0  !   s&[[/gestlings/descript][descript]]                                    1U               $.     W%.K.H%.%.%.&. d       pv9;    @O-                                                      ype              &.     3('.HL.X'.hL.'.,.,.      (gen-tilemap filename gw gh ncols nrows)

)  N_SRC
                       i e '       w9    P                                                             (              ..     nH..M.x....../.8/.     $ @[%    P                                                             E*     * * 6. &lt;a id="sndkit-patch"&gt;Sndkit Patch&lt;/a&gt;
                                              0 x9    P                                                                        6        #.     n#.O.33333     &lt; ,  *  /  3  * /  3  * 1* 3 0 * 3  =    )  /  4          B @d%      @        O-          	                                (     H Ixb+--8-V-x--PE|Ip.     N        E-     Z:-kg/I*0J*J*0K*,h$     T ,  *  /  3  $	 * /  3  * * 1* 4  *  /  3  $  * /  4       Z 0z9      @0U-                                                                   `        P3     W3A.33X33 ype        f f%    P                                                                        l         -  9   *%INNER join wikizet on zetdo_priority.UUID = wikizet.UUID        
    3r        3  B   \2SELECT * FROM blkref WHERE program == 2 AND ref == 45 AND pos == 2   x          	      	      	                                                   qnU        H           P                                                                       5      @        F$  8W-                                        ile '                ?   }y[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-                ?   #SELECT id, type FROM resources WHERE program=%d ORDER by id ASC  !         @  ?   |-vSELECT id, type FROM resources WHERE program=11 ORDER by id ASC          2     W2383h33            $     P                                                             !      *        `     n
8h     0 $+      @        {$                                          ,,      6 Y      @        Z-          h     ;    @HZ-  type    !      &lt;       @@[-                                                                 B             n(
X  H  '+    P                                                                      N &lt;a id="whats-a-path"&gt;What's a "Path"?&lt;/a&gt;                                        
    T * 2. &lt;a id="whats-a-path"&gt;What's a "Path"?&lt;/a&gt;
                            type        Z      P                                                             ,,      `        0     n(X     f @)++      @        \-  8]-                                                l * 3. &lt;a id="tangled-code"&gt;Tangled Code&lt;/a&gt;
                                  type      r p++    P                                                                        x @5      @        ]-  X^-                                                   @0U           CT *v-     @       rogrd  @v-   u.              F                d           _              0%     T;&lt;a id="compile"&gt;compile&lt;/a&gt;          
   CT *@V  RU         *L      f-          ME: p     El/gestlings/mouthanim                        (     =oenable/disable interpolator           CT *  #   j[[/gestlings/mouthanim][mouthanim]]          ,                .                               `-     6S.     @S@      ?     $ *[299387b4] 2023-08-07-16-46*:  |.`6-             (        .     E[      5.            ,             *[299387b4] 2023-08-07-16-46*:       0    `_-              8                      4 
       a$  RU         *L      b-     8        u     	e/gestlings/simple_path  b-     &lt;          !      !                                @ [[/gestlings/simple_path][simple_path]]                     D        ,                 .                      H        `c-     S.     `@      ?     L                       J                      P        c-                p                      T        p           (            X         d-     @           i  c-             \         b-     @           `i  `_-              ` 
         RU         *L                  d IB.`.`.PE I            h ,  /   *  3 /  * 3 * * 1* 3 /  * 4   l             E/gestlings/sdfvm_mouth              p        ,                .                      t         f-     S.      a@      ?     x [[/gestlings/sdfvm_mouth][sdfvm_mouth]]         }.                                     oh%U                    3	8	h			                                            0H               H       H   H                           nHx                                                p            H       H   H                    $            W(X          * @                         H               0                                        6 H                                         &lt;           W8h        B      H       H   H                           H           3Hx   N 0H   H               H                       T       P     38X8(   Z       H       H   H                       ` p                      H   H                f       /     nH/xx///080     l 0           H   H               H            r             H                              x       6     W66(7X77            1U           ME: @               0&gt;                              P#     
F'&lt;a id="halt"&gt;halt&lt;/a&gt;              B ** 3.5. &lt;a id="halt"&gt;halt&lt;/a&gt;
  .~.                    #     *** 3.5. &lt;a id="halt"&gt;halt&lt;/a&gt;
          CT * o-             rogr0           .          ME:  p-     @           `   o-               ** 3.6. &lt;a id="dur"&gt;dur&lt;/a&gt;
   8:.                    0#     ~A** 3.6. &lt;a id="dur"&gt;dur&lt;/a&gt;
                 C     
*Y*[fd11b75c] 2022-12-17-06-02*:       	$        `.  #   (SELECT UUID as ID, value as state   (        .     zU"ON wikizet.UUID = states.ID         ,        .     oWHERE value IS '#' || '             0         .     AND value LIKE '$state:%')          4         r-     mV[(page-amalg group)

                8 
   ME:   RU         *L                     &lt;        @     ,&lt;a id="behavior"&gt;behavior&lt;/a&gt;       @    CT *     G	-[[/gestlings/tasks][tasks]]         D ([[/gestlings/tasks][tasks]]),p~-                       H             0/7&lt;a id="jump"&gt;jump&lt;/a&gt;               SL ** 3.8. &lt;a id="jump"&gt;jump&lt;/a&gt;
  `z-                      P             [** 3.8. &lt;a id="jump"&gt;jump&lt;/a&gt;
      T    CT *p     D&([[/gestlings/tasks][tasks]]),      X *[86788620] 2023-08-08-13-18*: p4X.          \        @.     &gt;Y&lt;a id="membuf"&gt;membuf&lt;/a&gt;   
    8`        .  "   ** 3.9. &lt;a id="membuf"&gt;membuf&lt;/a&gt;
   d    CT *@     Q*[86788620] 2023-08-08-13-18*:       h ([[/gestlings/sigils][sigils]])DE u      l        `P     69&lt;a id="start"&gt;start&lt;/a&gt;  .     \p        P  !   T&gt;** 3.10. &lt;a id="start"&gt;start&lt;/a&gt;
    t    CT *            rogr                      x    ME: @v-             p                                                    m	1U                                                    A          1   xeSELECT * FROM segments WHERE id=10 AND program=10    
        @q-  )   FROM wikizet WHERE value LIKE '$state:%'        
                                                                                                      `D*               @    *   9           Z-              E*     h1h8%%@`* Z-     #          $   *Ylocal tal = {}

&lt;&lt;cmds&gt;&gt;
return tal
                (                                             - SELECT * FROM headers WHERE id=11 AND program=10
                  j2           0   / (SELECT * FROM headers WHERE id=11 AND program=10     7 * 3. &lt;a id="commands"&gt;Commands&lt;/a&gt;
         ?                &lt; SELECT * FROM headers WHERE id=12 AND program=10                  mA           0   F]SELECT * FROM headers WHERE id=12 AND program=10     F        E*               @    *  @9                      K         0*     K7F*@F*p* 0*     P     0*     b	n8`0*0*{-            U                                             Z                                  z-     _ ** 3.1. &lt;a id="macro"&gt;Macro&lt;/a&gt;
                         d                                             i     1*               @    *  9                      n    %     ux\	h8f**                s        }-     Hh8 e**}-            x      ~-     h8c*d*@~-                            	H2U         &lt;a id="to-provide-some-context"&gt;To Provide Some Context&lt;/a&gt;                  &lt;                          CT * -             rogr                              ,                .                              -     S.     a@      ?         ME: `-     @       :   -                      p     &lt;X|&lt;a id="commands"&gt;Commands&lt;/a&gt;               .     t (charfill char rep)

                          #   q* 3. &lt;a id="commands"&gt;Commands&lt;/a&gt;
  $             |:b&lt;a id="macro"&gt;Macro&lt;/a&gt;             j(        0      Z** 3.1. &lt;a id="macro"&gt;Macro&lt;/a&gt;
     ,        ;  #   v([[/gestlings/morpheme][morpheme]])  0        ,            p.                      4 ,  /   *  3 )  /  3 0 * 3 /  * 4          8 
   ME: P  RU         *L                     &lt;        ,                .                      @        -     xS.      f@      ?     D             ?&lt;a id="label"&gt;Label&lt;/a&gt;  ^-     rH              w** 3.2. &lt;a id="label"&gt;Label&lt;/a&gt;
     L        -     VS.     `f@      ?     P         .     @n(printhistory UUID)

               T              8Creates an Uxn label.

             X    CT *`     |/gestlings/mouthsounds  -      \ [[/gestlings/mouthsounds][mouthsounds]]                     ` ** 3.3. &lt;a id="num"&gt;Num&lt;/a&gt;
p4X.          d        S#     `5** 3.3. &lt;a id="num"&gt;Num&lt;/a&gt;
       h *[125de2f9] 2023-08-08-15-31*: ram ==     .       l    ME:      {*[125de2f9] 2023-08-08-15-31*:       p ** 3.4. &lt;a id="val"&gt;Val&lt;/a&gt;
H8.-      t        pj#     	0** 3.4. &lt;a id="val"&gt;Val&lt;/a&gt;
       x *[fd11b75c] 2022-12-17-06-02*:  -                                       k
2U                                                     SELECT * FROM blocks WHERE id=5 AND program=10@                
                                  ^-                                                       `@*               @    *  9                           -      ***`**          %      ***`**     #        *     DH8h%%*            (          .   $SELECT * FROM blocks WHERE id=5 AND program=10      - SELECT * FROM blkref WHERE id=6 AND program=10                     2                                             7          .   }LjSELECT * FROM blkref WHERE id=6 AND program=10      &lt;                                             A SELECT * FROM blocks WHERE id=5 AND program=10                     F        0  .   $SELECT * FROM blocks WHERE id=5 AND program=10      K                                             P I,pG|I.`..PE I     U SELECT * FROM segments WHERE id=8 AND program=10                  rZ           0   4SELECT * FROM segments WHERE id=8 AND program=10     _ SELECT * FROM segments WHERE id=9 AND program=10                  td          0   pZSELECT * FROM segments WHERE id=9 AND program=10     i SELECT * FROM segments WHERE id=10 AND program=10       p-     n                         :% p-     s        A*               @    *  @9                      x        B*     x7B* C*@B* -                     
3U                -                6           .             0     5~4      (H .             -     @       in'.d   -   -      
       `N  RU         *L      .                  [[/gestlings/sigils][sigils]]                    jx                   &gt;added !path_grammar                g               &gt;more words added to !mseq page.       
         RU         ,,               $        -                0)                      (        ,                +                      ,        @-     S.     g@      ?     0        `.     XbAND value IS '#' || '               4 *[08eaa478] 2023-08-10-15-59*:  (  H               8        @.     KaAND value like '&gt;%'                 &lt;             *[08eaa478] 2023-08-10-15-59*:       @ 
   h sy 7  RU         *L     ds             QD    h sy0;  !   uZ[[/gestlings/morpheme][morpheme]]    H        r     zeTo Provide Some Context             L        @     =oenable/disable interpolator         P (X=OPQRSTUV XYZ        T        0                a,                      X         -     Zto provide some context             \        @-     .to-provide-some-context             `        `     =oenable/disable interpolator         d        -     ?B&enable/disable-interpolator         h enabledisable-interpolator     (..            l             8enabledisable-interpolator   	    p        P     (            t        `     $c#+TITLE: Tal (via Lua)
             x             zeTo Provide Some Context                                             iTU                E     nhEX1EEEEXF    Q    !  !          ,,       !      8!   !       * 5. &lt;a id="tangled-code"&gt;Tangled Code&lt;/a&gt;
          ,,       H!            @T    ,,       H!      !  !      ,,            p!  !        ,,       H!      !  !                  K     WKx K(LXLL !      $ pV,,       H!      8!  8!         ,,       !      *      p  C   tSELECT * FROM blkref WHERE program == 12 AND ref == 11 AND pos == 2  0 H!      !  !       ,,       H!      !   !      6      !      8!  8!      ,,      !           &lt;           W(X          B  8!  8!       ,,      H!      !  !              H       `     38X	8	h	 ! N 0,,       !      !  !         ,,       !      T      
     3X



    Z p    !  !      ,,      !      !   !      `      	     388h ! f X      ,,       H!      8!  8!       ,,            l * 6. &lt;a id="implementation"&gt;Implementation&lt;/a&gt;
 !      !  !      ,, r H!      !  !       ,,       !       !      x          nHx     (4U               -     A[p4(                 -     7(-             -     Vc8    (              -     , b8((             `-     H8@-             -     op4((             -     (U( -             PC0                C0           -              `b+     =zetdo_priority.UUID,                I$        -  !   0substr(wikizet.value, 2) as task     (        -     @jfrom zetdo_priority                 ,         V-     uWHERE wikizet.value LIKE '&gt;%'       ,0        `-  "   ,ORDER BY zetdo_priority.score DESC   4 ([[/gestlings/morpho][morpho]])'UUID', 'value'            8        `-                @D0           -     &lt;         -                0E0                     @        3     q([[/gestlings/morpho][morpho]])      D        `-             E0           -     H        -              F0                      L         -             pF0                    P        `-             7           -     T        0                                      X        -            +           d+     \         -     :--      A@      ?     `        +                +                      d        -     vS.     j@      ?     h        .     !\(print-task r level)

              l        %            +           d+     p 
       @3   QU         
9  "    -     t 
          QU         
9  "    d+     x         5            1  d                                                      g4U               P/     $k4&gt;      H8(p/              i+            Pi+  `c-                    /     ab I      (                            -     aR@I      (      ?                  .     O      83(                    +                +                              -     S.      n@      ?              &     @          ``   *   -       
         RU         *L      -     $             8      xn+            (        @j+            
   pj+  -              ,        /             -0                      0        P-             .0                      4        -     :-      ?      ?     8        0%     @       @6                    &lt; 
       #  RU         *L                   @        3     e^[[/gestlings/morpho][morpho]]       D 
       J  RU         *L      i+     H        .0             @?0           -     L 0       *L  =  K                             P        -             ?0           -     T        -                 0@0                      X        k+             l+  -            \        -                 pA0                      `        P-             B0                    d        -                 `B0                      h        +                +                      l        -     FS.     Pp@      ?     p        -             B0                      t        .                h+  @-              x        (     3H8(-                                     4U        &lt;&lt;vertex_shorthand_for_gesture_path&gt;&gt;a+xh+@-                 +  %   q&j&lt;&lt;vertex_shorthand_for_gesture_path&gt;&gt;               
        0+  %   F7parsing_programs/parsing_programs.org                SELECT * FROM segments WHERE id=14 AND program=2                     d        @+  0   M;SELECT * FROM segments WHERE id=14 AND program=2      SELECT * FROM segments WHERE id=15 AND program=20-- -     f        +  0   9SELECT * FROM segments WHERE id=15 AND program=2     #         9-89P)                    ( &lt;&lt;gesture_path_as_lua_structure&gt;&gt;                             -     `+  %   %&gt;Ulevels/gestleton/gestleton_mapgen.org              2 SELECT * FROM segments WHERE id=16 AND program=2                     7     @-  &   Gprotogestling/protogestling_mockup.lua              l&lt;     p+  0   @SELECT * FROM segments WHERE id=16 AND program=2     A SELECT * FROM headers WHERE id=17 AND program=2:xh+             F     -  %   Z\jprotodiacritics/protodiacritics.janet              K        +  /   .AUSELECT * FROM headers WHERE id=17 AND program=2      P * 2. &lt;a id="overview"&gt;Overview&lt;/a&gt;
 H9  ,                      U SELECT * FROM content WHERE id=18 AND program=2                             Z        p+  /   SELECT * FROM content WHERE id=18 AND program=2      _ SELECT * FROM headers WHERE id=19 AND program=2                             d        p|+  /   (
SELECT * FROM headers WHERE id=19 AND program=2      i    /loc +  (   TAL as a lua table of tokens, or "words"            n SELECT * FROM content WHERE id=20 AND program=2&0& p&     s     x+  /   SELECT * FROM content WHERE id=20 AND program=2      x SELECT * FROM headers WHERE id=21 AND program=2                                             e0kU            `  /   "G/SELECT * FROM headers WHERE id=4 AND program=11              )   	&lt;a id="whats-a-path"&gt;What's a "Path"?&lt;/a&gt;      
    
      `  /   `* 2. &lt;a id="whats-a-path"&gt;What's a "Path"?&lt;/a&gt;
  ,,  SELECT * FROM content WHERE id=5 AND program=11,,                        /   bSELECT * FROM content WHERE id=5 AND program=11       SELECT * FROM headers WHERE id=6 AND program=11      ,,                      /   SELECT * FROM headers WHERE id=6 AND program=11  ! #     0   %   P&lt;a id="tangled-code"&gt;Tangled Code&lt;/a&gt;  ,,      (     &  +   * 3. &lt;a id="tangled-code"&gt;Tangled Code&lt;/a&gt;
         - SELECT * FROM blkref WHERE id=8 AND program=11  !  !            2      '  .   @SELECT * FROM blkref WHERE id=8 AND program=11      7 SELECT * FROM blocks WHERE id=7 AND program=11     !  !      &lt;      0)  .   &gt;0SELECT * FROM blocks WHERE id=7 AND program=11      A SELECT * FROM blkref WHERE id=8 AND program=11         !      F        *  .   @SELECT * FROM blkref WHERE id=8 AND program=11      K SELECT * FROM blocks WHERE id=7 AND program=11      )          P      *  .   &gt;0SELECT * FROM blocks WHERE id=7 AND program=11      U SELECT * FROM segments WHERE id=10 AND program=11,,                RZ      4  1   yeSELECT * FROM segments WHERE id=10 AND program=11    _ SELECT * FROM segments WHERE id=11 AND program=11    ,,           Td       5  1   Z3SELECT * FROM segments WHERE id=11 AND program=11   i SELECT * FROM segments WHERE id=12 AND program=11!        ,,      Vn      8  1   ;YSELECT * FROM segments WHERE id=12 AND program=11   s        &   X(local Path = {}

&lt;&lt;path&gt;&gt;
return Path
            x SELECT * FROM headers WHERE id=13 AND program=11,,                             @5U               l+                l+  -                      -     d1      (@                    @m+                pm+  L-                      -     ?1      H8(-             m+                 n+  `-                       -     ab 3      (                            `n+                n+  -                      -     aR@3   )   (      ?                      o+                Po+  -              $        v$     %$2      H8(v$     (        o+                p+  @-              ,        -     e4      8:@            0        pp+                p+  -              4         -     4      H8((@-     8         q+                0q+  -              &lt;        -     O:      (       @            @         -     d:      5@-       @     D        q+                q+  	-              H        `-     o;      x20H(((     L        Pr+                r+   %-              P        -     GKr;      5 -       @     T        s+                @s+   f-              X        `-     gn:   	   5--     \        -     9      8D9 -            `         -     O&lt;   
   (      @            d         }+            3  +  H9              h        `-     G\3&lt;      5-      *@     l        *     A      h5      @( et  p         -     A      5@-       @     t        `-     B      h5      @(     x        -     B      5-       @                                     c6U           -     @#      H8(-             +  #   ~;curated_lglyphs/curated_lglyphs.org          P-     p!m$   %   h78(                    -     $      (-                    +     8simple_path/simple_path.org                 P-     07simple_path/simple_path.lua                 -     oJ%$      0-89                    +     ,Sloadtiles/loadtiles.org                      -     v.:1loadtiles/loadtiles.janet       
    $        -     VF$      H88(-     (        +     hkprotosigils/protosigils.org         ,        -     CJprotosigils/protosigils.janet       0        -     HmpGradicals/radicals.txt               4         +  #   : protodiacritics/protodiacritics.org  8        *     uH%      H8(*     &lt;        P+     0WpGradicals/radicals.org               @        -     HmpGradicals/radicals.txt               D        P-     zAradicals/radicals.janet             H        -     tn(      h5      H@      @     L        -     tn(      h5      H@      @     P        &     X(      H88&     T        P-     +)      8       @            X        -     3)   "   8      @            \        -     	Z)      3--     `        @+     dmorpheme/morpheme.org               d        P-     morpheme/morpheme.lua               h        -     @)      H8h$0-     l        -     k+      H8(       @     p         &     T-      (3&            t        P-     aS-      H8H(p-     x        -     0      6(                                            6U               -                  B/                              +     xsigrunes/sigrunes.org                       -     xsigrunes/sigrunes.lua                       @-                 B/                               -                 @C/                              @-                 /                              .                /                              -                +                                -     h(      F@      ?     $        +     protogestling/protogestling.org      (        -     tprotogestling/protogestling.c       ,              EjY                            0 
        -   QU         
9  b                   4        @-               @3  H9              8 radicals/radicals.janet         p+                      &lt;        +     34Pprotogestling_mockup                @         -     
z#protogestling/mockup.org            D        p(     zAradicals/radicals.janet             H      #   X;[[/gestlings/sig#throw][10. Throw]]  L         +     FUdescript/descript.org               P         -     Udescript/descript.lua               T        &     @           -(                      X        P-     K5levels/gestleton/mapgen.lua         \        -     +2levels/gestleton/render.lua         `        -           H8(-     d        +     avatar/mouth/mouthtests.org         h        -     Javatar/mouth/mouthtests.c       
    l        @&     v.:1loadtiles/loadtiles.janet       
    p        P+     1Kavatar/mouth/sdfvm_mouth.org        t        @-     Kavatar/mouth/sdfvm_mouth.lua        x         -     pQ#      (M3-                                            a7U               +     w&lt;avatar/mouth/mouthanim.org      	            0-     0avatar/mouth/mouthanim.lua      	             @/                 p@/                              +     .1avatar/mouth/mouthsounds.org                -     1avatar/mouth/mouthsounds.lua         
       `  RU         *L                         -                 A/                              -                A/           -              +               *                      $        0-            1 p*                      (        +             *                      ,        P     /gestlings/sig#throw              0        0-                -                      4        0-     x}+      ?      ?     8        p-                	+                      &lt;        +                	+                      @         +                0
+                      D        0+                
+                      H        `+                P+                      L        +                +                      P        -                p+                      T        +                 +                      X        +                +                      \         +                 +                      `        P+                +                      d        +                @+                      h        +                *                      l        0+                *                      p        `+                0*                      t        0-                *                      x        +                P*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         plU               `-                            
      6@                                      @                                    -     OY                       
      7@                                      @                                    -                            
      8@                                      @                            $        -                            
      9@                                       @                            0        P-     y                       
      :@                                      @                            &lt;        -     W.                       
      ;@                                      @                            H        -                            
      &lt;@                                       @                            T        -                            
      =@                                      @                            `        P-     N                       
      &gt;@                                      @                            l        -     O                       
      ?@                                      @                            x        -                            
      @@                                      @                                    -     =                       
     @@                                      @                                    P-     m                       
      A@                                       @                                    -     r                       
     A@                                      @                                    -     #                       
      B@                                      @                                    -     }                       
     B@                                      @                                    P-     K                       
      C@                                       @                                    -     2                       
     C@                                       @                                    -     |                       
      D@                                      ?                                    -     A                       
     D@                                      @                                                                                                                                                                                                                                                                               lU                            `8     `                       
      @                                      @                                   -     `                       
      @                                      @                                  -     l                       
      @                                      @                          %        -     hf                       
      @                                      @                          1        `-     T;                       
      @                                      ?                          =         -     |                       
       @                                      @                          I        -     :                       
      "@                                                                  U        -     l                       
      $@                                       @                          a        `-     O                       
      &@                                       @             ,8 m    P-     B                   
      E@                                       @                          y         -     p                       
      (@                                       @                                  -     $                       
      *@                                      @                                  `-                            
      ,@                                      @                                   -                            
      .@                                      ?                                  -     d                       
      0@                                      @                                  -                            
      1@                                       @                                  `-                            
      2@                                      @                                   -     K                       
      3@                                      @                                  -     9                       
      4@                                      @                                  -                            
      5@                                       @                                                                                                                                                                                                                                                                nU              UPDA  
   '.sqd-  QU         ` .   .  0           , ro         $                                   "                                                                   0 9    '              +         .                             Xn                   ~     2&gt;the core data format for gestlings will be called !descript. Eventually, an entire video file for a gestling will be defined in this file, rather than in bits and pieces of lua code like with the !protogestling_mockup     	                  % #+NAME: path
#+BEGIN_SRC
function Path.vertex(v)
    x = {}

    x.val = v[1]
    x.dur = v[2]
    x.bhvr = v[3]

    return x
end</pre></code>
<p><pre><code>function Path.save(asset, gpath, filename)
    asset:save(gpath, filename)
end

function Path.load(asset, filename)
    local path_data = asset:load(filename)

    return Path.data_to_path(path_data)
end</pre></code>
<p><pre><code>function M.subset(m, a)
    local o = {}

    for _,v in pairs(a) do
        if m[v] == nil then
            error("Attribute '" .. v .. "' doesn't exist.")
        end
        o[a] = m[a]
    end

    return o
end</pre></code>
<p><pre><code>function gcd(m, n)
    while n ~= 0 do
        local q = m
        m = n
        n = q % n
    end
    return m
end

function lcm(m, n)
    return (m ~= 0 and n ~= 0) and
        m * n / gcd(m, n) or 0
end</pre></code>
<p><pre><code>function tal.macro(words, name, program)
    table.insert(words, "%" .. name)
    table.insert(words, "{")
    for _,v in pairs(program)
    do
        table.insert(words, v)
    end
    table.insert(words, "}")
end</pre></code>
<p><pre><code>function M.articulate(path, tal, words, seq, head)
    local mp = {}

    for _,s in pairs(seq) do
        M.append(path, mp, s[2], s[1])
    end


    M.compile(tal, path, words, mp, head)
end</pre></code>
<p><pre><code>function tal.membuf(bufname)
    lil(string.format("gmemnew %s", bufname))
end</pre></code>
<p><pre><code>function M.merge(A, B)
    local o = {}

    for k,v in pairs(A) do
        o[k] = v
    end

    for k,v in pairs(B) do
        o[k] = v
    end

    return o
end</pre></code>
<p><pre><code>{
    v(7, {2,1}, 2),
    v(5),
    v(7),
