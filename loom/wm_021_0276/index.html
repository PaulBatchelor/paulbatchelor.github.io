<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/css/style.css">

</head>
<body>
<div id="main">

<h2>6. Meta Commands and Actions</h2>

<p><a id="wm_021_0276"></a>Commands related to meta-things. Also, placing
things related to actions (such as scalars) here,
as there is no other place to put them, and not
enough of them to make a new category.
</p>

<h3>6.1. Addmetatarget</h3>

<p><a id="wm_021_0278"></a>The function <code>gest_addmetatarget</code> will create a new
metatarget with a size of <code>sz</code> metatargets.
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>int gest_addmetatarget(gest_d *g, int sz);</pre></code>
<p></p>
<p>This function will implicitely create a new target
using <code>gest_addtarget</code>, then configure this
target to be a metatarget.
</p>
<p>After it is created, the metatarget gets pushed onto the
metatarget stack contained in the gest data.
</p>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>int gest_addmetatarget(gest_d *g, int sz)
{
    int rc;
    gest_target *t;
    gest_metatarget *mt;

    if (g-&gt;mtpos &gt;= GEST_MTSTACK_SIZE) return 2;

    rc = gest_addtarget(g, -1);

    if (rc) return rc;

    t = g-&gt;curtarget;

    mt = metatarget_alloc(g, sz);

    t-&gt;get = get_seq;
    t-&gt;meta = mt;
    mt-&gt;parent = t;

    /* push to stack */
    g-&gt;mtstack[g-&gt;mtpos++] = mt;
    return 0;
}</pre></code>

<h3>6.2. Addmetabehavior</h3>

<p><a id="wm_021_0285"></a>Adds a metabehavior of with <code>sz</code> behaviors.
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>int gest_addmetabehavior(gest_d *g, int sz);</pre></code>
<p></p>
<p>By default, adding a metabehavior means taking
the behavior in the currently selected target and
converting it into a metabehavior. A nested metabehavior
will already have the root behavior converted
into a metabehavior at this point. If a metabehavior
has been found, it will create a metabehavior on
the next available behavior in the parent metabehavior.
</p>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>int gest_addmetabehavior(gest_d *g, int sz)
{
    gest_target *t;
    gest_metabehavior *mb;
    gest_behavior *b;

    if (g-&gt;mbpos &gt;= GEST_MBSTACK_SIZE) return 2;

    t = g-&gt;curtarget;

    b = &t-&gt;behavior;

    if (b-&gt;meta != NULL) {
        /* empty stack, shouldn't happen normally */
        if (g-&gt;mbpos &lt;= 0) return 3;

        mb = b-&gt;meta;
        b = &mb-&gt;behaviors[mb-&gt;pos++];

        if (mb-&gt;pos &gt;= mb-&gt;size) {
            g-&gt;mbstack[g-&gt;mbpos - 1] = NULL;
            g-&gt;mbpos--; /* don't be clever */
        }
    }

    mb = metabehavior_alloc(g, sz);

    b-&gt;get = behave_seq;
    b-&gt;meta = mb;
    mb-&gt;parent = b;

    /* push to stack */
    g-&gt;mbstack[g-&gt;mbpos++] = mb;
    return 0;
}</pre></code>

<h3>6.3. Addmetanode</h3>

<p><a id="wm_021_0292"></a><div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>int gest_addmetanode(gest_d *g, int nbeats, int sz);</pre></code>
<p></p>
<p>When a metanode is created, it creates the equivalent to
a monoramp, then binds a metanode to it.
</p>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>int gest_addmetanode(gest_d *g, int nbeats, int sz)
{
    int rc;
    gest_node *n;
    gest_metanode *mn;

    if (g-&gt;mnpos &gt;= GEST_MNSTACK_SIZE) return 1;

    rc = gest_monoramp(g, nbeats);

    if (rc) return rc;

    n = g-&gt;curnode;

    mn = metanode_alloc(g, n, sz);

    n-&gt;meta = mn;
    n-&gt;get = node_seq;
    mn-&gt;parent = n;

    set_curnode(g, mn-&gt;nodes[mn-&gt;pos++]);

    g-&gt;mnstack[g-&gt;mnpos++] = mn;

    return 0;
}</pre></code>

<h3>6.4. Addmetaphrase</h3>

<p><a id="wm_021_0298"></a>The function <code>gest_addmetaphrase</code> will allocate a new
phrase of arbitrary size and division
(will be unused anyways), and then allocate a new instance
of a metaphrase with <code>sz</code> phrases.
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>int gest_addmetaphrase(gest_d *g, int sz);</pre></code>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>int gest_addmetaphrase(gest_d *g, int sz)
{
    gest_metaphrase *mp;
    gest_phrase *ph;

    if (g-&gt;phrase_top == NULL) {
        fprintf(stderr, "Sorry, metaphrases can't yet be first\n");
        return 2;
    }

    if (g-&gt;mppos &gt;= GEST_MPSTACK_SIZE) return 1;


    gest_begin(g, 1, 1);

    ph = g-&gt;phrase_selected;

    mp = metaphrase_alloc(g, sz);

    ph-&gt;get = phrase_seq;
    ph-&gt;meta = mp;
    mp-&gt;parent = ph;

    g-&gt;mpstack[g-&gt;mppos++] = mp;

    return 0;
}</pre></code>

<h3>6.5. Randtarget</h3>

<p><a id="wm_021_0304"></a>The function <code>gest_randtarget</code> configures the last
metatarget to choose targets randomly.
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>int gest_randtarget(gest_d *g);</pre></code>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>int gest_randtarget(gest_d *g)
{
    gest_metatarget *mt;
    if (g-&gt;mtpos &lt;= 0) return 1;

    mt = g-&gt;mtstack[g-&gt;mtpos - 1];

    mt-&gt;parent-&gt;get = target_random;
    return 0;
}</pre></code>

<h3>6.6. Randbehavior</h3>

<p><a id="wm_021_0310"></a>The function <code>gest_randbehavior</code> configures the last
metabehavior to choose behaviors randomly.
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>int gest_randbehavior(gest_d *g);</pre></code>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>int gest_randbehavior(gest_d *g)
{
    gest_metabehavior *mb;

    if (g-&gt;mbpos &lt;= 0) return 1;

    mb = g-&gt;mbstack[g-&gt;mbpos - 1];

    mb-&gt;parent-&gt;get = behave_random;
    return 0;
}</pre></code>

<h3>6.7. Randnode</h3>

<p><a id="wm_021_0316"></a>The function <code>gest_randnode</code> configures the last
metanode to choose nodes randomly.
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>int gest_randnode(gest_d *g);</pre></code>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>int gest_randnode(gest_d *g)
{
    gest_metanode *mn;

    if (g-&gt;mnpos &lt;= 0) return 1;

    mn = g-&gt;mnstack[g-&gt;mnpos - 1];

    mn-&gt;parent-&gt;get = node_random;
    return 0;
}</pre></code>

<h3>6.8. Randphrase</h3>

<p><a id="wm_021_0322"></a>The function <code>gest_randphrase</code> configures the last
metaphrase to choose phrases randomly.
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>int gest_randphrase(gest_d *g);</pre></code>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>int gest_randphrase(gest_d *g)
{
    gest_metaphrase *mp;

    if (g-&gt;mppos &lt;= 0) return 1;

    mp = g-&gt;mpstack[g-&gt;mppos - 1];

    mp-&gt;parent-&gt;get = phrase_random;
    return 0;
}</pre></code>

<h3>6.9. Setscalar</h3>

<p><a id="wm_021_0328"></a>Binds an action to the current that assings a value
to an instant of a <code>gest_scalar</code>.
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>int gest_setscalar(gest_d *g, gest_scalar *s, SKFLT val);</pre></code>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>int gest_setscalar(gest_d *g, gest_scalar *s, SKFLT val)
{
    action_scalar(g, g-&gt;curtarget, s, val);
    return 0;
}</pre></code>

<h3>6.10. Repeat</h3>

<p><a id="wm_021_0334"></a>The command <code>gest_repeat</code> can be used to repeat a phrase
a fixed number of times before going to the next phrase.
Call this phrase after an initial phrase has been created
with <code>gest_begin</code>.
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>int gest_repeat(gest_d *g, int ntimes);</pre></code>
<p></p>
<p>The repeat function works by replacing the selected phrase's
<code>next</code> callback with a custom one, called <code>repeater</code>. There
is also special data which gets bound to the phrase's user
data slot: repeat position, and the total number of
repeats, which the <code>next</code> callback updates as a counter.
When the counter reaches the end, it resets and returns the
next phrase. Otherwise, it just returns itself.
</p>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>struct repeat_data {
    int pos;
    int reps;
};

gest_phrase *repeater(gest_d *g, gest_phrase *ph)
{
    struct repeat_data *rd;

    if (ph-&gt;ud == NULL) return ph;

    rd = (struct repeat_data *)ph-&gt;ud;
    rd-&gt;pos++;

    if (rd-&gt;pos &gt;= rd-&gt;reps) {
        rd-&gt;pos = 0;
        return ph-&gt;next;
    }

    return ph;
}

int gest_repeat(gest_d *g, int ntimes)
{
    gest_phrase *ph;
    struct repeat_data *rd;

    ph = g-&gt;phrase_selected;

    rd = gest_alloc(g, sizeof(struct repeat_data));
    rd-&gt;pos = 0;
    rd-&gt;reps = ntimes;

    ph-&gt;nextf = repeater;
    ph-&gt;ud = rd;

    return 0;
}</pre></code>

<h3>6.11. Mark</h3>

<p><a id="wm_021_0341"></a>The command <code>gest_mark</code> stores the current phrase to be
used for later. It is intended to be used with
<code>gest_return</code>.
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>int gest_mark(gest_d *g);</pre></code>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>int gest_mark(gest_d *g)
{
    g-&gt;saved = g-&gt;phrase_selected;
    return 0;
}</pre></code>

<h3>6.12. Return</h3>

<p><a id="wm_021_0347"></a>The command <code>gest_return</code> will return to a previously
marked phrase a fixed number of times before moving
on.
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>int gest_return(gest_d *g, int ntimes);</pre></code>
<p></p>
<p>It is utilized with a special <code>get</code> callback, which will
either return the saved phrase or the next phrase. The
phrase itself is otherwise completely empty and has no
duration.
</p>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>struct return_d {
    gest_phrase *ph;
    int pos;
    int ntimes;
};

static gest_phrase* goback(gest_d *g, gest_phrase *ph)
{
    struct return_d *rd;

    rd = (struct return_d *)ph-&gt;ud;

    rd-&gt;pos++;

    if (rd-&gt;pos &gt;= rd-&gt;ntimes) {
        rd-&gt;pos = 0;
        return next_phrase(g, ph);
    }

    return rd-&gt;ph;
}

int gest_return(gest_d *g, int ntimes)
{
    gest_phrase *ph;
    struct return_d *rd;

    if (g-&gt;saved == NULL) return 1;

    gest_begin(g, 0, 0);
    gest_end(g);

    rd = gest_alloc(g, sizeof(struct return_d));
    ph = g-&gt;phrase_selected;

    rd-&gt;ph = g-&gt;saved;
    rd-&gt;pos = 0;
    rd-&gt;ntimes = ntimes;

    ph-&gt;ud = rd;
    ph-&gt;get = goback;

    return 0;
}</pre></code>
<p></p>
<br>
<p><hr>

<a href="/loom/wm_021_0223">prev</a> | <a href="#">home</a> | <a href="/loom/wm_021_0354">next</a></p>
</div>
</body>
</html>
