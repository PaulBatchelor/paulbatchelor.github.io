<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/css/style.css">

</head>
<body>
<div id="main">

<h2>10. Stepping Through The Ramp Tree</h2>

<p><a id="wm_021_0503"></a>A big part of gest involves stepping through a ramp tree.
A ramp tree produces a set of normalized ramp values
from 0 to 1, whose period lengths are proportional
to the external conductor signal. These values
can then be used to interpolate between targets.
</p>
<p>The ramp tree value is computed with <code>ramptree_step</code>.
</p>
<div><b><i>&lt;&lt;static_funcdefs&gt;&gt;=</i></b></div><pre><code>static SKFLT ramptree_step(gest_d *g, SKFLT inc, int reset);</pre></code>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>static SKFLT ramptree_step(gest_d *g, SKFLT inc, int reset)
{
    SKFLT out;
    SKFLT phs;

    out = 0;

    phs = g-&gt;phs;

    if (g-&gt;phrase_selected == NULL) return phs;

&lt;&lt;beat_checkin&gt;&gt;

    inc *= g-&gt;phrase_selected-&gt;mod * g-&gt;correction;

&lt;&lt;set_the_output&gt;&gt;
&lt;&lt;update_targets&gt;&gt;
&lt;&lt;update_phase&gt;&gt;
&lt;&lt;check_and_update&gt;&gt;

    g-&gt;phs = phs;
    g-&gt;t += inc;

    return out;
}</pre></code>

<h3>10.1. Beat Check-in</h3>

<p><a id="wm_021_0519"></a>In order to combat clock drift, a phrase "checks in" every
time conductor signal resets, which is an indicator of the
new beat. Every time a new beat occurs, the status of the
phrase is figured out, and handled accordingly.
</p>
<p>Clock drift naturally occurs within Gest because it
resynthesizes a new timing signal based on the external
conductor signal. Left unchecked, Gestures will eventually
fall out of time with the conductor due to the fact that
they are marching to the beat of their own drum.
</p>
<p>The coarse way that clock drift is managed is by keeping
drift localized within the phrase. A phrase is allocated
to be a fixed number of beats. When the conductor goes
on to the next beat, the current phrase, wherever it may
be in its performance, is discarded, and the clock drift
debt is reset.
</p>
<p>Gestures are a game of constant imprecision. Their timing
can either be late or early, but never quite on time.
Early gestures occur when a
phrase finishes before the conductor. When this happens, it
is told to wait, returning 1 until the first downbeat of the
next phrase. Late
phrases don't quite make it to the end of their gesture.
When this happens, the phrase bails and jumps to the next
one. The hope is that they are close enough to prevent an
audible glitch.
</p>
<p>During the check-in, the ideal position, obtained from
the beat counter and known as the <code>goal</code>,
can be compared with the actual position <code>t</code>. These two
values can be used to create a course correction factor,
which allows the gesture to slow down or speed up to more
closely match the conductor signal.
</p>
<div><b><i>&lt;&lt;beat_checkin&gt;&gt;=</i></b></div><pre><code>if (reset) {
    int limit;
    SKFLT goal;

    limit = g-&gt;phrase_selected-&gt;beats;
    g-&gt;beat++;
    goal = (SKFLT) g-&gt;beat / limit;

    if (g-&gt;t &gt; 0) g-&gt;correction = goal / g-&gt;t;

    if (g-&gt;beat &gt;= limit) {
        g-&gt;beat = 0;
        g-&gt;t = 0;
        g-&gt;phs = 0;
        g-&gt;please_wait = 0;
        g-&gt;correction = 1.0;
        g-&gt;targetondeck = 1;
        g-&gt;phrase_selected = g-&gt;nxtstate.phrase;
        return phs;
    }
} else if (g-&gt;please_wait) {
    return 1.0;
}</pre></code>

<h3>10.2. Setting the Output</h3>

<p><a id="wm_021_0524"></a>The point of this function is to update the overall state of
the ramp trees in gest and return a corresponding ramp
value.
</p>
<p>The returned value is the computation done on the previous
call to <code>ramptree_step</code>.
</p>
<div><b><i>&lt;&lt;set_the_output&gt;&gt;=</i></b></div><pre><code>out = g-&gt;phs;</pre></code>

<h3>10.3. Updating Targets</h3>

<p><a id="wm_021_0529"></a>A set <code>targetondeck</code> flag will not only be
used to change the target, but also the state information
that comes with the target, such as the node, the phrase,
and the conductor modifier associated with the target.
</p>
<p>It is also here that the next node is found. Information
for the next node needs to be immediately available, as
certain tools using and extending gest (such as the vocal
tract interpolation work) rely on knowing about
the next target for it to work properly.
</p>
<p>It is assumed that by the time <code>targetondeck</code> is found,
the next node is already in place (presumably
from the last time targetondeck was set, or initialization),
and just needs to be swapped in.
</p>
<div><b><i>&lt;&lt;update_targets&gt;&gt;=</i></b></div><pre><code>if (g-&gt;targetondeck) {
    gest_state *s;
    int shouldiwait;

    s = &g-&gt;nxtstate;

    g-&gt;targetondeck = 0;

    /* non-matching non-NULL phrases indicate
     * a new phrase */
    shouldiwait =
        s-&gt;phrase != NULL &&
        s-&gt;phrase != g-&gt;phrase_selected;

    if (shouldiwait) {
        g-&gt;please_wait = 1;
        return 1.0;
    }

    g-&gt;num = s-&gt;num;
    g-&gt;den = s-&gt;den;
    s-&gt;target-&gt;curbehavior = s-&gt;behavior;
    set_curtarget(g, s-&gt;target);

    set_curnode(g, s-&gt;node);
    g-&gt;phrase_selected = s-&gt;phrase;

    init_state(&g-&gt;nxtstate);

    if (g-&gt;curnode != NULL) {
        find_next_node(g, g-&gt;curnode, &g-&gt;nxtstate);
    }

    g-&gt;nxttarget = g-&gt;nxtstate.target;

    if (g-&gt;nxttarget != NULL) {
        g-&gt;nxtval = g-&gt;nxttarget-&gt;value;
    } else {
        g-&gt;nxtval = g-&gt;curval;
    }
}</pre></code>
<p></p>
<p>What triggers <code>targetondeck</code>? Usually this happens when the
internal ramp reaches the end. This can also be triggered
during the beat check-in, when a conductor signal demands
to jump to the next phrase before fully finishing the
current one.
</p>

<h3>10.4. Updating the phase using modifier and friends</h3>

<p><a id="wm_021_0535"></a>To begin, the modifier amount is calculated.
</p>
<p>The modifier and increment amount are used together to
update the existing phase.
</p>
<div><b><i>&lt;&lt;update_phase&gt;&gt;=</i></b></div><pre><code>{
SKFLT i;
i = inc * ((SKFLT)g-&gt;num / g-&gt;den);
phs += i;
}</pre></code>
<p></p>
<p>The phase is then checked to see if it has exceeded 1.
If it has, a change in nodes is required.
</p>
<div><b><i>&lt;&lt;check_and_update&gt;&gt;=</i></b></div><pre><code>if (phs &gt; 1.0) {
&lt;&lt;goto_next_node&gt;&gt;
&lt;&lt;wraparound&gt;&gt;
}</pre></code>

<h3>10.5. Signalling to go to the next target</h3>

<p><a id="wm_021_0548"></a>When the ramp reaches the end, it is time to go on to the
next node with a target. By the time it reaches this point,
this node has already been found, and just needs to be
signalled to switch with the variable <code>targetondeck</code>.
</p>
<div><b><i>&lt;&lt;goto_next_node&gt;&gt;=</i></b></div><pre><code>g-&gt;targetondeck = 1;</pre></code>

<h3>10.6. Finding the next node in the Ramp Tree</h3>

<p><a id="wm_021_0553"></a>When a new node begins, the next with a target
in the ramp tree must be found immediately after.
Many programs using Gest require knowing the next target.
</p>
<p>The next node is found by traversing the Ramp
Tree based on the position the current node is in.
</p>
<p>The process of finding the next node is done in a function
called <code>find_next_node</code>. It will find the next node, and
store the results in an instance of <code>gest_state</code>. The
<code>top</code> node is expected to be the currently selected node
<code>curnode</code>.
</p>
<div><b><i>&lt;&lt;static_funcdefs&gt;&gt;=</i></b></div><pre><code>static void find_next_node(gest_d *g,
                           gest_node *top,
                           gest_state *state);</pre></code>
<p></p>
<p>Traversal starts large and gets smaller.
</p>
<p>To begin, check and see if the next node happens to be in
the next phrase. That would mean the currently selected
node is the right-most node (no nodes after it)
in the top of the tree. If this is true, it is time to
<b>wait</b> for the next phrase on the next down beat. If the
next phrase is being found here, it has arrived a tad too
early (which is actually better than being a
tad too late, as it turns out. It's one or the other here).
</p>
<p>If it's not the top of the tree, there is a general check
to see if the current node is the right-most node relative
to the position in the tree. If so, the node reverts the
global modification it did, and goes up one level to the
parent node to check the next node there.
</p>
<p>Finally, the next node is found, and the program recursively
dives into it to find the next target, applying modifiers
along the way. Before that happens, the current node <b>may</b>need to revert the global modifier if it is a monoramp
with a modifier greater than 1.
</p>
<p>If the next node happens to be a monoramp with a modifier
greater than 1, it will also apply modifications. But should
be handled inside of <code>dive_to_target</code>. If the node is already
a target with a monoramp >1, this gets applied here as a
special exception.
</p>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>static void find_next_node(gest_d *g,
                           gest_node *top,
                           gest_state *state)
{
    gest_node *next;
    gest_node *last_reverted;
    gest_phrase *phrase;
    int num, den;

    next = NULL;
    last_reverted = NULL;

    num = g-&gt;num;
    den = g-&gt;den;
    phrase = g-&gt;phrase_selected;

    while (next == NULL) {
        if (top == g-&gt;phrase_selected-&gt;top) {
            /* are we at the end */
            /* if so, go to next phrase */
            if (top-&gt;next == NULL) {
                /* next node is in next phrase */
                phrase = phrase-&gt;next;
                if (phrase != NULL) next = phrase-&gt;top;
                else next = NULL;
                g-&gt;num = 1;
                g-&gt;den = 1;
                if (next != NULL) {
                   next = dive_to_target(g, next);
                }
                break;
            } else {
                /* go to next child in top polyramp node */
                next = top-&gt;next;

                if (next-&gt;target == NULL) {
                    next = dive_to_target(g, next);
                }
            }
        } else if (top-&gt;next == NULL) {
            revert_modifier(g, top-&gt;parent);
            last_reverted = top-&gt;parent;
            top = top-&gt;parent;
        } else {
            next = top-&gt;next;

            /* if top is a monoramp &gt;1, revert it */

            if (top != last_reverted) {
                if (top-&gt;type == NODE_MONORAMP && top-&gt;modifier &gt; 1) {
                    /* revert the monoramp */
                    revert_modifier(g, top);
                }
            }

            /* dive_to_target applies modifiers */
            /* continguous nodes on the same level don't have these */
            if (next-&gt;target == NULL) {
                next = dive_to_target(g, next);
            } else if (next-&gt;type == NODE_MONORAMP && next-&gt;modifier &gt; 1) {
                /* next node is on same level but is monoramp */
                apply_modifier(g, next);
            }

        }
    }


    state-&gt;num = g-&gt;num;
    state-&gt;den = g-&gt;den;
    state-&gt;node = next;
    state-&gt;target = node_target(next);
    state-&gt;behavior = target_behavior(state-&gt;target);
    state-&gt;phrase = phrase;

    /* restore old numerator and denominator */

    g-&gt;num = num;
    g-&gt;den = den;
}</pre></code>

<h3>10.7. When a phrase is over, wraparound</h3>

<p><a id="wm_021_0560"></a>A phrase is considered over when it reaches the end of the
top-level polyramp. At this point, the next phrase is found
and set to be the beginning of that node.
</p>
<p>All ramps begin exactly at 0. When wraparound happens,
the roundoff error is stored in the error variable.
</p>
<div><b><i>&lt;&lt;wraparound&gt;&gt;=</i></b></div><pre><code>while (phs &gt; 1) phs--;
phs = 0;</pre></code>

<h3>10.8. Handling Roundoff Error in Phrases</h3>

<p><a id="wm_021_0565"></a>Roundoff error is a natural part of working with floating
point, and difficult to avoid entirely. Roundoff error
in this context leads to temporal drift in the timing
signal. Unchecked, this will eventually lead to phrases
being completly out of step with the rest of the music
surrounding it.
</p>
<p>Chunking gestures into phrases helps thwart some of the
major drift buildup that can occur over time. Phrases
ensure that any drift is localized, which, if the phrases
are small enough, should be quite negligible for most
musical purposes.
</p>
<p>The Ramp Tree in a phrase applies many manipulations to a
phasor signal, and this can cause phrases to either finish
too quickly or too slowly. If choosing one or the other,
finishing too quickly is always the preference.
</p>
<p>If a phrase ends before the conductor does, it is told to
wait. While waiting, it will only return 1 without updating
any state. When the conductor finally does catch up, the
phrase will be granted permission to move on to the next
phrase.
</p>
<p>Every time the phasor in a conductor signal resets (wraps
back), it registered as a new beat. This beat gives gest
an opportunity to "check in" with itself. Is it going ahead
of schedule? Behind? And then, try to make the appropriate
corrections.
</p>
<p>The progress of a phrase is kept inside of a monoramp that
spans the duration of the phrase, and the beat position is
kept track of as a sort of counter. A new beat indicates the
ideal time position, which can be compared against the the
actual position in the progress monoramp.
</p>
<p>Dividing the ideal position and actual position gives us
a correction factor that slightly speeds up or slows down
the phasor within the beat. If the ideal is a bit farther
along, the correction factor will be a value greater than 1
that runs to catch up. If the ideal is a bit behind, the
factor will be less than 1, and will hold things back until
the next beat.
</p>
<p>With any luck, the phrase will end just slightly before
the conductor, allowing it to wait for the next signal.
This happens when the monoramp exceeds 1 and/or the ramp
tree hits the end of the phrase. At any rate, a flag is set.
</p>
<p>There can also be cases where the phrase is too slow.
Hopefully, it is fast enough to be wrapping up the last
target in the ramp tree. This is detected when a beat
happens that is past the duration of the phrase. When
this happens, the phrase is reset early, and caution
is scattered to the wind. It's not an ideal situation, as
this has the potential to create an audible glitch in the
gesture.
</p>
<br>
<p><hr>

<a href="/loom/wm_021_0364">prev</a> | <a href="#">home</a> | <a href="/loom/wm_021_0567">next</a></p>
</div>
</body>
</html>
