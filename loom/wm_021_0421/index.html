<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/css/style.css">

</head>
<body>
<div id="main">

<h2>10. Stepping Through The Ramp Tree</h2>

<p><a id="wm_021_0421"></a>A big part of gest involves stepping through a ramp tree.
A ramp tree produces a set of normalized ramp values
from 0 to 1, whose period lengths are proportional
to the external conductor signal. These values
can then be used to interpolate between targets.
</p>
<p>The ramp tree value is computed with <code>ramptree_step</code>.
</p>
<div><b><i>&lt;&lt;static_funcdefs&gt;&gt;=</i></b></div><pre><code>static SKFLT ramptree_step(gest_d *g, SKFLT inc, int reset);</pre></code>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>static SKFLT ramptree_step(gest_d *g, SKFLT inc, int reset)
{
    SKFLT out;
    SKFLT phs;

    out = 0;

    phs = g-&gt;phs;

    if (g-&gt;phrase_selected == NULL) return phs;

&lt;&lt;beat_checkin&gt;&gt;

    inc *= g-&gt;phrase_selected-&gt;mod * g-&gt;correction;

&lt;&lt;set_the_output&gt;&gt;
&lt;&lt;update_targets&gt;&gt;
&lt;&lt;update_phase&gt;&gt;
&lt;&lt;check_and_update&gt;&gt;

    g-&gt;phs = phs;
    g-&gt;t += inc;

    return out;
}</pre></code>

<h3>10.1. Beat Check-in</h3>

<p><a id="wm_021_0437"></a>In order to combat clock drift, a phrase "checks in" every
time conductor signal resets, which is an indicator of the
new beat. Every time a new beat occurs, the status of the
phrase is figured out, and handled accordingly.
</p>
<p>Clock drift naturally occurs within Gest because it
resynthesizes a new timing signal based on the external
conductor signal. Left unchecked, Gestures will eventually
fall out of time with the conductor due to the fact that
they are marching to the beat of their own drum.
</p>
<p>The coarse way that clock drift is managed is by keeping
drift localized within the phrase. A phrase is allocated
to be a fixed number of beats. When the conductor goes
on to the next beat, the current phrase, wherever it may
be in its performance, is discarded, and the clock drift
debt is reset.
</p>
<p>Gestures are a game of constant imprecision. Their timing
can either be late or early, but never quite on time.
Early gestures occur when a
phrase finishes before the conductor. When this happens, it
is told to wait, returning 1 until the first downbeat of the
next phrase. Late
phrases don't quite make it to the end of their gesture.
When this happens, the phrase bails and jumps to the next
one. The hope is that they are close enough to prevent an
audible glitch.
</p>
<p>During the check-in, the ideal position, obtained from
the beat counter and known as the <code>goal</code>,
can be compared with the actual position <code>t</code>. These two
values can be used to create a course correction factor,
which allows the gesture to slow down or speed up to more
closely match the conductor signal.
</p>
<div><b><i>&lt;&lt;beat_checkin&gt;&gt;=</i></b></div><pre><code>if (reset) {
    int limit;
    SKFLT goal;

    limit = g-&gt;phrase_selected-&gt;top-&gt;modifier;
    g-&gt;beat++;
    goal = (SKFLT) g-&gt;beat / limit;

    if (g-&gt;t &gt; 0) g-&gt;correction = goal / g-&gt;t;

    if (g-&gt;beat &gt;= limit) {
        gest_node *next;

        g-&gt;phrase_selected = g-&gt;phrase_selected-&gt;next;

        g-&gt;beat = 0;
        g-&gt;t = 0;
        g-&gt;phs = 0;
        g-&gt;please_wait = 0;
        g-&gt;correction = 1.0;

        if (g-&gt;phrase_selected == NULL) {
            return phs;
        }

        next = g-&gt;phrase_selected-&gt;top;
        /* reset modifier */
        g-&gt;num = 1;
        g-&gt;den = 1;
        next = dive_to_target(g, next);
        set_nxttarget(g, next-&gt;target);
        set_curnode(g, next);
        return phs;
    }
} else if (g-&gt;please_wait) {
    return 1.0;
}</pre></code>

<h3>10.2. Setting the Output</h3>

<p><a id="wm_021_0442"></a>The point of this function is to update the overall state of
the ramp trees in gest and return a corresponding ramp
value.
</p>
<p>The returned value is the computation done on the previous
call to <code>ramptree_step</code>.
</p>
<div><b><i>&lt;&lt;set_the_output&gt;&gt;=</i></b></div><pre><code>out = g-&gt;phs;</pre></code>

<h3>10.3. Updating Targets</h3>

<p><a id="wm_021_0447"></a>If any targets were slotted to be updated in the previous
call, update them now, then clear the flag.
</p>
<div><b><i>&lt;&lt;update_targets&gt;&gt;=</i></b></div><pre><code>if (g-&gt;targetondeck) {
    g-&gt;targetondeck = 0;
    set_curtarget(g, g-&gt;nxttarget);
    g-&gt;nxttarget = NULL;
}</pre></code>

<h3>10.4. Updating the phase using modifier and friends</h3>

<p><a id="wm_021_0452"></a>To begin, the modifier amount is calculated.
</p>
<p>The modifier and increment amount are used together to
update the existing phase.
</p>
<div><b><i>&lt;&lt;update_phase&gt;&gt;=</i></b></div><pre><code>{
SKFLT i;
i = inc * ((SKFLT)g-&gt;num / g-&gt;den);
phs += i;
}</pre></code>
<p></p>
<p>The phase is then checked to see if it has exceeded 1.
If it has, a change in nodes is required.
</p>
<div><b><i>&lt;&lt;check_and_update&gt;&gt;=</i></b></div><pre><code>if (phs &gt; 1.0) {
&lt;&lt;find_next_node&gt;&gt;
&lt;&lt;wraparound&gt;&gt;
}</pre></code>

<h3>10.5. Finding the Next Node</h3>

<p><a id="wm_021_0465"></a>When the ramp reaches the end, it is time to find the next
node with a target. It does this by traversing the Ramp
Tree based on the position the current node is in.
</p>
<p>Traversal starts large and gets smaller.
</p>
<p>To begin, check and see if the next node happens to be in
the next phrase. That would mean the currently selected
node is the right-most node (no nodes after it)
in the top of the tree. If this is true, it is time to
<b>wait</b> for the next phrase on the next down beat. If the
next phrase is being found here, it has arrived a tad too
early (which is actually better than being a
tad too late, as it turns out. It's one or the other here).
</p>
<p>If it's not the top of the tree, there is a general check
to see if the current node is the right-most node relative
to the position in the tree. If so, the node reverts the
global modification it did, and goes up one level to the
parent node to check the next node there.
</p>
<p>Finally, the next node is found, and the program recursively
dives into it to find the next target, applying modifiers
along the way. Before that happens, the current node <b>may</b>need to revert the global modifier if it is a monoramp
with a modifier greater than 1.
</p>
<p>If the next node happens to be a monoramp with a modifier
greater than 1, it will also apply modifications. But should
be handled inside of <code>dive_to_target</code>. If the node is already
a target with a monoramp >1, this gets applied here as a
special exception.
</p>
<div><b><i>&lt;&lt;find_next_node&gt;&gt;=</i></b></div><pre><code>gest_node *next;
gest_node *top;
gest_node *last_reverted;

next = NULL;
last_reverted = NULL;

/* maybe there needs to be a curchild? */
/* or, maybe the top gets derived from the parent node */
top = g-&gt;curnode;
while (next == NULL) {
    if (top == g-&gt;phrase_selected-&gt;top) {
        /* are we at the end */
        /* if so, go to next phrase */
        if (top-&gt;next == NULL) {
            /* wait for the downbeat of the next phrase */
            g-&gt;please_wait = 1;
            break;
        } else {
            /* go to next child in top polyramp node */
            next = top-&gt;next;

            if (next-&gt;target == NULL) {
                next = dive_to_target(g, next);
            }

            set_nxttarget(g, next-&gt;target);
        }
    } else if (top-&gt;next == NULL) {
        revert_modifier(g, top-&gt;parent);
        last_reverted = top-&gt;parent;
        top = top-&gt;parent;
    } else {
        next = top-&gt;next;

        /* if top is a monoramp &gt;1, revert it */

        if (top != last_reverted) {
            if (top-&gt;type == NODE_MONORAMP && top-&gt;modifier &gt; 1) {
                /* revert the monoramp */
                revert_modifier(g, top);
            }
        }

        /* dive_to_target applies modifiers */
        /* continguous nodes on the same level don't have these */
        if (next-&gt;target == NULL) {
            next = dive_to_target(g, next);
        } else if (next-&gt;type == NODE_MONORAMP && next-&gt;modifier &gt; 1) {
            /* next node is on same level but is monoramp */
            apply_modifier(g, next);
        }

        set_nxttarget(g, next-&gt;target);
    }
}

set_curnode(g, next);</pre></code>
<p></p>
<p>A phrase is considered over when it reaches the end of the
top-level polyramp. At this point, the next phrase is found
and set to be the beginning of that node.
</p>
<p>All ramps begin exactly at 0. When wraparound happens,
the roundoff error is stored in the error variable.
</p>
<div><b><i>&lt;&lt;wraparound&gt;&gt;=</i></b></div><pre><code>while (phs &gt; 1) phs--;
phs = 0;</pre></code>

<h3>10.6. Handling Roundoff Error in Phrases</h3>

<p><a id="wm_021_0474"></a>Roundoff error is a natural part of working with floating
point, and difficult to avoid entirely. Roundoff error
in this context leads to temporal drift in the timing
signal. Unchecked, this will eventually lead to phrases
being completly out of step with the rest of the music
surrounding it.
</p>
<p>Chunking gestures into phrases helps thwart some of the
major drift buildup that can occur over time. Phrases
ensure that any drift is localized, which, if the phrases
are small enough, should be quite negligible for most
musical purposes.
</p>
<p>The Ramp Tree in a phrase applies many manipulations to a
phasor signal, and this can cause phrases to either finish
too quickly or too slowly. If choosing one or the other,
finishing too quickly is always the preference.
</p>
<p>If a phrase ends before the conductor does, it is told to
wait. While waiting, it will only return 1 without updating
any state. When the conductor finally does catch up, the
phrase will be granted permission to move on to the next
phrase.
</p>
<p>Every time the phasor in a conductor signal resets (wraps
back), it registered as a new beat. This beat gives gest
an opportunity to "check in" with itself. Is it going ahead
of schedule? Behind? And then, try to make the appropriate
corrections.
</p>
<p>The progress of a phrase is kept inside of a monoramp that
spans the duration of the phrase, and the beat position is
kept track of as a sort of counter. A new beat indicates the
ideal time position, which can be compared against the the
actual position in the progress monoramp.
</p>
<p>Dividing the ideal position and actual position gives us
a correction factor that slightly speeds up or slows down
the phasor within the beat. If the ideal is a bit farther
along, the correction factor will be a value greater than 1
that runs to catch up. If the ideal is a bit behind, the
factor will be less than 1, and will hold things back until
the next beat.
</p>
<p>With any luck, the phrase will end just slightly before
the conductor, allowing it to wait for the next signal.
This happens when the monoramp exceeds 1 and/or the ramp
tree hits the end of the phrase. At any rate, a flag is set.
</p>
<p>There can also be cases where the phrase is too slow.
Hopefully, it is fast enough to be wrapping up the last
target in the ramp tree. This is detected when a beat
happens that is past the duration of the phrase. When
this happens, the phrase is reset early, and caution
is scattered to the wind. It's not an ideal situation, as
this has the potential to create an audible glitch in the
gesture.
</p>
<br>
<p><hr>

<a href="/loom/wm_021_0306">prev</a> | <a href="#">home</a> | <a href="/loom/wm_021_0476">next</a></p>
</div>
</body>
</html>
