<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<link rel="stylesheet" href="/css/style.css">

</head>
<body>
<div id="main">

<h3>27. H264 Video Support</h3>

<p><a id="wm_000_3189"></a>The H264 is a remarkable video codec used to create
high-quality videos with in a very small amount of disk
space. Using the x264 library, one can easily encode video
directly instead of writing a sequence of PNG files.
</p>

<h4>27.1. x264 system include</h4>

<p><a id="wm_000_3191"></a>This will only be included if the <code>MONOLITH_H264</code> macro is
defined.
<div><b><i>&lt;&lt;system_includes&gt;&gt;=</i></b></div><pre><code>#ifdef MONOLITH_H264
#include &lt;x264.h&gt;
#endif</pre></code>

<h4>27.2. h264 top level constructs</h4>

<p><a id="wm_000_3195"></a>Because all video encoder functions are all congregated
inside of an org-mode block called
<code>h264_function_declarations</code>, where they are enclosed inside
of a macro ifdef.
<div><b><i>&lt;&lt;gfx_function_declarations&gt;&gt;=</i></b></div><pre><code>#ifdef MONOLITH_H264
&lt;&lt;h264_function_declarations&gt;&gt;
#endif</pre></code>
<div><b><i>&lt;&lt;gfx_static_function_declarations&gt;&gt;=</i></b></div><pre><code>#ifdef MONOLITH_H264
&lt;&lt;h264_static_function_declarations&gt;&gt;
#endif</pre></code>
<div><b><i>&lt;&lt;gfx_functions&gt;&gt;=</i></b></div><pre><code>#ifdef MONOLITH_H264
&lt;&lt;h264_functions&gt;&gt;
#endif</pre></code>
<div><b><i>&lt;&lt;gfx_scheme_functions&gt;&gt;=</i></b></div><pre><code>#ifdef MONOLITH_H264
&lt;&lt;h264_scheme_functions&gt;&gt;
#endif</pre></code>
<div><b><i>&lt;&lt;gfx_scheme_entries&gt;&gt;=</i></b></div><pre><code>#ifdef MONOLITH_H264
&lt;&lt;h264_scheme_entries&gt;&gt;
#endif</pre></code>
<div><b><i>&lt;&lt;gfx_janet&gt;&gt;=</i></b></div><pre><code>#ifdef MONOLITH_H264
&lt;&lt;h264_janet_functions&gt;&gt;
#endif</pre></code>
<div><b><i>&lt;&lt;gfx_janet_entries&gt;&gt;=</i></b></div><pre><code>#ifdef MONOLITH_H264
&lt;&lt;h264_janet_entries&gt;&gt;
#endif</pre></code>

<h4>27.3. h264 top-level struct declaration</h4>

<p><a id="wm_000_3225"></a></p>

<h5>27.3.1. DONE h264 struct entry</h5>

<p><a id="wm_000_3226"></a>CLOSED: [2019-05-30 Thu 19:37]
<div><b><i>&lt;&lt;struct_contents&gt;&gt;=</i></b></div><pre><code>#ifdef MONOLITH_H264
monolith_h264 vid;
#endif</pre></code>

<h5>27.3.2. h264 struct init/cleanup</h5>

<p><a id="wm_000_3230"></a><div><b><i>&lt;&lt;init&gt;&gt;=</i></b></div><pre><code>#ifdef MONOLITH_H264
monolith_h264_init(&m-&gt;vid);
#endif</pre></code>
<div><b><i>&lt;&lt;cleanup&gt;&gt;=</i></b></div><pre><code>#ifdef MONOLITH_H264
monolith_h264_clean(&m-&gt;vid);
#endif</pre></code>

<h5>27.3.3. h264 struct retrieval</h5>

<p><a id="wm_000_3235"></a><div><b><i>&lt;&lt;h264_function_declarations&gt;&gt;=</i></b></div><pre><code>monolith_h264 *monolith_h264_get(monolith_d *m);</pre></code>
<div><b><i>&lt;&lt;h264_functions&gt;&gt;=</i></b></div><pre><code>monolith_h264 *monolith_h264_get(monolith_d *m)
{
    return &m-&gt;vid;
}</pre></code>

<h4>27.4. h264 video struct</h4>

<p><a id="wm_000_3242"></a><div><b><i>&lt;&lt;gfx_typedefs&gt;&gt;=</i></b></div><pre><code>#ifdef MONOLITH_H264
typedef struct monolith_h264 monolith_h264;
#endif</pre></code>
<div><b><i>&lt;&lt;gfx_structs&gt;&gt;=</i></b></div><pre><code>#ifdef MONOLITH_H264
struct monolith_h264 {
    x264_param_t param;
    x264_picture_t pic;
    x264_picture_t pic_out;
    x264_t *h;
    int i_frame;
    x264_nal_t *nal;
    int i_nal;
    FILE *fp;
};
#endif</pre></code>

<h4>27.5. h264 video initialization</h4>

<p><a id="wm_000_3247"></a><div><b><i>&lt;&lt;h264_function_declarations&gt;&gt;=</i></b></div><pre><code>void monolith_h264_init(monolith_h264 *vid);</pre></code>
<div><b><i>&lt;&lt;h264_functions&gt;&gt;=</i></b></div><pre><code>void monolith_h264_init(monolith_h264 *vid)
{
    memset(vid, 0, sizeof(monolith_h264));
}</pre></code>

<h4>27.6. h264 video cleanup</h4>

<p><a id="wm_000_3252"></a><div><b><i>&lt;&lt;h264_function_declarations&gt;&gt;=</i></b></div><pre><code>void monolith_h264_clean(monolith_h264 *vid);</pre></code>
<div><b><i>&lt;&lt;h264_functions&gt;&gt;=</i></b></div><pre><code>void monolith_h264_clean(monolith_h264 *vid)
{
    monolith_h264_end(vid);
}</pre></code>

<h4>27.7. h264 video interface</h4>

<p><a id="wm_000_3257"></a></p>

<h5>27.7.1. begin</h5>

<p><a id="wm_000_3258"></a></p>

<h6>27.7.1.1. begin in C</h6>

<p><a id="wm_000_3259"></a>CLOSED: [2019-05-29 Wed 19:59]
Begins a video. Opens the file. Gets FPS. Will return 0
on failure.
<div><b><i>&lt;&lt;h264_function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_h264_begin(monolith_h264 *vid,
                        monolith_framebuffer *fb,
                        const char *filename,
                        int fps);</pre></code>
<div><b><i>&lt;&lt;h264_functions&gt;&gt;=</i></b></div><pre><code>int monolith_h264_begin(monolith_h264 *vid,
                        monolith_framebuffer *fb,
                        const char *filename,
                        int fps)
{
    x264_param_t *p;

    p = &vid-&gt;param;
    vid-&gt;fp = fopen(filename, "w");

    if(vid-&gt;fp == NULL) return 0;

    vid-&gt;i_frame = 0;

    if(x264_param_default_preset(p, "slow", NULL) &lt; 0)
        return 0;

    p-&gt;i_csp = X264_CSP_I444;
    p-&gt;i_width  = fb-&gt;w * fb-&gt;zoom;
    p-&gt;i_height = fb-&gt;h * fb-&gt;zoom;
    p-&gt;b_vfr_input = 0;
    p-&gt;b_repeat_headers = 1;
    p-&gt;b_annexb = 1;
    p-&gt;i_fps_num = fps;
    /* p-&gt;rc.f_aq_strength = 1.0; */
    p-&gt;rc.f_aq_strength = 0.1;
    p-&gt;rc.i_aq_mode= 1;
    p-&gt;i_log_level = X264_LOG_NONE;

    if(x264_param_apply_profile(p, "high444") &lt; 0 ) {
        return 0;
    }

    if(x264_picture_alloc(&vid-&gt;pic,
                          p-&gt;i_csp,
                          p-&gt;i_width,
                          p-&gt;i_height) &lt; 0 ) {
        return 0;
    }

    vid-&gt;h = x264_encoder_open(p);
    if(!vid-&gt;h) return 0;

    return 1;
}</pre></code>

<h6>27.7.1.2. begin in scheme</h6>

<p><a id="wm_000_3265"></a><div><b><i>&lt;&lt;h264_scheme_entries&gt;&gt;=</i></b></div><pre><code>{"monolith:h264-begin", pp_h264_begin, 2, 2, {STR,INT,___}},</pre></code>
<div><b><i>&lt;&lt;h264_scheme_functions&gt;&gt;=</i></b></div><pre><code>static cell pp_h264_begin(cell p)
{
    int fps;
    const char *filename;
    monolith_d *m;
    monolith_h264 *vid;
    monolith_framebuffer *fb;
    char *name = "monolith:gfx-setsize";

    filename = string(car(p));
    p = cdr(p);
    fps = integer_value(name, car(p));

    m = monolith_data_get();
    fb = monolith_fb_get(m);
    vid = monolith_h264_get(m);

    if(fb != NULL) {
        monolith_h264_begin(vid, fb, filename, fps);
    }
    return UNSPECIFIC;
}</pre></code>

<h6>27.7.1.3. begin in janet</h6>

<p><a id="wm_000_3272"></a><div><b><i>&lt;&lt;h264_janet_functions&gt;&gt;=</i></b></div><pre><code>static Janet j_h264_begin(int32_t argc, Janet *argv)
{
    int fps;
    const char *filename;
    monolith_d *m;
    monolith_h264 *vid;
    monolith_framebuffer *fb;

    janet_fixarity(argc, 2);

    filename = (const char *)janet_unwrap_string(argv[0]);
    fps = janet_unwrap_integer(argv[1]);

    m = monolith_data_get();
    fb = monolith_fb_get(m);
    vid = monolith_h264_get(m);

    if(fb != NULL) {
        monolith_h264_begin(vid, fb, filename, fps);
    }

    return janet_wrap_nil();
}</pre></code>
<div><b><i>&lt;&lt;h264_janet_entries&gt;&gt;=</i></b></div><pre><code>{
"monolith/h264-begin",
j_h264_begin,
"begin h264 video."
},</pre></code>

<h5>27.7.2. append</h5>

<p><a id="wm_000_3279"></a>Appends current gfx framebuffer as new frame. This one
requires the most code on our end because RGB buffer needs
to be converted to a YUV frame. The components are laid out
below.
</p>

<h6>27.7.2.1. rgb2yuv</h6>

<p><a id="wm_000_3281"></a>The static function <code>rgb2yuv</code> will take in a single RGB
triplet and return a YUV triplet
</p>
<br>
<p>source: <a href="https://www.fourcc.org/fccyvrgb.php">https://www.fourcc.org/fccyvrgb.php</a></p>
<br>
<div><b><i>&lt;&lt;h264_static_function_declarations&gt;&gt;=</i></b></div><pre><code>static void rgb2yuv(uint8_t r, uint8_t g, uint8_t b,
                    uint8_t *y, uint8_t *u, uint8_t *v);</pre></code>
<div><b><i>&lt;&lt;h264_functions&gt;&gt;=</i></b></div><pre><code>static void rgb2yuv(uint8_t r, uint8_t g, uint8_t b,
                    uint8_t *y, uint8_t *u, uint8_t *v)
{
    double Ey;
    double Ecr;
    double Ecb;
    double norm;

    norm = 1.0/255;

    Ey = (0.299*r + 0.587*g + 0.114*b)*norm;
    Ecr = 0.713 * (r*norm - Ey);
    Ecb = 0.564 * (b*norm - Ey);


    *y = Ey * 255;
    *u = (0.5 + Ecb) * 255;
    *v = (0.5 + Ecr) * 255;
}</pre></code>

<h6>27.7.2.2. mkyuv</h6>

<p><a id="wm_000_3288"></a>The <code>mkyuv</code> static function will create a YUV frame from
a GFX framebuffer, and store it in separate YUV buffers.
The encoding used for the video is IC420, which means the
Y buffer is full resolution, while the U and V components
subsamped to be at quarter resolution.
<div><b><i>&lt;&lt;h264_static_function_declarations&gt;&gt;=</i></b></div><pre><code>static void mkyuv(monolith_framebuffer *fb,
                  uint8_t *ybuf,
                  uint8_t *ubuf,
                  uint8_t *vbuf);</pre></code>
<div><b><i>&lt;&lt;h264_functions&gt;&gt;=</i></b></div><pre><code>static void mkyuv(monolith_framebuffer *fb,
                  uint8_t *ybuf,
                  uint8_t *ubuf,
                  uint8_t *vbuf)
{
    unsigned int x, y;
    unsigned int pos;
    monolith_pixel *p;
    uint8_t yv, uv, vv;
    monolith_pixel *pix;
    unsigned int w, h;

    pix = fb-&gt;pix;
    w = fb-&gt;w;
    h = fb-&gt;h;

    if (fb-&gt;zoom &gt; 1 && fb-&gt;zoom_buf != NULL) {
        zbuf_rescale(fb-&gt;pix, fb-&gt;zoom_buf,
                     fb-&gt;w, fb-&gt;h,
                     fb-&gt;zoom);
        pix = fb-&gt;zoom_buf;
        w *= fb-&gt;zoom;
        h *= fb-&gt;zoom;
    }

    pos = 0;

    for (y = 0; y &lt; h; y++) {
        for (x = 0; x &lt; w; x++) {
            p = &pix[y * w + x];
            rgb2yuv(p-&gt;r, p-&gt;g, p-&gt;b, &yv, &uv, &vv);
            ybuf[pos] = yv;
            ubuf[pos] = uv;
            vbuf[pos] = vv;
            pos++;
        }
    }
}</pre></code>

<h6>27.7.2.3. append in C</h6>

<p><a id="wm_000_3294"></a><div><b><i>&lt;&lt;h264_function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_h264_append(monolith_h264 *vid,
                         monolith_framebuffer *fb);</pre></code>
<div><b><i>&lt;&lt;h264_functions&gt;&gt;=</i></b></div><pre><code>int monolith_h264_append(monolith_h264 *vid,
                         monolith_framebuffer *fb)
{
    int i_frame_size;

    if(vid-&gt;fp == NULL) return 0;
    if(vid-&gt;h == NULL) return 0;

    mkyuv(fb,
          vid-&gt;pic.img.plane[0],
          vid-&gt;pic.img.plane[1],
          vid-&gt;pic.img.plane[2]);

    vid-&gt;pic.i_pts = vid-&gt;i_frame;

    vid-&gt;i_frame++;

    i_frame_size = x264_encoder_encode(vid-&gt;h,
                                       &vid-&gt;nal,
                                       &vid-&gt;i_nal,
                                       &vid-&gt;pic,
                                       &vid-&gt;pic_out);

    if(i_frame_size &lt; 0) return 0;
    else if(i_frame_size) {
        fwrite(vid-&gt;nal-&gt;p_payload,
               i_frame_size,
               1,
               vid-&gt;fp);
    }

    return 1;
}</pre></code>

<h6>27.7.2.4. append in scheme</h6>

<p><a id="wm_000_3299"></a><div><b><i>&lt;&lt;h264_scheme_entries&gt;&gt;=</i></b></div><pre><code>{"monolith:h264-append", pp_h264_append, 0, 0, {___,___,___}},</pre></code>
<div><b><i>&lt;&lt;h264_scheme_functions&gt;&gt;=</i></b></div><pre><code>static cell pp_h264_append(cell p)
{
    monolith_d *m;
    monolith_h264 *vid;
    monolith_framebuffer *fb;

    m = monolith_data_get();
    fb = monolith_fb_get(m);
    vid = monolith_h264_get(m);

    if(fb != NULL) {
        monolith_h264_append(vid, fb);
    }

    return UNSPECIFIC;
}</pre></code>

<h6>27.7.2.5. append in janet</h6>

<p><a id="wm_000_3304"></a><div><b><i>&lt;&lt;h264_janet_functions&gt;&gt;=</i></b></div><pre><code>static Janet j_h264_append(int32_t argc, Janet *argv)
{
    monolith_d *m;
    monolith_h264 *vid;
    monolith_framebuffer *fb;

    janet_fixarity(argc, 0);

    m = monolith_data_get();
    fb = monolith_fb_get(m);
    vid = monolith_h264_get(m);

    monolith_h264_append(vid, fb);

    return janet_wrap_nil();
}</pre></code>
<div><b><i>&lt;&lt;h264_janet_entries&gt;&gt;=</i></b></div><pre><code>{
"monolith/h264-append",
j_h264_append,
"h264 frame."
},</pre></code>

<h5>27.7.3. end</h5>

<p><a id="wm_000_3309"></a></p>

<h6>27.7.3.1. end in C</h6>

<p><a id="wm_000_3310"></a>CLOSED: [2019-05-29 Wed 19:59]
Writes remaining frames. Closes file. Cleans up x264.
This is also called at cleanup in case some things
are not fully cleaned up.
<div><b><i>&lt;&lt;h264_function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_h264_end(monolith_h264 *vid);</pre></code>
<div><b><i>&lt;&lt;h264_functions&gt;&gt;=</i></b></div><pre><code>int monolith_h264_end(monolith_h264 *vid)
{
    int i_frame_size;
    if(vid-&gt;h == NULL) return 0;
    while( x264_encoder_delayed_frames(vid-&gt;h))
    {
        i_frame_size = x264_encoder_encode(vid-&gt;h,
                                           &vid-&gt;nal,
                                           &vid-&gt;i_nal,
                                           NULL,
                                           &vid-&gt;pic_out );
        if( i_frame_size ) {
            fwrite(vid-&gt;nal-&gt;p_payload,
                   i_frame_size,
                   1,
                   vid-&gt;fp);
        }
    }

    x264_encoder_close(vid-&gt;h);
    x264_picture_clean(&vid-&gt;pic);
    fclose(vid-&gt;fp);
    vid-&gt;fp = NULL;
    vid-&gt;h = NULL;
    return 1;
}</pre></code>

<h6>27.7.3.2. end in scheme</h6>

<p><a id="wm_000_3316"></a><div><b><i>&lt;&lt;h264_scheme_entries&gt;&gt;=</i></b></div><pre><code>{"monolith:h264-end", pp_h264_end, 0, 0, {___,___,___}},</pre></code>
<div><b><i>&lt;&lt;h264_scheme_functions&gt;&gt;=</i></b></div><pre><code>static cell pp_h264_end(cell p)
{
    monolith_d *m;
    monolith_h264 *vid;

    m = monolith_data_get();
    vid = monolith_h264_get(m);

    monolith_h264_end(vid);
    return UNSPECIFIC;
}</pre></code>

<h6>27.7.3.3. end in janet</h6>

<p><a id="wm_000_3321"></a><div><b><i>&lt;&lt;h264_janet_functions&gt;&gt;=</i></b></div><pre><code>static Janet j_h264_end(int32_t argc, Janet *argv)
{
    monolith_d *m;
    monolith_h264 *vid;

    janet_fixarity(argc, 0);

    m = monolith_data_get();
    vid = monolith_h264_get(m);

    monolith_h264_end(vid);

    return janet_wrap_nil();
}</pre></code>
<div><b><i>&lt;&lt;h264_janet_entries&gt;&gt;=</i></b></div><pre><code>{
"monolith/h264-end",
j_h264_end,
"ends h264 video."
},</pre></code>
</div>
</body>
</html>
