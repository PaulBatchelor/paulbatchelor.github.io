<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<link rel="stylesheet" href="/css/style.css">

</head>
<body>
<div id="main">

<h3>1. SQLar Scheme Bindings</h3>

<p><a id="wm_007_0001"></a>This section outlines an interface for SQLar, designed to
be accessible to Scheme.
</p>

<h4>1.1. SQLar Top</h4>

<p><a id="wm_007_0003"></a>The SQLar interface writes to a file called
<code>sqlar_scheme.c</code>.
</p>
<div><b><i>&lt;&lt;sqlar_scheme_c&gt;&gt;=</i></b></div><pre><code>#include &lt;string.h&gt;
#include &lt;sqlite3.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
#include &lt;zlib.h&gt;
#include "s9core.h"
#include "s9import.h"
#include "s9ext.h"

#include "sqlar_scheme.h"

&lt;&lt;static_sqlar_function_declarations&gt;&gt;
int sqlar_main(int argc, char *argv[]);
&lt;&lt;sqlar_functions&gt;&gt;</pre></code>
<div><b><i>&lt;&lt;sqlar_scheme.h&gt;&gt;=</i></b></div><pre><code>#ifndef SQLAR_SCHEME_H
#define SQLAR_SCHEM_H
&lt;&lt;sqlar_function_declarations&gt;&gt;
#endif</pre></code>

<h4>1.2. SQLar Scheme Loader</h4>

<p><a id="wm_007_0019"></a>The scheme loader is done inside a function called
<code>s9_load_sqlar</code>.
<div><b><i>&lt;&lt;sqlar_function_declarations&gt;&gt;=</i></b></div><pre><code>void s9_load_sqlar(void);</pre></code>
<div><b><i>&lt;&lt;sqlar_functions&gt;&gt;=</i></b></div><pre><code>&lt;&lt;sqlar_scheme_functions&gt;&gt;
static S9_PRIM sqlar_primitives[] = {
&lt;&lt;sqlar_scheme_entries&gt;&gt;
    {NULL}
};
void s9_load_sqlar(void)
{
    add_primitives("sqlar", sqlar_primitives);
}</pre></code>

<h4>1.3. Adding a single file to a SQLar archive</h4>

<p><a id="wm_007_0031"></a></p>

<h5>1.3.1. Adding a file in C</h5>

<p><a id="wm_007_0032"></a></p>

<h6>1.3.1.1. sqlar_add_file</h6>

<p><a id="wm_007_0033"></a><div><b><i>&lt;&lt;static_sqlar_function_declarations&gt;&gt;=</i></b></div><pre><code>static int sqlar_add_file(const char *sqlar,
                          const char *file,
                          const char *name);</pre></code>
<div><b><i>&lt;&lt;sqlar_functions&gt;&gt;=</i></b></div><pre><code>&lt;&lt;compress_function&gt;&gt;
static int sqlar_add_file(const char *sqlar,
                          const char *file,
                          const char *name)
{
    sqlite3 *db;
    int rc;
    sqlite3_stmt *stmt;
    struct stat x;
    char *zc;
    int sz_orig;
    int sz_compr;

    sz_orig = 0;
    sz_compr = 0;

    rc = stat(file, &x);
    if(rc) return SQLITE_CANTOPEN;
    rc = sqlite3_open(sqlar, &db);
    if(rc) return rc;
    rc = sqlite3_exec(db,
                      "CREATE TABLE IF NOT EXISTS sqlar(\n"
                      "  name TEXT PRIMARY KEY,\n"
                      "  mode INT,\n"
                      "  mtime INT,\n"
                      "  sz INT,\n"
                      "  data BLOB\n"
                      ");", 0, 0, 0);
    rc = sqlite3_exec(db, "SELECT 1 FROM sqlar LIMIT 1", 0, 0, 0);
    if(rc) {
        fprintf(stderr, "File %s is not a SQLar archive\n", sqlar);
        sqlite3_close(db);
        return rc;
    }
    sqlite3_prepare(db,
                    "REPLACE INTO sqlar(name,mode,mtime,sz,data)"
                    " VALUES(?1,?2,?3,?4,?5)",
                    -1,
                    &stmt,
                    NULL);

    sqlite3_bind_text(stmt, 1, name, -1, SQLITE_STATIC);
    sqlite3_bind_int(stmt, 2, x.st_mode);
    sqlite3_bind_int64(stmt, 3, x.st_mtime);

    zc = read_file(file, &sz_orig, &sz_compr);
    sqlite3_bind_int(stmt, 4, sz_orig);
    sqlite3_bind_blob(stmt, 5, zc, sz_compr, sqlite3_free);

    sqlite3_step(stmt);

    sqlite3_finalize(stmt);
    sqlite3_close(db);
    return SQLITE_OK;
}</pre></code>

<h6>1.3.1.2. Compress Function</h6>

<p><a id="wm_007_0041"></a><div><b><i>&lt;&lt;compress_function&gt;&gt;=</i></b></div><pre><code>static char *read_file(const char *filename, int *size_orig, int *size_compr)
{
    FILE *in;
    char *zin;
    long int nin;
    char *zcompr;
    unsigned long int ncompr;
    int rc;

    in = fopen(filename, "rb");

    if(in==0) {
        fprintf(stderr, "cannot open \"%s\" for reading\n", filename);
        return NULL;
    }

    fseek(in, 0, SEEK_END);
    nin = ftell(in);
    rewind(in);
    zin = sqlite3_malloc( nin+1 );

    if(zin==0) {
        fprintf(stderr, "cannot malloc for %ld bytes\n", nin+1);
        return NULL;
    }

    if( nin&gt;0 && fread(zin, nin, 1, in)!=1 ){
        fprintf(stderr, "unable to read %ld bytes of file %s\n", nin, filename);
        return NULL;
    }

    fclose(in);
    ncompr = 13 + nin + (nin+999)/1000;
    zcompr = sqlite3_malloc(ncompr+1);

    if(zcompr==0) {
        fprintf(stderr, "cannot malloc for %ld bytes\n", ncompr+1);
        return NULL;
    }

    rc = compress((Bytef*)zcompr, &ncompr, (const Bytef*)zin, nin);

    if( rc!=Z_OK ) {
        fprintf(stderr, "Cannot compress %s\n", filename);
        return NULL;
    }

    if(nin&gt;ncompr){
        sqlite3_free(zin);
        *size_orig = nin;
        *size_compr = (int)ncompr;
        return zcompr;
    }else{
        sqlite3_free(zcompr);
        *size_orig = *size_compr = nin;
        return zin;
    }
}</pre></code>

<h5>1.3.2. Adding a file in Scheme</h5>

<p><a id="wm_007_0045"></a><div><b><i>&lt;&lt;sqlar_scheme_entries&gt;&gt;=</i></b></div><pre><code>{"sqlar:add-file", pp_add_file, 3, 3, {STR,STR,STR}},</pre></code>
<div><b><i>&lt;&lt;sqlar_scheme_functions&gt;&gt;=</i></b></div><pre><code>static cell pp_add_file(cell x)
{
    const char *db;
    const char *file;
    const char *name;
    int rc;
    cell cstr;

    cstr = car(x);
    db = string(car(x));
    x = cdr(x);
    file = string(car(x));
    x = cdr(x);
    name = string(car(x));
    rc = sqlar_add_file(db, file, name);

    if(rc != SQLITE_OK) {
        error("Could not add file to sqlar archive", cstr);
    }
    return UNSPECIFIC;
}</pre></code>

<h4>1.4. Extracting a single file from a SQLar archive</h4>

<p><a id="wm_007_0052"></a></p>

<h5>1.4.1. Extracting a file in C</h5>

<p><a id="wm_007_0053"></a></p>

<h6>1.4.1.1. sqlar_extract_file</h6>

<p><a id="wm_007_0054"></a>The function <code>sqlar_extract_file</code> is used to extract a file from a sqlar
archive.
<div><b><i>&lt;&lt;static_sqlar_function_declarations&gt;&gt;=</i></b></div><pre><code>static int sqlar_extract_file(const char *sqlar,
                              const char *name,
                              const char *out);</pre></code>
<div><b><i>&lt;&lt;sqlar_functions&gt;&gt;=</i></b></div><pre><code>static int sqlar_extract_file(const char *sqlar,
                              const char *name,
                              const char *out)
{
    FILE *fp;
    char *output;
    unsigned long int out_size;
    int rc;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int imode;
    int sz;
    const char *data;
    int data_sz;

    rc = sqlite3_open(sqlar, &db);
    if(rc) return rc;

    rc = sqlite3_exec(db,
                      "CREATE TABLE IF NOT EXISTS sqlar(\n"
                      "  name TEXT PRIMARY KEY,\n"
                      "  mode INT,\n"
                      "  mtime INT,\n"
                      "  sz INT,\n"
                      "  data BLOB\n"
                      ");", 0, 0, 0);


    sqlite3_prepare(db,
                    "SELECT name, mode, mtime, sz, data FROM sqlar"
                    " WHERE name is ?1",
                    -1,
                    &stmt,
                    NULL);

    sqlite3_bind_text(stmt, 1, name, -1, SQLITE_STATIC);

    rc = sqlite3_step(stmt);

    if(rc != SQLITE_ROW) {
        fprintf(stderr, "Could find file %s\n", name);
        sqlite3_finalize(stmt);
        sqlite3_close(db);
        return rc;
    }

    imode = sqlite3_column_int(stmt,1);
    sz = sqlite3_column_int(stmt,3);
    data = sqlite3_column_blob(stmt,4);
    data_sz = sqlite3_column_bytes(stmt,4);

    fp = fopen(out, "wb");
    if(fp == NULL) {
        fprintf(stderr, "Could not open output file %s for writing\n", out);
        return SQLITE_CANTOPEN;
    }

    if(sz == data_sz) {
        fwrite(data, 1, data_sz, fp);
    } else {
        output = sqlite3_malloc(sz+1);
        out_size = sz;

        rc = uncompress((Bytef*)output,
                        &out_size,
                        (const Bytef*)data,
                        data_sz);
        if(rc != Z_OK) {
            fprintf(stderr, "Error: could not uncompress data\n");
            return SQLITE_ERROR;
        }
        fwrite(output, out_size, 1, fp);
        sqlite3_free(output);
    }
    fclose(fp);
    sqlite3_finalize(stmt);
    sqlite3_close(db);
    rc = chmod(out, imode&0777);
    return SQLITE_OK;
}</pre></code>

<h5>1.4.2. Extracting a file in Scheme</h5>

<p><a id="wm_007_0060"></a><div><b><i>&lt;&lt;sqlar_scheme_entries&gt;&gt;=</i></b></div><pre><code>{"sqlar:extract-file", pp_extract_file, 3, 3, {STR,STR,STR}},</pre></code>
<div><b><i>&lt;&lt;sqlar_scheme_functions&gt;&gt;=</i></b></div><pre><code>static cell pp_extract_file(cell x)
{
    const char *db;
    const char *file;
    const char *name;
    int rc;
    cell cstr;

    cstr = car(x);
    db = string(car(x));
    x = cdr(x);
    file = string(car(x));
    x = cdr(x);
    name = string(car(x));
    rc = sqlar_extract_file(db, file, name);

    if(rc != SQLITE_OK) {
        error("Could not extract file from sqlar archive", cstr);
    }
    return UNSPECIFIC;
}</pre></code>

<h4>1.5. Raw SQLite query</h4>

<p><a id="wm_007_0065"></a>The function <code>sqlar:sql</code> performs raw SQL commands on an
input file.
</p>

<h5>1.5.1. Raw SQLite in C</h5>

<p><a id="wm_007_0067"></a><div><b><i>&lt;&lt;static_sqlar_function_declarations&gt;&gt;=</i></b></div><pre><code>static int sqlar_sql(char *db, char *sql);</pre></code>
<div><b><i>&lt;&lt;sqlar_functions&gt;&gt;=</i></b></div><pre><code>static int callback(void *notused,
                    int argc,
                    char **argv,
                    char **azcolname)
{
    int i;
    for(i = 0; i &lt; argc; i++) {
        printf("%s = %s\n",
               azcolname[i],
               argv[i] ? argv[i] : "NULL");
    }
    printf("\n");
    return 0;
}
static int sqlar_sql(char *filename, char *sql)
{
    int rc;
    sqlite3 *db;
    char *errmsg;

    errmsg = NULL;

    rc = sqlite3_open(filename, &db);

    if(rc) {
        fprintf(stderr,
                "Can't open database: %s\n",
                sqlite3_errmsg(db));
        sqlite3_close(db);
        return 1;
    }

    rc = sqlite3_exec(db, sql, callback, 0, &errmsg);

    if(rc != SQLITE_OK) {
        fprintf(stderr, "SQLite error: %s\n", errmsg);
        sqlite3_free(errmsg);
    }
    sqlite3_close(db);
    return 0;
}</pre></code>

<h5>1.5.2. Raw SQLite in Scheme</h5>

<p><a id="wm_007_0072"></a>Raw sqlite commands can be executed in Scheme using the function <code>sqlar:sql</code>.
<div><b><i>&lt;&lt;sqlar_scheme_entries&gt;&gt;=</i></b></div><pre><code>{"sqlar:sql", pp_sql, 2, 2, {STR,STR,___}},</pre></code>
<div><b><i>&lt;&lt;sqlar_scheme_functions&gt;&gt;=</i></b></div><pre><code>static cell pp_sql(cell x)
{
    char *db;
    char *sql;
    int rc;
    cell cstr;

    cstr = car(x);
    db = string(car(x));
    x = cdr(x);
    sql = string(car(x));
    rc = sqlar_sql(db, sql);

    if(rc != 0) {
        error("SQLite error", cstr);
    }

    return UNSPECIFIC;
}</pre></code>

<h4>1.6. Extracting SQLar file to buffer</h4>

<p><a id="wm_007_0078"></a></p>

<h5>1.6.1. Via SQLar filename</h5>

<p><a id="wm_007_0079"></a><div><b><i>&lt;&lt;sqlar_function_declarations&gt;&gt;=</i></b></div><pre><code>int sqlar_extract_to_buffer(const char *sqlar,
                            const char *name,
                            char **out,
                            int *size);</pre></code>
<div><b><i>&lt;&lt;sqlar_functions&gt;&gt;=</i></b></div><pre><code>int sqlar_extract_to_buffer(const char *sqlar,
                            const char *name,
                            char **out,
                            int *size)
{
    int rc;
    sqlite3 *db;

    if (access(sqlar, F_OK) == -1) {
        fprintf(stderr,
                "SQLar: could not find db %s\n",
                sqlar);
        return SQLITE_NOTFOUND;
    }

    rc = sqlite3_open(sqlar, &db);

    if (rc) {
        fprintf(stderr, "SQLar: %s\n", sqlite3_errmsg(db));
        return rc;
    }

    rc = sqlar_extract_to_buffer_db(db, name, out, size);

    sqlite3_close(db);
    return rc;
}</pre></code>

<h5>1.6.2. Via Sqlite3 db handle</h5>

<p><a id="wm_007_0084"></a><div><b><i>&lt;&lt;sqlar_function_declarations&gt;&gt;=</i></b></div><pre><code>int sqlar_extract_to_buffer_db(sqlite3 *db,
                               const char *name,
                               char **out,
                               int *size);</pre></code>
<div><b><i>&lt;&lt;sqlar_functions&gt;&gt;=</i></b></div><pre><code>int sqlar_extract_to_buffer_db(sqlite3 *db,
                               const char *name,
                               char **out,
                               int *size)
{
    char *output;
    unsigned long int out_size;
    int rc;
    sqlite3_stmt *stmt;
    int sz;
    const char *data;
    int data_sz;

    rc = sqlite3_exec(db,
                      "CREATE TABLE IF NOT EXISTS sqlar(\n"
                      "  name TEXT PRIMARY KEY,\n"
                      "  mode INT,\n"
                      "  mtime INT,\n"
                      "  sz INT,\n"
                      "  data BLOB\n"
                      ");", 0, 0, 0);


    sqlite3_prepare(db,
                    "SELECT name, mode, mtime, sz, data FROM sqlar"
                    " WHERE name is ?1",
                    -1,
                    &stmt,
                    NULL);

    sqlite3_bind_text(stmt, 1, name, -1, SQLITE_STATIC);

    rc = sqlite3_step(stmt);

    if(rc != SQLITE_ROW) {
        fprintf(stderr,
                "SQLar: could find file %s\n",
                name);
        sqlite3_finalize(stmt);
        sqlite3_close(db);
        return rc;
    }

    sz = sqlite3_column_int(stmt,3);
    data = sqlite3_column_blob(stmt,4);
    data_sz = sqlite3_column_bytes(stmt,4);

    output = calloc(1, sz + 1);
    if(sz != data_sz) {
        out_size = sz;

        rc = uncompress((Bytef*)output,
                        &out_size,
                        (const Bytef*)data,
                        data_sz);
        if(rc != Z_OK) {
            fprintf(stderr,
                    "Error: could not uncompress data\n");
            return SQLITE_ERROR;
        }
    } else {
        memcpy(output, data, sz);
    }

    *size = sz;
    *out = output;
    sqlite3_finalize(stmt);
    return SQLITE_OK;
}</pre></code>
</div>
</body>
</html>
