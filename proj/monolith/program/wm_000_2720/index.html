<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<link rel="stylesheet" href="/css/style.css">

</head>
<body>
<div id="main">

<h3>19. State</h3>

<p><a id="wm_000_2720"></a>Monolith has the ability to save and load data. We call this data <code>state</code>.
</p>

<h4>19.1. SQLite Header Include</h4>

<p><a id="wm_000_2722"></a><div><b><i>&lt;&lt;system_includes&gt;&gt;=</i></b></div><pre><code>#include "sqlite3.h"</pre></code>

<h4>19.2. Monolith State in Top-level Struct</h4>

<p><a id="wm_000_2725"></a>At any given time, exactly one state file is open. This state file is
managed inside of the struct.
</p>
<div><b><i>&lt;&lt;struct_contents&gt;&gt;=</i></b></div><pre><code>monolith_state state;</pre></code>
<div><b><i>&lt;&lt;init&gt;&gt;=</i></b></div><pre><code>monolith_state_init(&m-&gt;state);</pre></code>
<p></p>
<p>On cleanup, monolith will automatically close any open monolith state. Nothing
will happen if there isn't anything open.
</p>
<div><b><i>&lt;&lt;cleanup&gt;&gt;=</i></b></div><pre><code>monolith_state_close(m);</pre></code>
<p></p>
<p>State can be retrieved with <code>monolith_state_get</code>.
</p>
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>monolith_state* monolith_state_get(monolith_d *m);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>monolith_state* monolith_state_get(monolith_d *m)
{
    return &m-&gt;state;
}</pre></code>

<h4>19.3. Monolith State Data</h4>

<p><a id="wm_000_2739"></a>The monolith state is mostly powered by SQLite! SQLite doesn't need to be seen
by other parts of monolith, so we wrap all the bits inside of monolith state and
make SQLite calls via monolith state functions.
<div><b><i>&lt;&lt;typedefs&gt;&gt;=</i></b></div><pre><code>typedef struct monolith_state monolith_state;</pre></code>
<div><b><i>&lt;&lt;structs&gt;&gt;=</i></b></div><pre><code>struct monolith_state {
    sqlite3 *db;
};</pre></code>
<p>It is initialized with the funciton <code>monolith_state_init</code>.
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>void monolith_state_init(monolith_state *s);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>void monolith_state_init(monolith_state *s)
{
    s-&gt;db = NULL;
}</pre></code>
<p></p>
<br>
<p>The function <code>monolith_state_empty</code> checks to see if the
database is empty.
</p>
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_state_empty(monolith_state *s);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_state_empty(monolith_state *s)
{
    return s-&gt;db == NULL;
}</pre></code>

<h4>19.4. Parameter and Schema State Data</h4>

<p><a id="wm_000_2755"></a>While the monolith state does use SQLite, pages shouldn't be writing SQLite
statements directly. Parameters can be saved and loaded using this parameter
interface.
</p>

<h5>19.4.1. Parameter Data</h5>

<p><a id="wm_000_2757"></a>A parameter is a single unit which stores a single data value. It is known
as a <code>monolith_state_param</code>.
<div><b><i>&lt;&lt;typedefs&gt;&gt;=</i></b></div><pre><code>typedef struct monolith_state_param monolith_state_param;</pre></code>
<div><b><i>&lt;&lt;structs&gt;&gt;=</i></b></div><pre><code>struct monolith_state_param {
&lt;&lt;state_param_contents&gt;&gt;
};</pre></code>

<h6>19.4.1.1. Parameter Struct Initialization/Cleanup</h6>

<p><a id="wm_000_2765"></a>The struct is initialized with <code>monolith_state_param_init</code>.
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>void monolith_state_param_init(monolith_state_param *msp);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>void monolith_state_param_init(monolith_state_param *msp)
{
&lt;&lt;monolith_state_param_init&gt;&gt;
}</pre></code>
<p>Any thing allocated and bound to this particular param instance is freed
with <code>monolith_state_param_cleanup</code>.
</p>
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>void monolith_state_param_cleanup(monolith_state_param *msp);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>void monolith_state_param_cleanup(monolith_state_param *msp)
{
&lt;&lt;monolith_state_param_cleanup&gt;&gt;
}</pre></code>

<h6>19.4.1.2. Parameter Struct Contents</h6>

<p><a id="wm_000_2780"></a></p>

<h7>19.4.1.2.1. Param Name</h7>

<p><a id="wm_000_2781"></a>The parameter name is the string used to identify what the parameter is.
In addition to the name, the string length is stored as well.
<div><b><i>&lt;&lt;state_param_contents&gt;&gt;=</i></b></div><pre><code>char *name;
int len;</pre></code>
<div><b><i>&lt;&lt;monolith_state_param_init&gt;&gt;=</i></b></div><pre><code>msp-&gt;name = NULL;
msp-&gt;len = 0;</pre></code>
<div><b><i>&lt;&lt;monolith_state_param_cleanup&gt;&gt;=</i></b></div><pre><code>if(msp-&gt;name != NULL) free(msp-&gt;name);</pre></code>
<p></p>
<p>The name for a particular parameter can be set using the function
<code>monolith_state_param_name_set</code>. It will allocate and set the name of the
string. The length of the string must also be known and explicitely provided.
</p>
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_name_set(monolith_state_param *p,
                                  const char *name,
                                  int len);</pre></code>
<p>The function will allocate and copy the string to the internal state. If the
allocation fails, the function will return false (0), otherwise it will return
true (1). The function can also fail if the length is non-zero or the name is
non-null.
</p>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_name_set(monolith_state_param *p,
                                  const char *name,
                                  int len)
{
    if(p-&gt;len != 0) return 0;
    if(p-&gt;name != NULL) return 0;

    p-&gt;name = calloc(1, len + 1);
    if(p-&gt;name == NULL) return 0;
    strncpy(p-&gt;name, name, len);
    return 1;
}</pre></code>
<p></p>
<p>The parameter name can be retrieved using the function
<code>monolith_state_param_name_get</code>

<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>const char * monolith_state_param_name_get(monolith_state_param *p);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>const char * monolith_state_param_name_get(monolith_state_param *p)
{
    return p-&gt;name;
}</pre></code>

<h7>19.4.1.2.2. Param Type Flag</h7>

<p><a id="wm_000_2803"></a><div><b><i>&lt;&lt;state_param_contents&gt;&gt;=</i></b></div><pre><code>int type;</pre></code>
<div><b><i>&lt;&lt;monolith_state_param_init&gt;&gt;=</i></b></div><pre><code>msp-&gt;type = 0;</pre></code>
<p></p>
<p>The type can be set with the function <code>monolith_state_param_type_set</code>,
and retrieved with the function <code>monolith_state_param_type_get</code>.
</p>
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>void monolith_state_param_type_set(monolith_state_param *p, int type);
int monolith_state_param_type_get(monolith_state_param *p);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>void monolith_state_param_type_set(monolith_state_param *p, int type)
{
    p-&gt;type = type;
}
int monolith_state_param_type_get(monolith_state_param *p)
{
    return p-&gt;type;
}</pre></code>

<h7>19.4.1.2.3. Param User Data</h7>

<p><a id="wm_000_2813"></a><div><b><i>&lt;&lt;state_param_contents&gt;&gt;=</i></b></div><pre><code>void *ud;</pre></code>
<div><b><i>&lt;&lt;monolith_state_param_init&gt;&gt;=</i></b></div><pre><code>msp-&gt;ud = NULL;</pre></code>
<p></p>
<br>
<p>Data assigned to the user data pointer <code>ud</code> is freed by <code>monolith_state_param</code>
during cleanup. By default, the data is freed using the system <code>free</code> function.
If the internal destructor function has been set with
<code>monolith_state_param_dtor_set</code>.
</p>
<div><b><i>&lt;&lt;monolith_state_param_cleanup&gt;&gt;=</i></b></div><pre><code>if(msp-&gt;ud != NULL) {
    if(msp-&gt;dtor != NULL) {
        msp-&gt;dtor(msp-&gt;ud); /* use external destructor */
    } else {
        free(msp-&gt;ud); /* use system free */
    }
}</pre></code>
<p></p>
<p>The user data can be set/get with the functions
<code>monolith_state_param_data_set</code> and
<code>monolith_state_param_data_get</code>.
</p>
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>void monolith_state_param_data_set(monolith_state_param *p, void *ud);
void * monolith_state_param_data_get(monolith_state_param *p);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>void monolith_state_param_data_set(monolith_state_param *p, void *ud)
{
    p-&gt;ud = ud;
}
void * monolith_state_param_data_get(monolith_state_param *p)
{
    return p-&gt;ud;
}</pre></code>

<h7>19.4.1.2.4. Param Destructor (Optional)</h7>

<p><a id="wm_000_2826"></a>A destructor function pointer is used as an alternative to <code>free</code> for
freeing the internal userdata. If it is non-null, it will call this function
when the function is being cleaned up. Otherwise, it will call
the default system <code>free</code>.
<div><b><i>&lt;&lt;state_param_contents&gt;&gt;=</i></b></div><pre><code>void (*dtor)(void *);</pre></code>
<div><b><i>&lt;&lt;monolith_state_param_init&gt;&gt;=</i></b></div><pre><code>msp-&gt;dtor = NULL;</pre></code>
<p></p>
<p>The destructor can be set using the function <code>monolith_state_param_dtor_set</code>.
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>void monolith_state_param_dtor_set(monolith_state_param *msp,
                                   void (*dtor)(void *));</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>void monolith_state_param_dtor_set(monolith_state_param *msp,
                                   void (*dtor)(void *))
{
    msp-&gt;dtor = dtor;
}</pre></code>

<h6>19.4.1.3. Parameter State Types</h6>

<p><a id="wm_000_2837"></a></p>

<h7>19.4.1.3.1. Type Enum Declaration</h7>

<p><a id="wm_000_2838"></a>All types are stored inside of an enum, which gets dynamically populated here.
<div><b><i>&lt;&lt;macros&gt;&gt;=</i></b></div><pre><code>enum {
    PARAM_NONE = 0,
&lt;&lt;parameter_enum&gt;&gt;
    PARAM_END /* so we don't have to worry about comma warning */
};</pre></code>

<h7>19.4.1.3.2. Floating Point Parameter</h7>

<p><a id="wm_000_2844"></a>A floating point parameter uses the enum type <code>PARAM_FLOAT</code>.
<div><b><i>&lt;&lt;parameter_enum&gt;&gt;=</i></b></div><pre><code>PARAM_FLOAT,</pre></code>
<p>A float point parameter is created using the function
<code>monolith_state_param_mkfloat</code>.
</p>

<h8>19.4.1.3.2.1. state_param_mkfloat</h8>

<p><a id="wm_000_2850"></a><div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_mkfloat(monolith_state_param *p,
                                 const char *name,
                                 int len,
                                 float ival);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_mkfloat(monolith_state_param *p,
                                 const char *name,
                                 int len,
                                 float ival)
{
    int rc;
    float *x;
    rc = monolith_state_param_name_set(p, name, len);
    if(!rc) return 0;
    x = calloc(1, sizeof(float));
    *x = ival;
    monolith_state_param_data_set(p, x);
    monolith_state_param_type_set(p, PARAM_FLOAT);
    return 1;
}</pre></code>

<h8>19.4.1.3.2.2. state_param_float</h8>

<p><a id="wm_000_2855"></a>The value of a float can be retrieved using the function
<code>monolith_param_float</code>. This will do type checking. If it's not a float,
it will return 0.
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_float(monolith_state_param *p, float **f);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_float(monolith_state_param *p, float **f)
{
    int t;
    t = monolith_state_param_type_get(p);
    if(t != PARAM_FLOAT) return 0;
    *f = (float *)monolith_state_param_data_get(p);
    return 1;
}</pre></code>

<h8>19.4.1.3.2.3. state_param_float_set</h8>

<p><a id="wm_000_2861"></a>The value of a float can be set using the function
<code>monolith_param_float_set</code>. If the parameter is not a float, it will
return 0.
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_float_set(monolith_state_param *p, float f);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_float_set(monolith_state_param *p, float f)
{
    int t;
    float *fp;
    t = monolith_state_param_type_get(p);
    if(t != PARAM_FLOAT) return 0;
    fp = (float *)monolith_state_param_data_get(p);
    *fp = f;
    return 1;
}</pre></code>

<h7>19.4.1.3.3. Integer Parameter</h7>

<p><a id="wm_000_2867"></a>An integer parameter uses the enum type <code>PARAM_INT</code>.
<div><b><i>&lt;&lt;parameter_enum&gt;&gt;=</i></b></div><pre><code>PARAM_INT,</pre></code>
<p>An integer parameter is created using the function
<code>monolith_state_param_mkint</code>.
</p>

<h8>19.4.1.3.3.1. state_param_mkint</h8>

<p><a id="wm_000_2872"></a><div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_mkint(monolith_state_param *p,
                               const char *name,
                               int len,
                               int ival);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_mkint(monolith_state_param *p,
                               const char *name,
                               int len,
                               int ival)
{
    int rc;
    int *x;
    rc = monolith_state_param_name_set(p, name, len);
    if(!rc) return 0;
    x = calloc(1, sizeof(int));
    *x = ival;
    monolith_state_param_data_set(p, x);
    monolith_state_param_type_set(p, PARAM_INT);
    return 1;
}</pre></code>
<p>The value of an integer can be retrieved using the function
<code>monolith_state_param_int</code>. This will do type checking. If it's not an integer,
it will return 0.
</p>

<h8>19.4.1.3.3.2. state_param_int</h8>

<p><a id="wm_000_2878"></a><div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_int(monolith_state_param *p, int **i);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_int(monolith_state_param *p, int **i)
{
    int t;
    t = monolith_state_param_type_get(p);
    if(t != PARAM_INT) return 0;
    *i = (int *)monolith_state_param_data_get(p);
    return 1;
}</pre></code>

<h8>19.4.1.3.3.3. state_param_int_set</h8>

<p><a id="wm_000_2883"></a>The value of an integer can be set using the function
<code>monolith_param_int_set</code>. If the parameter is not an integer, it will
return 0.
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_int_set(monolith_state_param *p, int i);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_int_set(monolith_state_param *p, int i)
{
    int t;
    int *ip;
    t = monolith_state_param_type_get(p);
    if(t != PARAM_INT) return 0;
    ip = (int *)monolith_state_param_data_get(p);
    *ip = i;
    return 1;
}</pre></code>

<h7>19.4.1.3.4. String Parameter</h7>

<p><a id="wm_000_2889"></a></p>

<h8>19.4.1.3.4.1. state_param_mkstring</h8>

<p><a id="wm_000_2890"></a>CLOSED: [2019-01-13 Sun 18:57]
A string parameter uses the enum type <code>PARAM_STRING</code>.
<div><b><i>&lt;&lt;parameter_enum&gt;&gt;=</i></b></div><pre><code>PARAM_STRING,</pre></code>
<p>An string parameter is created using the function
<code>monolith_state_param_mkstring</code>. The size of the string must be supplied
as well.
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_mkstring(monolith_state_param *p,
                                  const char *name,
                                  int len,
                                  const char *str,
                                  unsigned int strlen);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_mkstring(monolith_state_param *p,
                                  const char *name,
                                  int len,
                                  const char *str,
                                  unsigned int strlen)
{
    int rc;
    char *x;
    rc = monolith_state_param_name_set(p, name, len);
    if(!rc) return 0;
    x = calloc(1, strlen + 1);
    if(x == NULL) return 0;
    strncpy(x, str, strlen);
    monolith_state_param_data_set(p, x);
    monolith_state_param_type_set(p, PARAM_STRING);
    return 1;
}</pre></code>
<p>The value of a string can be retrieved using the function
<code>monolith_state_param_string</code>. This will do type checking.
If it's not a string, it will return 0.
</p>

<h8>19.4.1.3.4.2. state_param_string</h8>

<p><a id="wm_000_2900"></a><div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_string(monolith_state_param *p, char **str);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_string(monolith_state_param *p, char **str)
{
    int t;
    t = monolith_state_param_type_get(p);
    if(t != PARAM_STRING) return 0;
    *str = (char *)monolith_state_param_data_get(p);
    return 1;
}</pre></code>

<h7>19.4.1.3.5. Monome State Parameter</h7>

<p><a id="wm_000_2905"></a>The monome LED state has it's own parameter. The parameter itself stores the
current state of the LED grid as a string. More information can be found
in the section <a href="How monome state data is stored">How monome state data is stored</a>.
</p>

<h8>19.4.1.3.5.1. monome state type enum</h8>

<p><a id="wm_000_2907"></a>A monome state parameter uses the enum type <code>PARAM_MSTATE</code>.
<div><b><i>&lt;&lt;parameter_enum&gt;&gt;=</i></b></div><pre><code>PARAM_MSTATE,</pre></code>

<h8>19.4.1.3.5.2. state_param_mkmstate</h8>

<p><a id="wm_000_2911"></a>When the monolith state is saved, it only saves the string. The data allocated
is all the data needed for the string, plus the null terminator. With 3 bytes
per row, and 8 rows, this totals to be 25 bytes.
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_mkmstate(monolith_state_param *p,
                                  const char *name,
                                  int len,
                                  monolith_page_mstate *ms);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_mkmstate(monolith_state_param *p,
                                  const char *name,
                                  int len,
                                  monolith_page_mstate *ms)
{
    int rc;
    char *bytes;
    rc = monolith_state_param_name_set(p, name, len);
    if(!rc) return 0;
    bytes = calloc(1, 25); /* (8 x 3) + 1 */
    monolith_base64_grid_encode(ms, bytes);
    bytes[24] = 0;
    monolith_state_param_data_set(p, bytes);
    monolith_state_param_type_set(p, PARAM_MSTATE);
    return 1;
}</pre></code>

<h8>19.4.1.3.5.3. state_param_mstate</h8>

<p><a id="wm_000_2917"></a>This function will read information from the state param and read it into the
monolith monome state.
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_mstate(monolith_state_param *p,
                                monolith_page_mstate *ms);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_mstate(monolith_state_param *p,
                                monolith_page_mstate *ms)
{
    int t;
    char *bytes;
    t = monolith_state_param_type_get(p);
    if(t != PARAM_MSTATE) return 0;
    bytes = (char *)monolith_state_param_data_get(p);
    monolith_base64_grid_decode(ms, bytes);
    return 1;
}</pre></code>

<h8>19.4.1.3.5.4. state_param_mstate_set</h8>

<p><a id="wm_000_2923"></a>The value of an integer can be set using the function
<code>monolith_param_int_set</code>. If the parameter is not an integer, it will
return 0.
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_mstate_set(monolith_state_param *p, const char *str);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_mstate_set(monolith_state_param *p, const char *str)
{
    int t;
    char *in;
    int i;
    t = monolith_state_param_type_get(p);
    if(t != PARAM_MSTATE) return 0;
    in = (char *)monolith_state_param_data_get(p);
    for(i = 0; i &lt; 24; i++) {
        in[i] = str[i];
    }
    return 1;
}</pre></code>

<h7>19.4.1.3.6. DONE Blob Parameter [4/4]</h7>

<p><a id="wm_000_2929"></a>CLOSED: [2019-04-05 Fri 21:36]
</p>

<h8>19.4.1.3.6.1. DONE Blob Enum</h8>

<p><a id="wm_000_2931"></a>CLOSED: [2019-03-17 Sun 23:05]
A blob is used to store binary data.
<div><b><i>&lt;&lt;parameter_enum&gt;&gt;=</i></b></div><pre><code>PARAM_BLOB,</pre></code>

<h8>19.4.1.3.6.2. DONE state_param_mkblob</h8>

<p><a id="wm_000_2935"></a>CLOSED: [2019-04-05 Fri 21:26]
The function <code>state_param_mkblob</code> creates a blob entry. If the blob needs to be
freed, a destructor callback <code>dtor</code> should be passed in as an argument.
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_mkblob(monolith_state_param *p,
                                const char *name,
                                int len,
                                void *blob,
                                unsigned int bloblen,
                                void (*dtor)(void*));</pre></code>
<p></p>
<p>In order to keep track of both the blob data and the size, a special struct
is created. The custom destructor callback is stored here as well.
</p>
<div><b><i>&lt;&lt;mkblob_struct&gt;&gt;=</i></b></div><pre><code>typedef struct {
    unsigned int blobsize;
    void *ud;
    void (*dtor)(void*);
} mkblob_struct;</pre></code>
<p></p>
<br>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>&lt;&lt;mkblob_struct&gt;&gt;

static void blob_free(void *ud)
{
    mkblob_struct *x;
    x = ud;

    if(x-&gt;dtor != NULL) x-&gt;dtor(x-&gt;ud);
    free(ud);
}

int monolith_state_param_mkblob(monolith_state_param *p,
                                const char *name,
                                int len,
                                void *blob,
                                unsigned int bloblen,
                                void (*dtor)(void*))
{
    int rc;
    mkblob_struct *x;
    rc = monolith_state_param_name_set(p, name, len);
    if(!rc) return 0;

    x = calloc(1, sizeof(mkblob_struct));
    if(x == NULL) return 0;

    x-&gt;ud = blob;
    x-&gt;blobsize = bloblen;
    x-&gt;dtor = dtor;
    monolith_state_param_data_set(p, x);
    monolith_state_param_type_set(p, PARAM_BLOB);
    monolith_state_param_dtor_set(p, blob_free);
    return 1;
}</pre></code>

<h8>19.4.1.3.6.3. DONE state_param_blob</h8>

<p><a id="wm_000_2948"></a>CLOSED: [2019-04-05 Fri 21:32]
This function will read a state parameter, and store the pointer and size into
the variables <code>blob</code> and <code>blobsize</code>.
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_blob(monolith_state_param *p,
                              void **blob,
                              unsigned int *blobsize);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_blob(monolith_state_param *p,
                              void **blob,
                              unsigned int *blobsize)
{
    int t;
    mkblob_struct *x;
    t = monolith_state_param_type_get(p);
    if(t != PARAM_BLOB) return 0;
    x = monolith_state_param_data_get(p);
    if(blob != NULL) *blob = x-&gt;ud;
    if(blobsize != NULL) *blobsize = x-&gt;blobsize;
    return 1;
}</pre></code>

<h8>19.4.1.3.6.4. DONE state_param_blob_set</h8>

<p><a id="wm_000_2954"></a>CLOSED: [2019-05-12 Sun 10:42]
An initialized Blob parameter (initialized with empty values) can be set
to hold real values with the function <code>state_param_blob_set</code>. This will
require the blob, the blob size, and an optional destructor callback.
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_blob_set(monolith_state_param *p,
                                  void *blob,
                                  unsigned int blobsize,
                                  void (*dtor)(void*));</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_state_param_blob_set(monolith_state_param *p,
                                  void *blob,
                                  unsigned int blobsize,
                                  void (*dtor)(void*))
{
    int t;
    mkblob_struct *x;
    t = monolith_state_param_type_get(p);
    if(t != PARAM_BLOB) return 0;
    x = (mkblob_struct *)monolith_state_param_data_get(p);
    x-&gt;ud = blob;
    x-&gt;blobsize = blobsize;
    x-&gt;dtor = dtor;
    return 1;
}</pre></code>

<h5>19.4.2. Monolith Schema Data</h5>

<p><a id="wm_000_2960"></a>A group of parameters (for say, a page) is known as a <code>schema</code>. In practice,
one uses schemas to read and write data to a SQLite table.
</p>
<p>The schema struct is an opaque pointer that must be manually allocated and
destroyed when it is being used.
</p>

<h6>19.4.2.1. Schema Initialization/Cleanup</h6>

<p><a id="wm_000_2962"></a></p>
<p>When schema is initialized, it pre-allocates a fixed number of parameters.
The number of parameters must be node. From there, the schema can be populated
with variable names and values.
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>void monolith_state_schema_init(monolith_state_schema **p_s, int nparams);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>void monolith_state_schema_init(monolith_state_schema **p_s, int nparams)
{
    int i;
    monolith_state_schema *s;

    s = calloc(1, sizeof(monolith_state_schema));
&lt;&lt;schema_init&gt;&gt;
    *p_s = s;
}</pre></code>
<p>When the schema no longer needs to be used, it must be freed using
<code>monolith_state_schema_cleanup</code>.
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>void monolith_state_schema_cleanup(monolith_state_schema **p_s);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>void monolith_state_schema_cleanup(monolith_state_schema **p_s)
{
    int i;
    monolith_state_schema *s;

    s = *p_s;
&lt;&lt;schema_cleanup&gt;&gt;
    free(s);
}</pre></code>

<h6>19.4.2.2. Schema Contents</h6>

<p><a id="wm_000_2977"></a></p>

<h7>19.4.2.2.1. Schema Struct Declaration</h7>

<p><a id="wm_000_2978"></a><div><b><i>&lt;&lt;typedefs&gt;&gt;=</i></b></div><pre><code>typedef struct monolith_state_schema monolith_state_schema;</pre></code>
<div><b><i>&lt;&lt;structs&gt;&gt;=</i></b></div><pre><code>struct monolith_state_schema {
&lt;&lt;schema_contents&gt;&gt;
};</pre></code>

<h7>19.4.2.2.2. Param Array</h7>

<p><a id="wm_000_2985"></a><div><b><i>&lt;&lt;schema_contents&gt;&gt;=</i></b></div><pre><code>monolith_state_param *params;</pre></code>
<p></p>
<p>On init, this gets allocated, then each parameter is initialized.
<div><b><i>&lt;&lt;schema_init&gt;&gt;=</i></b></div><pre><code>s-&gt;params = calloc(1, nparams * sizeof(monolith_state_param));
for(i = 0; i &lt; nparams; i++) {
    monolith_state_param_init(&s-&gt;params[i]);
}</pre></code>
<div><b><i>&lt;&lt;schema_cleanup&gt;&gt;=</i></b></div><pre><code>for(i = 0; i &lt; s-&gt;nparams; i++) {
    monolith_state_param_cleanup(&s-&gt;params[i]);
}
if(s-&gt;params != NULL) free(s-&gt;params);</pre></code>
<p></p>
<p>A single parameter can be retrieved using the function
<code>monolith_state_schema_param</code>. This will do bounds checking, and will return
0 on error.
</p>
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_state_schema_param(monolith_state_schema *s,
                                int pos,
                                monolith_state_param **p);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_state_schema_param(monolith_state_schema *s,
                                int pos,
                                monolith_state_param **p)
{
    if(pos &lt; 0) return 0;
    if(pos &gt;= s-&gt;nparams) return 0;
    *p = &s-&gt;params[pos];
    return 1;
}</pre></code>

<h7>19.4.2.2.3. Number of Parameters</h7>

<p><a id="wm_000_3001"></a>The number of parameters is stored inside of a variable called <code>nparams</code>.
<div><b><i>&lt;&lt;schema_contents&gt;&gt;=</i></b></div><pre><code>int nparams;</pre></code>
<div><b><i>&lt;&lt;schema_init&gt;&gt;=</i></b></div><pre><code>s-&gt;nparams = nparams;</pre></code>

<h6>19.4.2.3. Schema Parameter Setters/Getters</h6>

<p><a id="wm_000_3007"></a>Parameters inside of the schema can be indirectly set using schema functions.
Pages will uses these functions, so they get the shorter prefix
<code>monolith_param</code>.
</p>

<h7>19.4.2.3.1. Schema Floating Point Parameter</h7>

<p><a id="wm_000_3009"></a>A monolith parameter can be created using the function <code>monolith_param_mkfloat</code>.
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_param_mkfloat(monolith_state_schema *s,
                           int pos,
                           const char *name,
                           int len,
                           float ival);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_param_mkfloat(monolith_state_schema *s,
                           int pos,
                           const char *name,
                           int len,
                           float ival)
{
    monolith_state_param *p;
    if(!monolith_state_schema_param(s, pos, &p)) return 0;
    return monolith_state_param_mkfloat(p, name, len, ival);
}</pre></code>
<p>A monolith parameter float can be retrieved using the function
<code>monolith_param_float</code>
#+NAME: function_declarations
<pre><code>int monolith_param_float(monolith_state_schema *s, int pos, float *val);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_param_float(monolith_state_schema *s, int pos, float *val)
{
    monolith_state_param *p;
    float *tmp;
    int rc;
    if(!monolith_state_schema_param(s, pos, &p)) return 0;
    rc = monolith_state_param_float(p, &tmp);
    if(rc) *val = *tmp;
    return rc;
}</pre></code>

<h7>19.4.2.3.2. Schema Integer Parameter</h7>

<p><a id="wm_000_3020"></a></p>

<h8>19.4.2.3.2.1. Integer Param Maker</h8>

<p><a id="wm_000_3021"></a>A monolith parameter can be created using the function <code>monolith_param_mkfloat</code>.
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_param_mkint(monolith_state_schema *s,
                         int pos,
                         const char *name,
                         int len,
                         int ival);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_param_mkint(monolith_state_schema *s,
                         int pos,
                         const char *name,
                         int len,
                         int ival)
{
    monolith_state_param *p;
    if(!monolith_state_schema_param(s, pos, &p)) return 0;
    return monolith_state_param_mkint(p, name, len, ival);
}</pre></code>
<p>A monolith parameter integer can be retrieved using the function
<code>monolith_param_int</code>
<b></b>*<b></b>* 19.4.2.3.2.2. Integer Param Getter
<a id="wm_000_3028"></a><div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_param_int(monolith_state_schema *s, int pos, int *val);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_param_int(monolith_state_schema *s, int pos, int *val)
{
    monolith_state_param *p;
    int *tmp;
    int rc;
    if(!monolith_state_schema_param(s, pos, &p)) return 0;
    rc = monolith_state_param_int(p, &tmp);
    if(rc) *val = *tmp;
    return rc;
}</pre></code>

<h7>19.4.2.3.3. Schema String Parameter</h7>

<p><a id="wm_000_3033"></a></p>

<h8>19.4.2.3.3.1. String Param Maker</h8>

<p><a id="wm_000_3034"></a>A monolith parameter can be created using the function <code>monolith_param_mkfloat</code>.
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_param_mkstring(monolith_state_schema *s,
                            int pos,
                            const char *name,
                            int len,
                            const char *str,
                            unsigned int strlen);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_param_mkstring(monolith_state_schema *s,
                            int pos,
                            const char *name,
                            int len,
                            const char *str,
                            unsigned int strlen)
{
    monolith_state_param *p;
    if(!monolith_state_schema_param(s, pos, &p)) return 0;
    return monolith_state_param_mkstring(p, name, len, str, strlen);
}</pre></code>
<p>A monolith parameter string can be retrieved using the function
<code>monolith_param_string</code>
<b></b>*<b></b>* 19.4.2.3.3.2. String Param Getter
<a id="wm_000_3041"></a><div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_param_string(monolith_state_schema *s, int pos, char **val);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_param_string(monolith_state_schema *s, int pos, char **val)
{
    monolith_state_param *p;
    if(!monolith_state_schema_param(s, pos, &p)) return 0;
    return monolith_state_param_string(p, val);
}</pre></code>

<h8>19.4.2.3.3.3. Const String Param Getter</h8>

<p><a id="wm_000_3046"></a>In many situations, <code>const</code> strings are used more often, so a wrapper function
has been created called <code>monolith_param_stringc</code>. On error, the function
will return NULL.
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>const char * monolith_param_stringc(monolith_state_schema *s, int pos);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>const char * monolith_param_stringc(monolith_state_schema *s, int pos)
{
    char *str;
    if(!monolith_param_string(s, pos, &str)) return NULL;
    return str;
}</pre></code>

<h7>19.4.2.3.4. Schema Monolith State Parameter</h7>

<p><a id="wm_000_3052"></a>This refers to the <a href="Monome Page State">LED state</a> of the monome grid.
</p>

<h8>19.4.2.3.4.1. Schema State Param Maker</h8>

<p><a id="wm_000_3054"></a><div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_param_mkmstate(monolith_state_schema *s,
                            int pos,
                            const char *name,
                            int len,
                            monolith_page_mstate *ms);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_param_mkmstate(monolith_state_schema *s,
                            int pos,
                            const char *name,
                            int len,
                            monolith_page_mstate *ms)
{
    monolith_state_param *p;
    if(!monolith_state_schema_param(s, pos, &p)) return 0;
    return monolith_state_param_mkmstate(p, name, len, ms);
}</pre></code>

<h8>19.4.2.3.4.2. Schema State Param Getter</h8>

<p><a id="wm_000_3059"></a><div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_param_mstate(monolith_state_schema *s,
                          int pos,
                          monolith_page_mstate *ms);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_param_mstate(monolith_state_schema *s,
                          int pos,
                          monolith_page_mstate *ms)
{
    monolith_state_param *p;
    if(!monolith_state_schema_param(s, pos, &p)) return 0;
    return monolith_state_param_mstate(p, ms);
}</pre></code>

<h7>19.4.2.3.5. DONE Schema Blob Parameter</h7>

<p><a id="wm_000_3064"></a>CLOSED: [2019-04-05 Fri 21:36]
</p>

<h8>19.4.2.3.5.1. DONE Blob Param Maker</h8>

<p><a id="wm_000_3066"></a>CLOSED: [2019-04-05 Fri 21:34]
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_param_mkblob(monolith_state_schema *s,
                          int pos,
                          const char *name,
                          int len,
                          void *blob,
                          unsigned int blobsize,
                          void (*dtor)(void *));</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_param_mkblob(monolith_state_schema *s,
                          int pos,
                          const char *name,
                          int len,
                          void *blob,
                          unsigned int blobsize,
                          void (*dtor)(void *))
{
    monolith_state_param *p;
    if(!monolith_state_schema_param(s, pos, &p)) return 0;
    return monolith_state_param_mkblob(p, name, len, blob, blobsize, dtor);
}</pre></code>

<h8>19.4.2.3.5.2. DONE Blob Param Getter</h8>

<p><a id="wm_000_3072"></a>CLOSED: [2019-04-05 Fri 21:36]
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_param_blob(monolith_state_schema *s,
                        int pos,
                        void **blob,
                        unsigned int *blobsize);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_param_blob(monolith_state_schema *s,
                        int pos,
                        void **blob,
                        unsigned int *blobsize)
{
    monolith_state_param *p;
    if(!monolith_state_schema_param(s, pos, &p)) return 0;
    return monolith_state_param_blob(p, blob, blobsize);
}</pre></code>

<h8>19.4.2.3.5.3. DONE Blob Param Setter</h8>

<p><a id="wm_000_3078"></a>CLOSED: [2019-05-09 Thu 08:20]
Unlike other parameter times, making a blob parameter and setting
a blob parameter are two separate things. The blob value, once
allocated is set with the function <code>monolith_param_setblob</code>
#+NAME: function_declarations
<pre><code>int monolith_param_setblob(monolith_state_schema *s,
                           int pos,
                           void *blob,
                           unsigned int blobsize,
                           void (*dtor)(void *));</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_param_setblob(monolith_state_schema *s,
                           int pos,
                           void *blob,
                           unsigned int blobsize,
                           void (*dtor)(void *))
{
    monolith_state_param *p;
    if(!monolith_state_schema_param(s, pos, &p)) return 0;
    return monolith_state_param_blob_set(p, blob, blobsize, dtor);
}</pre></code>
<p></p>
<p>If the system <code>mallocs</code> and <code>frees</code> are used, then the function
<code>monolith_param_setblob_default</code> function can be used.
</p>
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_param_setblob_default(monolith_state_schema *s,
                           int pos,
                           void *blob,
                           unsigned int blobsize);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>static void free_blob(void *ud) {
    free(ud);
}
int monolith_param_setblob_default(monolith_state_schema *s,
                           int pos,
                           void *blob,
                           unsigned int blobsize)
{
    return monolith_param_setblob(s, pos, blob, blobsize, free_blob);
}</pre></code>

<h5>19.4.3. Monolith Schema write test</h5>

<p><a id="wm_000_3089"></a>This is a quick function to make sure the schema things work out okay.
From there, this can be swapped out to write to an actual SQLite database.
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>void monolith_state_schema_test_write(monolith_state_schema *s,
                                      const char *key,
                                      unsigned int len);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>void monolith_state_schema_test_write(monolith_state_schema *s,
                                      const char *key,
                                      unsigned int len)
{
    unsigned int n;
    monolith_state_param *param;
    char buf[256];
    int pos;
    pos = 0;
    strncpy(&buf[pos], "CREATE TABLE IF NOT EXISTS ", 28);
    pos += 27;
    strncpy(&buf[pos], key, len);
    pos += len;
    strncpy(&buf[pos], "(", 2);
    pos += 1;

    strncpy(&buf[pos], "key UNIQUE STRING, ", 20);
    pos += 19;

    for(n = 0; n &lt; s-&gt;nparams; n++) {
        param = &s-&gt;params[n];
        switch(param-&gt;type) {
            case PARAM_NONE:
                printf("NONE");
                break;
            case PARAM_FLOAT:
                pos += sprintf(&buf[pos], "%s FLOAT", param-&gt;name);
                break;
            case PARAM_INT:
                pos += sprintf(&buf[pos], "%s INT", param-&gt;name);
                break;
            case PARAM_STRING:
                pos += sprintf(&buf[pos], "%s STRING", param-&gt;name);
                break;
            case PARAM_MSTATE:
                pos += sprintf(&buf[pos], "%s STRING", param-&gt;name);
                break;
            default:
                break;
        }

        if(n &lt; s-&gt;nparams - 1) {
            pos += sprintf(&buf[pos], ", ");
        }
    }
    pos += sprintf(&buf[pos], ");");
    buf[pos] = 0;
    printf("%s\n", buf);
}</pre></code>

<h4>19.5. How monome state data is stored</h4>

<p><a id="wm_000_3095"></a>The Grid state data is encoded as in a non standard ascii base 64 string,
which allows the data to be stored in a portable manner, while sacrificing
some storage efficiency. Each character in a base64 string encodes a 6 bit value.
A grid row (16 bits, 2 bytes) is stored amongst base64 ascii characters, with
2 extra bits to spare. To mimic how the monome stores data (with "1" being on
the far left), the bitfield is encoded in little endian format.
</p>
<p>In the monolith base64 system, numbers end at ascii position 122 ('z') and move
down to ascii position 58 (':'). Between this range are all printable
ascii characters that also contain the entire alphabet (capital and lowercase).
This chosen range is an aesthetic choice by the author.
</p>

<h5>19.5.1. Encoding/Decoding 6 bit values</h5>

<p><a id="wm_000_3097"></a>The atomic operation for the monolith base64 algorithm are 6 bit values,
which get represented as printable ascii character.
</p>
<p>A 6 bit value is encoded with the function <code>monolith_base64_6bit_encode</code>, and
decoded with the function <code>monolith_base64_6bit_decode</code>.
</p>
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>char monolith_base64_6bit_encode(unsigned char x);
unsigned char monolith_base64_6bit_decode(char x);</pre></code>
<p></p>
<p>Converting a 6-bit value to an ascii is a matter of masking the 8 bit value and
adding the starting bias of 58.
</p>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>char monolith_base64_6bit_encode(unsigned char x)
{
    return (x & 63) + 58;
}</pre></code>
<p></p>
<p>Decoding an ascii value to a number is the reverse process of this.
</p>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>unsigned char monolith_base64_6bit_decode(char x)
{
    return x - 58;
}</pre></code>

<h5>19.5.2. Encoding/Decoding a monome row</h5>

<p><a id="wm_000_3107"></a>A monome state is encoded/decoded one row at a time. Rows are represented as
2-byte unsigned short values (16 bits), which get mapped to the monome in a
little endian sequence. The base 64 encoding also respects this little endian
storage.
</p>
<p>A monome row is encoded using the function <code>mononolith_base64_16bit_encode</code>
and decoded with the function <code>monolith_base64_16bit_decode</code>.
</p>
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>void monolith_base64_16bit_encode(unsigned short row, char *a, char *b, char *c);
unsigned short monolith_base64_16bit_decode(char a, char b, char c);</pre></code>
<p></p>
<p>When a 16 bit value is encoded, it maps the first 6 bits into the character <code>a</code>,
the second set of 6-bits into character <code>b</code>, and the remaining 4 bits into the
character <code>c</code>.
</p>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>void monolith_base64_16bit_encode(unsigned short row, char *a, char *b, char *c)
{
    *a = monolith_base64_6bit_encode(row & 63);
    *b = monolith_base64_6bit_encode((row &gt;&gt; 6) & 63);
    *c = monolith_base64_6bit_encode((row &gt;&gt; 12) & 63);
}</pre></code>
<p></p>
<p>The encoding process does the reverse of this, taking the and A, B, C values,
and using bitshifting operations to create a row.
</p>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>unsigned short monolith_base64_16bit_decode(char a, char b, char c)
{
    unsigned short out;
    out = monolith_base64_6bit_decode(a);
    out |= monolith_base64_6bit_decode(b) &lt;&lt; 6;
    out |= monolith_base64_6bit_decode(c) &lt;&lt; 12;
    return out;
}</pre></code>

<h5>19.5.3. Encoding/Decoding a monome grid</h5>

<p><a id="wm_000_3117"></a>The monome grid consists of 8 rows of 16 bits. The encode/decode functions
handle converting to and from the C representation of 8 16-bit values
to a ascii string buffer of 24 bytes (not including the null terminator).
These functions are <code>monolith_base64_grid_encode</code> and
<code>monolith_base64_grid_decode</code>, respectively.
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>void monolith_base64_grid_encode(monolith_page_mstate *mstate, char *bytes);
void monolith_base64_grid_decode(monolith_page_mstate *mstate, char *bytes);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>void monolith_base64_grid_encode(monolith_page_mstate *mstate, char *bytes)
{
    int row;
    unsigned short *grid;
    grid = (unsigned short *)mstate-&gt;data;
    for(row = 0; row &lt; 8; row++) {
        monolith_base64_16bit_encode(grid[row],
                                     &bytes[0],
                                     &bytes[1],
                                     &bytes[2]);
        bytes+=3;
    }
}

void monolith_base64_grid_decode(monolith_page_mstate *mstate, char *bytes)
{
    int row;
    unsigned short *grid;
    grid = (unsigned short *)mstate-&gt;data;
    for(row = 0; row &lt; 8; row++) {
        grid[row] = monolith_base64_16bit_decode(bytes[0],
                                                 bytes[1],
                                                 bytes[2]);
        bytes+=3;
    }
}</pre></code>

<h5>19.5.4. Base64 Scheme functions</h5>

<p><a id="wm_000_3123"></a>Rows are encoded and decoded with <code>monolith:base64-16bit-encode</code> and
<code>monolith:base64-16bit-decode</code>.
<div><b><i>&lt;&lt;primitive_entries&gt;&gt;=</i></b></div><pre><code>{"monolith:base64-16bit-encode", pp_base64_16bit_encode, 1, 1, {INT,___,___}},
{"monolith:base64-16bit-decode", pp_base64_16bit_decode, 1, 1, {STR,___,___}},</pre></code>
<div><b><i>&lt;&lt;scheme_functions&gt;&gt;=</i></b></div><pre><code>static cell pp_base64_16bit_encode(cell p)
{
    unsigned short x;
    char name[] = "monolith:base64-16bit-encode";
    char str[4];
    x = (unsigned short) integer_value(name, car(p));
    monolith_base64_16bit_encode(x, &str[0], &str[1], &str[2]);
    str[3] = 0;
    return s9_make_string(str, 3);
}</pre></code>
<div><b><i>&lt;&lt;scheme_functions&gt;&gt;=</i></b></div><pre><code>static cell pp_base64_16bit_decode(cell p)
{
    unsigned short x;
    char *str;
    str = string(car(p));
    x = monolith_base64_16bit_decode(str[0], str[1], str[2]);
    return s9_make_integer(x);
}</pre></code>

<h4>19.6. Generating SQL commands from Schema data</h4>

<p><a id="wm_000_3131"></a>The Schema, once populated with parameters, is passed of to the monolith
state to be translated to a SQL database. In order to do this, the Schema needs
to be coverted to a SQL command.
</p>
<p>There are two major SQL commands: a create table command, and a row insert
command.
</p>
<p>The functions to run these commands are expected to run twice: first, to
do a runthrough to get the number of bytes needed to allocate. second, to
actually write to the buffer.
</p>

<h5>19.6.1. SQL Create Command from Schema</h5>

<p><a id="wm_000_3133"></a>This will create the necessary table creation command. This SQL command will
check if the table exists first before writing, so it is safe to call every
time.
</p>

<h6>19.6.1.1. monolith_state_schema_sql_create</h6>

<p><a id="wm_000_3135"></a><div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>unsigned int monolith_state_schema_sql_create(monolith_state_schema *s,
                                              const char *tabname,
                                              unsigned int len,
                                              char *buf,
                                              int write);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>unsigned int monolith_state_schema_sql_create(monolith_state_schema *s,
                                              const char *tabname,
                                              unsigned int len,
                                              char *buf,
                                              int write)
{
    unsigned int pos;
    unsigned int n;
    monolith_state_param *param;

    pos = 0;
    if(write) strncpy(&buf[pos], "CREATE TABLE IF NOT EXISTS ", 28);
    pos += 27;
    if(write) strncpy(&buf[pos], tabname, len);
    pos += len;
    if(write) strncpy(&buf[pos], "(", 2);
    pos += 1;

    if(write) strncpy(&buf[pos], "key TEXT UNIQUE, ", 18);
    pos += 17;

    for(n = 0; n &lt; s-&gt;nparams; n++) {
        param = &s-&gt;params[n];
        switch(param-&gt;type) {
&lt;&lt;schema_sql_create_types&gt;&gt;
            default:
                break;
        }

        if(n &lt; s-&gt;nparams - 1) {
            if(write) pos += sprintf(&buf[pos], ", ");
            else pos += snprintf(NULL, 0, ", ");
        }
    }
    if(write) pos += sprintf(&buf[pos], ");");
    else pos += snprintf(NULL, 0, ");");
    if(write) buf[pos] = 0;
    return pos + 1; /* don't forget the NULL terminator :) */
}</pre></code>

<h6>19.6.1.2. Parameter types</h6>

<p><a id="wm_000_3142"></a></p>

<h7>19.6.1.2.1. No Parameter</h7>

<p><a id="wm_000_3143"></a><div><b><i>&lt;&lt;schema_sql_create_types&gt;&gt;=</i></b></div><pre><code>case PARAM_NONE:
    break;</pre></code>

<h7>19.6.1.2.2. SQLite Float</h7>

<p><a id="wm_000_3147"></a><div><b><i>&lt;&lt;schema_sql_create_types&gt;&gt;=</i></b></div><pre><code>case PARAM_FLOAT:
    if(write) pos += sprintf(&buf[pos], "%s FLOAT", param-&gt;name);
    else pos += snprintf(NULL, 0, "%s FLOAT", param-&gt;name);
    break;</pre></code>

<h7>19.6.1.2.3. SQLite Integer</h7>

<p><a id="wm_000_3150"></a><div><b><i>&lt;&lt;schema_sql_create_types&gt;&gt;=</i></b></div><pre><code>case PARAM_INT:
    if(write) pos += sprintf(&buf[pos], "%s INT", param-&gt;name);
    else pos += snprintf(NULL, 0, "%s INT", param-&gt;name);
    break;</pre></code>

<h7>19.6.1.2.4. SQLite String</h7>

<p><a id="wm_000_3153"></a><div><b><i>&lt;&lt;schema_sql_create_types&gt;&gt;=</i></b></div><pre><code>case PARAM_STRING:
    if(write) pos += sprintf(&buf[pos], "%s TEXT", param-&gt;name);
    else pos += snprintf(NULL, 0, "%s TEXT", param-&gt;name);
    break;</pre></code>

<h7>19.6.1.2.5. SQLite Monome State</h7>

<p><a id="wm_000_3156"></a>Well, this is really represented as the TEXT type.
<div><b><i>&lt;&lt;schema_sql_create_types&gt;&gt;=</i></b></div><pre><code>case PARAM_MSTATE:
    if(write) pos += sprintf(&buf[pos], "%s TEXT", param-&gt;name);
    else pos += snprintf(NULL, 0, "%s TEXT", param-&gt;name);
    break;</pre></code>

<h7>19.6.1.2.6. SQLite Blob</h7>

<p><a id="wm_000_3160"></a>SQLite uses its own BLOB type.
<div><b><i>&lt;&lt;schema_sql_create_types&gt;&gt;=</i></b></div><pre><code>case PARAM_BLOB:
    if(write) pos += sprintf(&buf[pos], "%s BLOB", param-&gt;name);
    else pos += snprintf(NULL, 0, "%s BLOB", param-&gt;name);
    break;</pre></code>

<h5>19.6.2. SQL Insert Command from Schema</h5>

<p><a id="wm_000_3164"></a>The following function described below will create an SQLite template string,
which can then be used by the SQLite API to write data into a string.
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>unsigned int monolith_state_schema_sql_insert(monolith_state_schema *s,
                                              const char *tab,
                                              unsigned int keylen,
                                              char *buf,
                                              int write);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>unsigned int monolith_state_schema_sql_insert(monolith_state_schema *s,
                                              const char *tab,
                                              unsigned int len,
                                              char *buf,
                                              int write)
{
    unsigned int pos;
    unsigned int n;
    monolith_state_param *param;
    int p;

    pos = 0;
    if(write) strncpy(&buf[pos], "REPLACE INTO ", 14);
    pos += 13;
    if(write) strncpy(&buf[pos], tab, len);
    pos += len;
    if(write) strncpy(&buf[pos], " (key, ", 8);
    pos += 7;

    for(n = 0; n &lt; s-&gt;nparams; n++) {
        param = &s-&gt;params[n];
        if(write) pos += sprintf(&buf[pos], "%s", param-&gt;name);
        else pos += snprintf(NULL, 0, "%s", param-&gt;name);
        if(n &lt; s-&gt;nparams - 1) {
            if(write) pos += sprintf(&buf[pos], ", ");
            else pos += snprintf(NULL, 0, ", ");
        }
    }

    if(write) pos += sprintf(&buf[pos], ")\n");
    else pos += snprintf(NULL, 0, ")");

    if(write) strncpy(&buf[pos], "VALUES(?1, ", 12);
    pos += 11;

    p = 2;
    for(n = 0; n &lt; s-&gt;nparams; n++) {
        param = &s-&gt;params[n];
        if(write) pos += sprintf(&buf[pos], "?%d", p);
        else pos += snprintf(NULL, 0, "?%d", p);
        if(n &lt; s-&gt;nparams - 1) {
            if(write) pos += sprintf(&buf[pos], ", ");
            else pos += snprintf(NULL, 0, ", ");
        }
        p++;
    }

    if(write) pos += sprintf(&buf[pos], ");");
    else pos += snprintf(NULL, 0, ");");
    if(write) buf[pos] = 0;
    return pos + 1; /* don't forget the NULL terminator :) */
}</pre></code>

<h5>19.6.3. SQL Select Command from Schema</h5>

<p><a id="wm_000_3170"></a>When a state is read from disk, a SQLite select command must be prepared.
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>unsigned int monolith_state_schema_sql_select(monolith_state_schema *s,
                                              const char *tab,
                                              unsigned int tablen,
                                              const char *key,
                                              unsigned int keylen,
                                              char *buf,
                                              int write);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>unsigned int monolith_state_schema_sql_select(monolith_state_schema *s,
                                              const char *tab,
                                              unsigned int tablen,
                                              const char *key,
                                              unsigned int keylen,
                                              char *buf,
                                              int write)
{
    unsigned int pos;

    pos = 0;


    if(write) strncpy(&buf[pos], "SELECT * FROM ", 15);
    pos += 14;
    if(write) strncpy(&buf[pos], tab, tablen);
    pos += tablen;
    if(write) strncpy(&buf[pos], " WHERE key == '", 16);
    pos += 15;
    if(write) strncpy(&buf[pos], key, keylen + 1);
    pos += keylen;
    if(write) strncpy(&buf[pos], "';", 3);
    pos += 2;

    if(write) buf[pos] = 0;
    return pos + 1; /* don't forget the NULL terminator :) */
}</pre></code>

<h4>19.7. SQLite File I/O</h4>

<p><a id="wm_000_3176"></a>Actual operations involving the SQLite API happen with these functions below.
</p>

<h5>19.7.1. Opening/Closing a SQLite database.</h5>

<p><a id="wm_000_3178"></a>A database is opened with the function <code>monolith_state_dbopen</code>. This is a
wrapper around <code>sqlite3_open</code>. A database is closed with
<code>monolith_state_dbclose</code>. This is a wrapper around <code>sqlite3_close</code>.
</p>
<p>NOTE: these functions have been slightly renamed from <code>state_open</code> and
<code>state_close</code> to <code>state_dbopen</code> and <code>state_dbclose</code>. This was done
because I wanted to use that namespace to handle the global monolith state
pointer (a design addition I made after this section).
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_state_dbopen(monolith_state *state, const char *filename);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_state_dbopen(monolith_state *state, const char *filename)
{
    int rc;
    rc = sqlite3_open(filename, &state-&gt;db);
    if(rc) {
        fprintf(stderr, "Could not open %s: %s\n",
                filename,
                sqlite3_errmsg(state-&gt;db));
        sqlite3_close(state-&gt;db);
        return 0;
    }
    return 1;
}</pre></code>
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>void monolith_state_dbclose(monolith_state *state);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>void monolith_state_dbclose(monolith_state *state)
{
    if(state-&gt;db == NULL) return;
    sqlite3_close(state-&gt;db);
}</pre></code>

<h5>19.7.2. A Note on Blobs</h5>

<p><a id="wm_000_3188"></a>NOTE: blobs opt to use the normal blob rather than the blob64 type, which takes
in a signed integer for size (<code>sqlite3_bind_blob</code>).
</p>
<p>This will potentially truncate some larger blobs.
This is done because the way to get size (sqlite3bytes) returns an
integer, and not an unsigned int.
<div><b><i>&lt;&lt;bind_blob_parameter&gt;&gt;=</i></b></div><pre><code>void *blob;
unsigned int blobsize;
blobsize = 0;
blob = NULL;
monolith_state_param_blob(param, &blob, &blobsize);
sqlite3_bind_blob(stmt, p, blob, (int)blobsize, NULL);
break;</pre></code>
<p></p>
<p>When reading a blob, an integer size is used to match the type in
<code>sqlite3_column_bytes</code>.
</p>
<p>The blob handled by sqlite is freed internally by SQLite, so the data must
be copied over and allocated.
<div><b><i>&lt;&lt;get_blob_parameter&gt;&gt;=</i></b></div><pre><code>int bytes;
int b;
const unsigned char *blob;
unsigned char *buf;
blob = (unsigned char *)sqlite3_column_blob(stmt, p);
bytes = sqlite3_column_bytes(stmt, p);
buf = malloc(bytes);
for(b = 0; b &lt; bytes; b++) buf[b] = blob[b];
monolith_state_param_blob_set(param, buf, bytes, free_the_blob);
break;</pre></code>
<p></p>
<p>The callback used to free the copied data is called <code>free_the_blob</code>. Just
a wrapper around the system <code>free</code>.
<div><b><i>&lt;&lt;static_function_declarations&gt;&gt;=</i></b></div><pre><code>static void free_the_blob(void *ud);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>static void free_the_blob(void *ud)
{
    free(ud);
}</pre></code>

<h5>19.7.3. Writing a Schema to a SQLite database</h5>

<p><a id="wm_000_3202"></a>The function <code>monolith_state_write_schema</code> writes a schema to disk. This
function typically gets called inside of a page save callback.
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_state_write_schema(monolith_state *ms,
                                monolith_state_schema *schema,
                                const char *tab,
                                unsigned int tablen,
                                const char *key,
                                unsigned int keylen);</pre></code>
<p></p>
<br>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_state_write_schema(monolith_state *ms,
                                monolith_state_schema *schema,
                                const char *tab,
                                unsigned int tablen,
                                const char *key,
                                unsigned int keylen)
{
    unsigned int nbytes_create;
    unsigned int nbytes_insert;
    char *tmp;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    int n;
    monolith_state_param *param;
    float *ftmp;
    int *itmp;
    char *stmp;
    int p;

    rc = 1;
    db = ms-&gt;db;

    if(db == NULL) return 0;

    nbytes_create = monolith_state_schema_sql_create(schema,
                                                     tab,
                                                     tablen,
                                                     NULL,
                                                     0);

    tmp = malloc(nbytes_create);

    monolith_state_schema_sql_create(schema, tab, tablen, tmp, 1);

    sqlite3_prepare(db, tmp, -1, &stmt, NULL);
    rc = sqlite3_step(stmt);

    if(rc != SQLITE_DONE) {
        fprintf(stderr, "SQLite error: %s\n", sqlite3_errmsg(db));
    }

    sqlite3_finalize(stmt);

    nbytes_insert = monolith_state_schema_sql_insert(schema,
                                                     tab,
                                                     tablen,
                                                     NULL,
                                                     0);
    if(nbytes_insert &gt; nbytes_create) {
        tmp = realloc(tmp, nbytes_insert);
    }
    monolith_state_schema_sql_insert(schema, tab, tablen, tmp, 1);

    sqlite3_prepare(db, tmp, -1, &stmt, NULL);

    sqlite3_bind_text(stmt, 1, key, keylen, NULL);

    p = 2;
    for(n = 0; n &lt; schema-&gt;nparams; n++) {
        param = &schema-&gt;params[n];
        switch(param-&gt;type) {
            case PARAM_NONE:
                break;
            case PARAM_FLOAT:
                monolith_state_param_float(param, &ftmp);
                sqlite3_bind_double(stmt, p, *ftmp);
                break;
            case PARAM_INT:
                monolith_state_param_int(param, &itmp);
                sqlite3_bind_double(stmt, p, *itmp);
                break;
            case PARAM_STRING:
                monolith_state_param_string(param, &stmp);
                sqlite3_bind_text(stmt, p, stmp, -1, NULL);
                break;
            case PARAM_MSTATE:
                stmp = param-&gt;ud;
                sqlite3_bind_text(stmt, p, stmp, 24, NULL);
                break;
            case PARAM_BLOB: {
&lt;&lt;bind_blob_parameter&gt;&gt;
            }
            default:
                break;
        }
        p++;
    }

    rc = sqlite3_step(stmt);
    if(rc != SQLITE_DONE) {
        fprintf(stderr, "SQLite error: %s\n", sqlite3_errmsg(db));
    }

    sqlite3_finalize(stmt);

    free(tmp);
    return 1;
}</pre></code>

<h5>19.7.4. Reading from a SQLite databse to a Schema</h5>

<p><a id="wm_000_3211"></a>The function <code>monolith_state_read_schema</code> reads a schema from disk.
This function typically gets called inside of a page load callback.
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_state_read_schema(monolith_state *ms,
                               monolith_state_schema *schema,
                               const char *tab,
                               unsigned int tablen,
                               const char *key,
                               unsigned int keylen);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_state_read_schema(monolith_state *ms,
                               monolith_state_schema *schema,
                               const char *tab,
                               unsigned int tablen,
                               const char *key,
                               unsigned int keylen)
{
    unsigned int nbytes;
    char *tmp;
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    int n;
    monolith_state_param *param;
    float ftmp;
    int itmp;
    int p;

    rc = 1;
    db = ms-&gt;db;

    if(db == NULL) return 0;

    nbytes = monolith_state_schema_sql_select(schema,
                                              tab, tablen,
                                              key, keylen, NULL, 0);

    tmp = malloc(nbytes);

    monolith_state_schema_sql_select(schema,
                                     tab, tablen,
                                     key, keylen, tmp, 1);
    sqlite3_prepare(db, tmp, -1, &stmt, NULL);
    rc = sqlite3_step(stmt);

    if(rc == SQLITE_DONE) {
        fprintf(stderr, "Key doesn't exist: ");
        fwrite(key, 1, keylen, stderr);
        fprintf(stderr, "\n");
        sqlite3_finalize(stmt);
        free(tmp);
        return 0;
    }

    p = 1;

    for(n = 0; n &lt; schema-&gt;nparams; n++) {
        param = &schema-&gt;params[n];
        switch(param-&gt;type) {
            case PARAM_NONE:
                break;
            case PARAM_FLOAT:
                ftmp = sqlite3_column_double(stmt, p);
                monolith_state_param_float_set(param, ftmp);
                break;
            case PARAM_INT:
                itmp = sqlite3_column_int(stmt, p);
                monolith_state_param_int_set(param, itmp);
                break;
            case PARAM_STRING:
                fprintf(stderr, "Oops. Not ready to read strings\n");
                /* monolith_state_param_string(param, &stmp); */
                /* sqlite3_bind_text(stmt, p, stmp, -1, NULL); */
                break;
            case PARAM_MSTATE: {
                const char *str;
                str = (const char *)sqlite3_column_text(stmt, p);
                monolith_state_param_mstate_set(param, str);
                break;
            }
            case PARAM_BLOB: {
&lt;&lt;get_blob_parameter&gt;&gt;
            }
            default:
                break;
        }
        p++;
    }

    sqlite3_finalize(stmt);
    free(tmp);
    return 1;
}</pre></code>

<h4>19.8. Opening/Closing a Monolith State database</h4>

<p><a id="wm_000_3219"></a>This opens the state stored inside of the monolith struct.
</p>

<h5>19.8.1. Opening The Monolith State</h5>

<p><a id="wm_000_3221"></a></p>

<h6>19.8.1.1. Opening State From C</h6>

<p><a id="wm_000_3222"></a>This can be done with the function <code>monolith_state_open</code>.
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_state_open(monolith_d *m, const char *filename);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_state_open(monolith_d *m, const char *filename)
{
    return monolith_state_dbopen(&m-&gt;state, filename);
}</pre></code>

<h6>19.8.1.2. Opening State from Scheme</h6>

<p><a id="wm_000_3228"></a>This can be done with the function <code>monolith:state-open</code>.
<div><b><i>&lt;&lt;primitive_entries&gt;&gt;=</i></b></div><pre><code>{"monolith:state-open", pp_state_open, 1, 1, {STR,___,___}},</pre></code>
<div><b><i>&lt;&lt;scheme_functions&gt;&gt;=</i></b></div><pre><code>static cell pp_state_open(cell p) {
    monolith_d *m;
    const char *filename;
    int rc;

    filename = string(car(p));
    m = monolith_data_get();
    rc = monolith_state_open(m, filename);
    if(!rc) error("Could not open file", car(p));
    return UNSPECIFIC;
}</pre></code>

<h6>19.8.1.3. Opening State from Janet</h6>

<p><a id="wm_000_3234"></a>This is done with <code>monolith/state-open</code>.
<div><b><i>&lt;&lt;core_janet_entries&gt;&gt;=</i></b></div><pre><code>{
"monolith/state-open",
j_state_open,
"Opens a state database.\n"
},</pre></code>
<div><b><i>&lt;&lt;janet_functions&gt;&gt;=</i></b></div><pre><code>static Janet j_state_open(int32_t argc, Janet *argv)
{
    const char *filename;
    int rc;
    monolith_d *m;

    janet_fixarity(argc, 1);
    filename = (const char *)janet_getstring(argv, 0);

    m = monolith_data_get();

    rc = monolith_state_open(m, filename);
    if (!rc) fprintf(stderr,
                    "Could not open file '%s'",
                    filename);

    return janet_wrap_nil();
}</pre></code>

<h5>19.8.2. Closing Monolith State</h5>

<p><a id="wm_000_3240"></a></p>

<h6>19.8.2.1. Closing the State from C</h6>

<p><a id="wm_000_3241"></a>This can be done with <code>monolith_state_close</code>
#+NAME: function_declarations
<pre><code>void monolith_state_close(monolith_d *m);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>void monolith_state_close(monolith_d *m)
{
    monolith_state_dbclose(&m-&gt;state);
}</pre></code>

<h6>19.8.2.2. Closing the State from Scheme</h6>

<p><a id="wm_000_3247"></a>State can be explicitely closed with <code>monolith:state-close</code>.
<div><b><i>&lt;&lt;primitive_entries&gt;&gt;=</i></b></div><pre><code>{"monolith:state-close", pp_state_close, 0, 0, {___,___,___}},</pre></code>
<div><b><i>&lt;&lt;scheme_functions&gt;&gt;=</i></b></div><pre><code>static cell pp_state_close(cell p) {
    monolith_d *m;
    m = monolith_data_get();
    monolith_state_close(m);
    return UNSPECIFIC;
}</pre></code>

<h6>19.8.2.3. Opening State from Janet</h6>

<p><a id="wm_000_3253"></a>This is done with <code>monolith/state-close</code>.
<div><b><i>&lt;&lt;core_janet_entries&gt;&gt;=</i></b></div><pre><code>{
"monolith/state-close",
j_state_close,
"Closes a state database.\n"
},</pre></code>
<div><b><i>&lt;&lt;janet_functions&gt;&gt;=</i></b></div><pre><code>static Janet j_state_close(int32_t argc, Janet *argv)
{
    monolith_d *m;

    janet_fixarity(argc, 0);
    m = monolith_data_get();
    monolith_state_close(m);

    return janet_wrap_nil();
}</pre></code>

<h4>19.9. Raw SQLite commands on open state file</h4>

<p><a id="wm_000_3259"></a>Occasionally, it is desirable to evaluate raw sqlite
commands on an open state file.
</p>

<h5>19.9.1. In C</h5>

<p><a id="wm_000_3261"></a>This can be done with <code>monolith_state_sql</code>.
<div><b><i>&lt;&lt;function_declarations&gt;&gt;=</i></b></div><pre><code>int monolith_state_sql(monolith_d *m, const char *cmd);</pre></code>
<div><b><i>&lt;&lt;functions&gt;&gt;=</i></b></div><pre><code>int monolith_state_sql(monolith_d *m, const char *cmd)
{
    monolith_state *state;
    sqlite3 *db;

    state = &m-&gt;state;
    db = state-&gt;db;

    if (db == NULL) return 0;

    sqlite3_exec(db, cmd, NULL, NULL, NULL);

    return 1;
}</pre></code>

<h5>19.9.2. In Scheme</h5>

<p><a id="wm_000_3267"></a>This can be done with <code>monolith:state-sql</code>
#+NAME: primitive_entries
<pre><code>{"monolith:state-sql", pp_state_sql, 1, 1, {STR,___,___}},</pre></code>
<div><b><i>&lt;&lt;scheme_functions&gt;&gt;=</i></b></div><pre><code>static cell pp_state_sql(cell p)
{
    monolith_d *m;
    const char *cmd;

    cmd = string(car(p));
    m = monolith_data_get();

    monolith_state_sql(m, cmd);

    return UNSPECIFIC;
}</pre></code>
<p></p>
<br>
<p><hr>

<a href="/proj/monolith/program/wm_000_2353">prev</a> | <a href="/proj/monolith/program/wm_000">home</a> | <a href="/proj/monolith/program/wm_000_3273">next</a></p>
</div>
</body>
</html>
