<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<link rel="stylesheet" href="/css/style.css">

</head>
<body>
<div id="main">

<h3>97. cabtmp</h3>

<p><a id="wm_038_0404"></a><code>cabtmp</code> creates a temporary cable and initialize it to be
signal <code>in</code>. <code>cabtmp</code> will first try to snatch a buffer from
the buffer pool. If there are no free buffers in the pool,
it will allocate one. When the cable is no longer being
used, it <b>must</b> be explicitly freed with <code>cabclr</code>.
</p>
<p><code>cabtmp</code> is currently the most ideal way to handle signals
that modulate many things at once (global clocks, LFOs,
signals processed by filter banks, etc). In practice, a
signal would be copied using <code>cabtmp</code>, held with <code>bhold</code>,
then stored using <code>cabset</code> and maybe <code>nextfree</code> if the
register didn't matter. From there <code>cabget</code> would be
used to efficiently retrieve the signal, and then
<code>cabclr</code> would be called when the signal was no longer
being needed.
</p>
<div><b><i>&lt;&lt;ugens-top&gt;&gt;=</i></b></div><pre><code>(define (cabtmp in)
  (param in)
  (rvl "cabtmp"))</pre></code>
<p></p>
<br>
<p><hr>

<a href="/proj/monolith/program/wm_038_0006">prev</a> | <a href="/proj/monolith/program/wm_038">home</a> | <a href="/proj/monolith/program/wm_038_0408">next</a></p>
</div>
</body>
</html>
