<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<link rel="stylesheet" href="/css/style.css">

</head>
<body>
<div id="main">

<h3>4. Line16 Core Functions</h3>

<p><a id="wm_012_0323"></a></p>

<h4>4.1. Draw Point Bank</h4>

<p><a id="wm_012_0324"></a>Given a point and position, will draw the slot on the grid.
</p>
<p>In progress. Right now, we just mark if things are active
or not.
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_draw_point(line16_point *pt,
                              int pos,
                              monolith_page_mstate *m);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void line16_draw_point(line16_point *pt,
                              int pos,
                              monolith_page_mstate *ms)
{
   if(pt-&gt;active) {
       monolith_page_mstate_led_set(ms, pos, 1, 1);
   } else {
       monolith_page_mstate_led_set(ms, pos, 1, 0);
   }
   line16_draw_point_type(pt, pos, ms);
}</pre></code>

<h4>4.2. Draw Point Type</h4>

<p><a id="wm_012_0330"></a><div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_draw_point_type(line16_point *pt,
                                   int pos,
                                   monolith_page_mstate *m);</pre></code>
<p></p>
<p>Because the type flag has a special bit reserved for trigger
mode, the type needs to be bitmasked in order to work.
</p>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void line16_draw_point_type(line16_point *pt,
                                   int pos,
                                   monolith_page_mstate *m)
{
    int y;
    int type;
    type = pt-&gt;type & 3;
    for(y = 0; y &lt; 4; y++) {
        if(type == y) {
            monolith_page_mstate_led_set(m, pos, y + 2, 1);
        } else {
            monolith_page_mstate_led_set(m, pos, y + 2, 0);
        }
    }
}</pre></code>

<h4>4.3. Draw Point Togmode</h4>

<p><a id="wm_012_0336"></a><div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_draw_point_togmode(line16_point *pt,
                                      monolith_page_mstate *m);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void line16_draw_point_togmode(line16_point *pt,
                                      monolith_page_mstate *m)
{
    int t;
    t = pt-&gt;type & 1&lt;&lt;2;
    monolith_page_mstate_led_set(m, 0, 7, t);
}</pre></code>

<h4>4.4. Draw Selected Line</h4>

<p><a id="wm_012_0341"></a>Draws the select line on the control panel, located in the
bottom right corner.
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_draw_selected_line(int selected,
                                      monolith_page_mstate *m);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void line16_draw_selected_line(int selected,
                                      monolith_page_mstate *m)
{
    int t;
    int s;
    for (t = 0; t &lt; 4; t++) {
        s = (selected & (1 &lt;&lt; t)) != 0;
        monolith_page_mstate_led_set(m,
                                     12 + t, 7,
                                     s);
    }
}</pre></code>

<h4>4.5. Redraw all points</h4>

<p><a id="wm_012_0347"></a>Will redraw all points on the grid. At the very least, this
will be called at creation.
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_redraw_points(page_line16_d *l);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void line16_redraw_points(page_line16_d *l)
{
    int pt;
    line16_point *points;

    points = l-&gt;lines[l-&gt;selected_line].points;

    for(pt = 0; pt &lt; 16; pt++) {
        line16_draw_point(&points[pt],
                          pt,
                          l-&gt;mstate);
    }
}</pre></code>

<h4>4.6. Display Point Values</h4>

<p><a id="wm_012_0353"></a>Given a point, this will display the point values on the
arc.
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_display_vals(line16_point *pt,
                                monolith_page_arcstate *as);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void line16_display_vals(line16_point *pt,
                                monolith_page_arcstate *as)
{
    monolith_arcstate_mapval(as, 0, pt-&gt;val);
    monolith_arcstate_mapval(as, 1, pt-&gt;dur);
    monolith_arcstate_mapval(as, 2, pt-&gt;aux[0]);
    monolith_arcstate_mapval(as, 3, pt-&gt;aux[1]);
}</pre></code>

<h4>4.7. Select a point</h4>

<p><a id="wm_012_0359"></a>This will select a point, and update the UI.
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_select_point(page_line16_d *l, int pt);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void line16_select_point(page_line16_d *l, int pt)
{
    line16_line *line;
    if(pt &lt; 0 || pt &gt;= 16) return;
    line = &l-&gt;lines[l-&gt;selected_line];
    l-&gt;selected_point = pt;
    line16_display_vals(&line-&gt;points[pt], l-&gt;arcstate);
    line16_draw_point_togmode(&line-&gt;points[pt], l-&gt;mstate);
    monolith_page_mstate_led_row16(l-&gt;mstate, 0, 1&lt;&lt;pt);
}</pre></code>
<p></p>
<p>Point can be retrieved using <code>line16_select_point_get</code>.
</p>
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static int line16_select_point_get(page_line16_d *l);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static int line16_select_point_get(page_line16_d *l)
{
    return l-&gt;selected_point;
}</pre></code>

<h4>4.8. Compute a Line</h4>

<p><a id="wm_012_0370"></a>This computes a line segment, which is then written
to the internal block.
</p>

<h5>4.8.1. Main Callback</h5>

<p><a id="wm_012_0372"></a><div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_compute_line(page_line16_d *l,
                                pw_patch *p,
                                pw_cable *in);</pre></code>
<p>A line is a connection between to points. At the time of
writing, this connection is limited to linear interpolation.
Exponential mapping could be in the future, but to get
things started, linear.
</p>
<p>A line has three main components. A point A, a point B, and
a duration between the two. A counter keeps tracker of the
current line position, which is then used to derive
position.
</p>
<p>When the position has reached the length of the duration,
a new line segment begins! The points, duration, and counter
are updated.
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void update_counters(page_line16_d *l)
{
    l-&gt;timer += l-&gt;onedsr * l-&gt;rate;
    /* to prevent overflow, circle between values */
    if(l-&gt;timer &gt; 10) {
        l-&gt;timer = 1; /* low but still slow */
    }

    /* do it again for aux timer */
    l-&gt;aux_timer += l-&gt;onedsr * l-&gt;rate;

    if(l-&gt;aux_timer &gt; 10) {
        l-&gt;aux_timer = 1;
    }
}

static void line16_compute_line(page_line16_d *l,
                                pw_patch *p,
                                pw_cable *in)
{
    int blksize;
    int s;
    pw_cable *out;
    PWFLT dur;
    PWFLT o;
    line16_point *pt_a;
    line16_point *pt_b;

    blksize = pw_patch_blksize(p);
    line16_state_apply(l);
    out = &l-&gt;out;

    if (l-&gt;pointpos &lt; 0) {
        line16_start_line(l);
        line16_aux_cache_udpate(l);
        line16_update_pointpos(l);
        if(l-&gt;pointpos &lt; 0) {
            for(s = 0; s &lt; blksize; s++) {
                pw_cable_set(out, s, 0);
                update_counters(l);
            }
            return;
        }
    }

    pt_a = line16_get_point(l, l-&gt;pointpos);
    pt_b = line16_get_point(l, l-&gt;nextpoint);

    if (pt_a == NULL && pt_b == NULL) return;

    for (s = 0; s &lt; blksize; s++) {
        if (pw_cable_get(in, s) != 0) {
            l-&gt;trig = 1;
        }
        if (l-&gt;pointpos &lt; 0) {
            o = 0;
        } else {
            if (l-&gt;pointpos &lt; 0) {
                o = 0;
            } else {
                pt_a = line16_get_point(l, l-&gt;pointpos);
                pt_b = line16_get_point(l, l-&gt;nextpoint);

                dur = line16_durscale(l, pt_a-&gt;dur);

                if (l-&gt;counter &gt;= dur) {
                    line16_begin_segment(l);
                    pt_a = line16_get_point(l, l-&gt;pointpos);
                    pt_b = line16_get_point(l, l-&gt;nextpoint);
                    line16_aux_cache_udpate(l);
                    line16_update_pointpos(l);
                }

                if (l-&gt;pointpos &gt;= 0) {
                    /* calculate the line */
                    if ((pt_a-&gt;type & 4) && l-&gt;trig == 0) {
                        o = pt_a-&gt;val;
                    } else {
                        switch (pt_a-&gt;type & 3) {
                            case SLOPE_LINEAR:
                                o = line_linear(l,
                                                pt_a, pt_b,
                                                l-&gt;counter);
                                break;
                            case SLOPE_EXP_POSITIVE:
                                o = line_exp_pos(l,
                                                 pt_a, pt_b,
                                                 l-&gt;counter,
                                                 l-&gt;aux_cache[0]);
                                break;
                            case SLOPE_EXP_NEGATIVE:
                                o = line_exp_neg(l,
                                                 pt_a, pt_b,
                                                 l-&gt;counter,
                                                 l-&gt;aux_cache[0]);
                                break;
                            case SLOPE_BEZIER:
                                o = line_bezier(l,
                                                pt_a, pt_b,
                                                l-&gt;counter,
                                                l-&gt;aux_cache[0],
                                                l-&gt;aux_cache[1]);
                                break;
                            default:
                                o = line_linear(l,
                                                pt_a, pt_b,
                                                l-&gt;counter);
                                break;
                        }

                        l-&gt;counter += l-&gt;onedsr *
                            l-&gt;rate *
                            pt_a-&gt;rate;
                    }
                } else {
                    o = 0;
                }
            }
        }
        pw_cable_set(out, s, o);
        update_counters(l);
    }
}</pre></code>

<h5>4.8.2. Line Slope Functions</h5>

<p><a id="wm_012_0378"></a></p>

<h6>4.8.2.1. Linear</h6>

<p><a id="wm_012_0379"></a><div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static PWFLT line_linear(page_line16_d *l,
                         line16_point *pt_a,
                         line16_point *pt_b,
                         PWFLT counter);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static PWFLT line_linear(page_line16_d *l,
                         line16_point *pt_a,
                         line16_point *pt_b,
                         PWFLT counter)
{
    PWFLT a, b;
    PWFLT o;
    PWFLT dur;

    a = pt_a-&gt;val;
    b = pt_b-&gt;val;
    dur = line16_durscale(l, pt_a-&gt;dur);

    o = a + (b - a) * (counter / dur);

    return o;
}</pre></code>

<h6>4.8.2.2. Exponential Positive</h6>

<p><a id="wm_012_0384"></a><div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static PWFLT line_exp_pos(page_line16_d *l,
                          line16_point *pt_a,
                          line16_point *pt_b,
                          PWFLT counter,
                          PWFLT aux);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static PWFLT line_exp_pos(page_line16_d *l,
                          line16_point *pt_a,
                          line16_point *pt_b,
                          PWFLT counter,
                          PWFLT aux)
{
    PWFLT a, b;
    PWFLT o;
    PWFLT slp;
    PWFLT dur;

    a = pt_a-&gt;val;
    b = pt_b-&gt;val;
    dur = line16_durscale(l, pt_a-&gt;dur);

    slp = 1 + (15 * aux);

    o = a + (b - a) *
        (1 - exp(counter * slp / dur)) /
        (1 - exp(slp));

    return o;
}</pre></code>

<h6>4.8.2.3. Exponential Negative</h6>

<p><a id="wm_012_0389"></a><div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static PWFLT line_exp_neg(page_line16_d *l,
                          line16_point *pt_a,
                          line16_point *pt_b,
                          PWFLT counter,
                          PWFLT aux);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static PWFLT line_exp_neg(page_line16_d *l,
                          line16_point *pt_a,
                          line16_point *pt_b,
                          PWFLT counter,
                          PWFLT aux)
{
    PWFLT a, b;
    PWFLT o;
    PWFLT slp;
    PWFLT dur;

    a = pt_a-&gt;val;
    b = pt_b-&gt;val;
    dur = line16_durscale(l, pt_a-&gt;dur);

    slp = -1 - (15 * aux);

    o = a + (b - a) *
        (1 - exp(counter * slp / dur)) /
        (1 - exp(slp));

    return o;
}</pre></code>

<h6>4.8.2.4. Bezier</h6>

<p><a id="wm_012_0394"></a></p>
<p>The reference equation:
</p>
<p>B(t) = (1 - t)^2<b>P0 + 2</b>(1 - t)P1 + t^2P2
</p>
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static PWFLT line_bezier(page_line16_d *l,
                         line16_point *pt_a,
                         line16_point *pt_b,
                         PWFLT counter,
                         PWFLT aux1,
                         PWFLT aux2);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static PWFLT line_bezier(page_line16_d *l,
                         line16_point *pt_a,
                         line16_point *pt_b,
                         PWFLT counter,
                         PWFLT aux1,
                         PWFLT aux2)
{
    PWFLT a, b;
    PWFLT o;
    PWFLT x[3];
    PWFLT y[3];
    PWFLT dur;
    PWFLT val;
    PWFLT t;

    a = pt_a-&gt;val;
    b = pt_b-&gt;val;
    dur = line16_durscale(l, pt_a-&gt;dur);

    /* some light clamping... in case of weirdness */
    val = aux1;
    if(val &lt; 0.001) val = 0.001;
    if(val &gt; 0.999) val = 0.99;

    x[0] = 0;
    y[0] = a;

    x[1] = (dur * val);
    y[1]= aux2;

    x[2] = dur;
    y[2] = b;

    t = find_t(x[0], x[1], x[2], counter);

    o = (1.0 - t) * (1.0 - t) * y[0] +
        2.0 * (1.0 - t) * t * y[1] +
        t * t * y[2];

    return o;
}</pre></code>
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static PWFLT find_t(PWFLT x0, PWFLT x1, PWFLT x2, PWFLT x);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static PWFLT find_t(PWFLT x0, PWFLT x1, PWFLT x2, PWFLT x)
{
    PWFLT a;
    PWFLT b;
    PWFLT c;
    PWFLT out;
    PWFLT det;

    a = (x0 - 2.0 * x1 + x2);
    b = 2.0 * (-x0 + x1);
    c = x0 - x;

    out = 0;
    if(a) {
        det = b * b - 4 * a * c;
        if(det &gt; 0)
            out = ((-b + sqrt(det))/(2.0 * a));
        else
            out = 0;
    } else {
        if(b != 0) out = (x - x0)/b;
    }
    return out;
}</pre></code>

<h4>4.9. DONE Compute a Local Line</h4>

<p><a id="wm_012_0404"></a>CLOSED: [2020-01-03 Fri 14:16]
This function is used to compute a single line instance. It
will compute once per block.
</p>
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>void line16_compute_localline(line16_localline *localline,
                              pw_patch *patch,
                              pw_cable *in,
                              pw_cable *out);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>void line16_compute_localline(line16_localline *ll,
                              pw_patch *patch,
                              pw_cable *in,
                              pw_cable *out)
{
    int blksize;
    int s;
    /* pw_cable *out; */
    PWFLT dur;
    PWFLT o;
    line16_point *pt_a;
    line16_point *pt_b;
    line16_line *line;
    page_line16_d *pg;

    blksize = pw_patch_blksize(patch);
    /* line16_state_apply(l); */
    /* out = &l-&gt;out; */

    line = ll-&gt;l;
    pg = ll-&gt;pg;

    if (ll-&gt;pointpos &lt; 0) {
        line16_start_line_local(ll);
        /* line16_update_pointpos(l); */
        pt_a = line16_line_point(line, ll-&gt;pointpos);
        if (pt_a != NULL) {
            ll-&gt;aux[0] = pt_a-&gt;aux[0];
            ll-&gt;aux[1] = pt_a-&gt;aux[1];
        }
        if(ll-&gt;pointpos &lt; 0) {
            for(s = 0; s &lt; blksize; s++) {
                pw_cable_set(out, s, 0);
                /* update_counters(l); */
            }
            return;
        }
    }

    pt_a = line16_line_point(line, ll-&gt;pointpos);
    pt_b = line16_line_point(line, ll-&gt;nextpoint);

    if (pt_a == NULL && pt_b == NULL) return;

    for (s = 0; s &lt; blksize; s++) {
        if (pw_cable_get(in, s) != 0) ll-&gt;trig = 1;
        if (ll-&gt;pointpos &lt; 0) {
            o = 0;
        } else {
            if (ll-&gt;pointpos &lt; 0) {
                o = 0;
            } else {
                pt_a = line16_line_point(line, ll-&gt;pointpos);
                pt_b = line16_line_point(line, ll-&gt;nextpoint);

                dur = line16_durscale(pg, pt_a-&gt;dur);

                if (ll-&gt;counter &gt;= dur) {
                    line16_begin_local(ll);
                    pt_a = line16_line_point(line, ll-&gt;pointpos);
                    pt_b = line16_line_point(line, ll-&gt;nextpoint);
                    /* line16_aux_cache_udpate(l); */
                    /* line16_update_pointpos(l); */
                    ll-&gt;aux[0] = pt_a-&gt;aux[0];
                    ll-&gt;aux[1] = pt_a-&gt;aux[1];
                }

                if (ll-&gt;pointpos &gt;= 0) {
                    /* calculate the line */
                    if ((pt_a-&gt;type & 4) && ll-&gt;trig == 0) {
                        o = pt_a-&gt;val;
                    } else {
                        switch (pt_a-&gt;type & 3) {
                            case SLOPE_LINEAR:
                                o = line_linear(pg,
                                                pt_a, pt_b,
                                                ll-&gt;counter);
                                break;
                            case SLOPE_EXP_POSITIVE:
                                o = line_exp_pos(pg,
                                                 pt_a, pt_b,
                                                 ll-&gt;counter,
                                                 ll-&gt;aux[0]);
                                break;
                            case SLOPE_EXP_NEGATIVE:
                                o = line_exp_neg(pg,
                                                 pt_a, pt_b,
                                                 ll-&gt;counter,
                                                 ll-&gt;aux[0]);
                                break;
                            case SLOPE_BEZIER:
                                o = line_bezier(pg,
                                                pt_a, pt_b,
                                                ll-&gt;counter,
                                                ll-&gt;aux[0],
                                                ll-&gt;aux[1]);
                                break;
                            default:
                                o = line_linear(pg,
                                                pt_a, pt_b,
                                                ll-&gt;counter);
                                break;
                        }

                        ll-&gt;counter += pg-&gt;onedsr *
                            pg-&gt;rate *
                            pt_a-&gt;rate;
                    }
                } else {
                    o = 0;
                }
            }
        }
        pw_cable_set(out, s, o);
        /* update_counters(l); */
    }
}</pre></code>
<p>This line is self contained and ancillary to the main line
sequence. For this reason it is known as "local".
</p>
<p>The biggest difference between the local line and the
main line is that the local line can only loop between
itself.
</p>
<p>The local line callback expects an input and output cable.
The input cable contains a trigger signal for points that
wait. The output cable is where the line will write the
signal to.
</p>
<p>As the name would suggest, the local line utilizes local
variables. Local variables are stored in a struct and are
passed to the line callback.
</p>
<p>Some Local variables I see here include:
</p>
<p>- counter
- pointpos
- nextpoint
- trig
- local aux cache
</p>
<div><b><i>&lt;&lt;line16_typedefs&gt;&gt;=</i></b></div><pre><code>typedef struct line16_localline line16_localline;</pre></code>
<div><b><i>&lt;&lt;line16_struct&gt;&gt;=</i></b></div><pre><code>struct line16_localline {
    page_line16_d *pg;
    line16_line *l;
    PWFLT counter;
    int pointpos;
    int nextpoint;
    int trig;
    PWFLT aux[2];
};</pre></code>
<p></p>
<p>This struct is initialized with <code>line16_localline_init</code>.
</p>
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>void line16_localline_init(line16_localline *l,
                           line16_line *line,
                           page_line16_d *pg);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>void line16_localline_init(line16_localline *l,
                           line16_line *line,
                           page_line16_d *pg)
{
    l-&gt;counter = 0;
    l-&gt;pointpos = -1;
    l-&gt;nextpoint = -1;
    l-&gt;trig = 0;
    l-&gt;l = line;
    l-&gt;pg = pg;
    l-&gt;aux[0] = 0;
    l-&gt;aux[1] = 0;
}</pre></code>

<h4>4.10. Find Next Point (Main and Local)</h4>

<p><a id="wm_012_0420"></a>This will return the next available point. This will start
at the current point, and iterate through the points in
ascending order until a point has been found. This can
include wrapping back to the beginning, if need be.
</p>
<p>If there are no active points to be found, this function
will return a negative value. If there is only one active
point, it means that the current point will be returned.
</p>

<h5>4.10.1. Main</h5>

<p><a id="wm_012_0422"></a><div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static int line16_find_next(page_line16_d *l, int after);</pre></code>
<p>In the for loop, n starts on 1 in order to skip the
current point position.
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static int line16_find_next(page_line16_d *l, int after)
{
    line16_line *line;
    line = &l-&gt;lines[l-&gt;playing_line];
    return line16_line_find_next(line, after);
}</pre></code>

<h5>4.10.2. Local</h5>

<p><a id="wm_012_0428"></a><div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static int line16_line_find_next(line16_line *l, int after);</pre></code>
<p>In the for loop, n starts on 1 in order to skip the
current point position.
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static int line16_line_find_next(line16_line *l, int after)
{
    int pp;
    int n;
    int pos;
    line16_point *pt;

    pp = after;

    if(l-&gt;nactive == 0) {
        return -1;
    } else if(l-&gt;nactive == 1 && pp &gt;= 0) {
        return pp;
    }

    for(n = 0; n &lt; 16; n++) {
        pos = (pp + n + 1) % 16;
        pt = &l-&gt;points[pos];
        if(pt-&gt;active) return pos;
    }

    return -1;
}</pre></code>

<h4>4.11. Increment Value</h4>

<p><a id="wm_012_0434"></a>Increments a value up or down and returns it. This includes
clamping value to be in range 0-1.
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static PWFLT line16_increment(PWFLT val, int delta);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static PWFLT line16_increment(PWFLT val, int delta)
{
    val += 0.001 * delta;
    if(val &lt; 0) val = 0;
    else if(val &gt; 1) val = 1;

    return val;
}</pre></code>

<h4>4.12. Get Point (Main and Local)</h4>

<p><a id="wm_012_0440"></a>Given an index value, retrieve the point. If point is
out of range, return NULL.
</p>

<h5>4.12.1. Main Point Getter</h5>

<p><a id="wm_012_0442"></a>For use in the main callback.
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>line16_point * line16_get_point(page_line16_d *l, int pt);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>line16_point * line16_get_point(page_line16_d *l, int pt)
{
    line16_line *line;

    line = &l-&gt;lines[l-&gt;playing_line];

    return line16_line_point(line, pt);
}</pre></code>

<h5>4.12.2. Get Local Point</h5>

<p><a id="wm_012_0448"></a>Get a point from a particular line.
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>line16_point * line16_line_point(line16_line *l, int pt);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>line16_point * line16_line_point(line16_line *l, int pt)
{
    if(pt &lt; 0 || pt &gt;= 16) return NULL;

    return &l-&gt;points[pt];
}</pre></code>

<h4>4.13. Point Setters/Getters</h4>

<p><a id="wm_012_0454"></a>Where <code>l</code> is the page data, <code>line</code> is the line number
(in case we implement multiple lines), <code>pos</code> is the
point position on the line, and <code>val</code> is the value to be
set.
</p>

<h5>4.13.1. line16_point_val_set</h5>

<p><a id="wm_012_0456"></a><div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_point_val_set(page_line16_d *l,
                                 int linepos,
                                 int pos,
                                 PWFLT val);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void line16_point_val_set(page_line16_d *l,
                                 int linepos,
                                 int pos,
                                 PWFLT val)
{
    line16_line *line;
    int lite;

    if (val &lt; 0) val = 0;
    if (val &gt; 1) val = 1;

    if (pos &lt; 0) pos = 0;
    if (pos &gt; 15) pos = 15;

    if (linepos &lt; 0) linepos = 0;
    if (linepos &gt; 15) linepos = 15;

    line = &l-&gt;lines[linepos];
    line-&gt;points[pos].val = val;

    lite =
        linepos == l-&gt;selected_line &&
        pos == l-&gt;selected_point;

    if (lite) {
        monolith_arcstate_mapval(l-&gt;arcstate, 0, val);
    }
}</pre></code>

<h5>4.13.2. line16_point_val_get</h5>

<p><a id="wm_012_0461"></a><div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static PWFLT line16_point_val_get(page_line16_d *l,
                                  int linepos,
                                  int pos);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static PWFLT line16_point_val_get(page_line16_d *l,
                                  int linepos,
                                  int pos)
{
    line16_line *line;

    if(pos &lt; 0) pos = 0;
    if(pos &gt; 15) pos = 15;

    if (linepos &lt; 0) linepos = 0;
    if (linepos &gt; 15) linepos = 15;

    line = &l-&gt;lines[linepos];

    return line-&gt;points[pos].val;
}</pre></code>

<h5>4.13.3. line16_point_dur_set</h5>

<p><a id="wm_012_0466"></a><div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_point_dur_set(page_line16_d *l,
                                 int linepos,
                                 int pos,
                                 PWFLT dur);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void line16_point_dur_set(page_line16_d *l,
                                 int linepos,
                                 int pos,
                                 PWFLT dur)
{
    line16_line *line;
    int lite;

    if(dur &lt; 0) dur = 0;
    if(dur &gt; 1) dur = 1;

    if(pos &lt; 0) pos = 0;
    if(pos &gt; 15) pos = 15;

    if(linepos &lt; 0) linepos = 0;
    if(linepos &gt; 15) linepos = 15;

    line = &l-&gt;lines[linepos];
    line-&gt;points[pos].dur = dur;

    lite =
        linepos == l-&gt;selected_line &&
        pos == l-&gt;selected_point;

    if(lite) {
        monolith_arcstate_mapval(l-&gt;arcstate, 1, dur);
    }
}</pre></code>

<h5>4.13.4. line16_point_dur_get</h5>

<p><a id="wm_012_0471"></a><div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static PWFLT line16_point_dur_get(page_line16_d *l,
                                  int line,
                                  int pos);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static PWFLT line16_point_dur_get(page_line16_d *l,
                                  int linepos,
                                  int pos)
{
    line16_line *line;

    if(pos &lt; 0) pos = 0;
    if(pos &gt; 15) pos = 15;

    if(linepos &lt; 0) linepos = 0;
    if(linepos &gt; 15) linepos = 15;

    line = &l-&gt;lines[linepos];

    return line-&gt;points[pos].dur;
}</pre></code>

<h5>4.13.5. line16_point_aux_set</h5>

<p><a id="wm_012_0476"></a><div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_point_aux_set(page_line16_d *l,
                                 int linepos,
                                 int pos,
                                 int aux,
                                 PWFLT val);</pre></code>
<p>Because this can set the monome, this function is rate
limited. This is especially important for cases when the
aux value is being set by a patchwerk node.
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void line16_point_aux_set(page_line16_d *l,
                                 int linepos,
                                 int pos,
                                 int aux,
                                 PWFLT val)
{
    line16_line *line;
    int lite;

    if(val &lt; 0) val = 0;
    if(val &gt; 1) val = 1;

    if(pos &lt; 0) pos = 0;
    if(pos &gt; 15) pos = 15;

    if(aux &lt; 0) aux = 0;
    if(aux &gt; 1) aux = 1;

    if(linepos &lt; 0) linepos = 0;
    if(linepos &gt; 15) linepos = 15;

    line = &l-&gt;lines[linepos];

    line-&gt;points[pos].aux[aux] = val;

    lite =
        linepos == l-&gt;selected_line &&
        pos == l-&gt;selected_point;

    if (lite) {
        if(l-&gt;aux_timer &lt; AUX_MIN_DUR) return;
        monolith_arcstate_mapval(l-&gt;arcstate,
                                 2 + aux,
                                 val);
        l-&gt;aux_timer = 0;
    }
}</pre></code>

<h5>4.13.6. line16_point_aux_get</h5>

<p><a id="wm_012_0482"></a><div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static PWFLT line16_point_aux_get(page_line16_d *l,
                                  int linepos,
                                  int pos,
                                  int aux);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static PWFLT line16_point_aux_get(page_line16_d *l,
                                  int linepos,
                                  int pos,
                                  int aux)
{
    line16_line *line;
    if (pos &lt; 0) pos = 0;
    if (pos &gt; 15) pos = 15;

    if (linepos &lt; 0) linepos = 0;
    if (linepos &gt; 15) linepos = 15;

    line = &l-&gt;lines[linepos];

    return line-&gt;points[pos].aux[aux];
}</pre></code>

<h5>4.13.7. line16_point_status_set</h5>

<p><a id="wm_012_0487"></a><div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_point_status_set(page_line16_d *l,
                                    int line,
                                    int pos,
                                    int status);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void line16_point_status_set(page_line16_d *l,
                                    int line,
                                    int pos,
                                    int status)
{
    if (pos &lt; 0) pos = 0;
    if (pos &gt; 15) pos = 15;

    if (line == l-&gt;selected_line) {
        monolith_page_mstate_led_set(l-&gt;mstate,
                                    pos, 1, (status != 0));
        /* TODO state_set should know which line, no? */
        line16_state_set(l, pos, status);
    }
}</pre></code>

<h5>4.13.8. line16_point_status_get</h5>

<p><a id="wm_012_0492"></a><div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static int line16_point_status_get(page_line16_d *l,
                                   int linepos,
                                   int pos);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static int line16_point_status_get(page_line16_d *l,
                                   int linepos,
                                   int pos)
{
    line16_line *line;

    if (pos &lt; 0) pos = 0;
    if (pos &gt; 15) pos = 15;

    if (linepos &lt; 0) linepos = 0;
    if (linepos &gt; 15) linepos = 15;

    line = &l-&gt;lines[linepos];

    return line-&gt;points[pos].active;
}</pre></code>

<h5>4.13.9. line16_point_type_set</h5>

<p><a id="wm_012_0497"></a><div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_point_type_set(page_line16_d *l,
                                  int linepos,
                                  int pos,
                                  int type);</pre></code>
<p>Because the type flag stores extra data in the upper bits
(like the trigger flag), setting must be done to only change
the lower two bits.
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void line16_point_type_set(page_line16_d *l,
                                  int linepos,
                                  int pos,
                                  int type)
{
    int tmp;
    line16_line *line;

    if(pos &lt; 0) pos = 0;
    if(pos &gt; 15) pos = 15;

    if (linepos &lt; 0) linepos = 0;
    if (linepos &gt; 15) linepos = 15;

    line = &l-&gt;lines[linepos];

    tmp = line-&gt;points[pos].type;
    tmp &= ~3; /* clear last two bits */
    tmp |= type & 3; /* mask + set */
    line-&gt;points[pos].type = tmp;
}</pre></code>

<h5>4.13.10. line16_point_type_get</h5>

<p><a id="wm_012_0503"></a><div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static int line16_point_type_get(page_line16_d *l,
                                   int linepos,
                                   int pos);</pre></code>
<p>The value is AND'd, because other data is stored in the
upper bits.
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static int line16_point_type_get(page_line16_d *l,
                                 int linepos,
                                 int pos)
{
    line16_line *line;

    if (linepos &lt; 0) linepos = 0;
    if (linepos &gt; 15) linepos = 15;

    line = &l-&gt;lines[linepos];

    if(pos &lt; 0) pos = 0;
    if(pos &gt; 15) pos = 15;

    return line-&gt;points[pos].type & 3;
}</pre></code>

<h5>4.13.11. line16_point_rate_set</h5>

<p><a id="wm_012_0509"></a><div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_point_rate_set(page_line16_d *l,
                                  int linepos,
                                  int pos,
                                  PWFLT rate);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void line16_point_rate_set(page_line16_d *l,
                                  int linepos,
                                  int pos,
                                  PWFLT rate)
{
    line16_line *line;

    if(pos &lt; 0) pos = 0;
    if(pos &gt; 15) pos = 15;

    if (linepos &lt; 0) linepos = 0;
    if (linepos &gt; 15) linepos = 15;

    line = &l-&gt;lines[linepos];

    line-&gt;points[pos].rate = rate;
}</pre></code>

<h5>4.13.12. line16_point_rate_get</h5>

<p><a id="wm_012_0514"></a><div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static PWFLT line16_point_rate_get(page_line16_d *l,
                                   int linepos,
                                   int pos);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static PWFLT line16_point_rate_get(page_line16_d *l,
                                   int linepos,
                                   int pos)
{
    line16_line *line;

    if(pos &lt; 0) pos = 0;
    if(pos &gt; 15) pos = 15;

    if (linepos &lt; 0) linepos = 0;
    if (linepos &gt; 15) linepos = 15;

    line = &l-&gt;lines[linepos];

    return line-&gt;points[pos].rate;
}</pre></code>

<h5>4.13.13. line16_point_trigmode_set</h5>

<p><a id="wm_012_0519"></a><div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>/* static void line16_point_trigmode_set(page_line16_d *l, */
/*                                       int line, */
/*                                       int pos, */
/*                                       int tog); */</pre></code>
<p>Trigmode is embedded inside of the type variable, so some
bit twiddling is needed.
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>/* static void line16_point_trigger_set(page_line16_d *l, */
/*                                      int line, */
/*                                      int pos, */
/*                                      int tog) */
/* { */
/*     int tmp; */
/*     if(pos &lt; 0) pos = 0; */
/*     if(pos &gt; 15) pos = 15; */

/*     tmp = l-&gt;points[pos].type; */
/*     tmp &= ~(1&lt;&lt;2); /\* clear bit 3 *\/ */
/*     tmp |= tog & ~(1&lt;&lt;2); /\* mask + set *\/ */
/*     l-&gt;points[pos].type = tmp; */
/* } */</pre></code>

<h5>4.13.14. line16_point_trigmode_get</h5>

<p><a id="wm_012_0525"></a><div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>/* static int line16_point_trigmode_get(page_line16_d *l, */
/*                                      int line, */
/*                                      int pos); */</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>/* static int line16_point_trigmode_get(page_line16_d *l, */
/*                                      int line, */
/*                                      int pos) */
/* { */

/*     if(pos &lt; 0) pos = 0; */
/*     if(pos &gt; 15) pos = 15; */

/*     return l-&gt;points[pos].type & (1 &lt;&lt; 2); */
/* } */</pre></code>

<h4>4.14. Begin New Segment (Main and Local)</h4>

<p><a id="wm_012_0530"></a></p>

<h5>4.14.1. Main</h5>

<p><a id="wm_012_0531"></a>Starts a new segment.
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_begin_segment(page_line16_d *l);</pre></code>
<p></p>
<p>When a new segment starts:
</p>
<p>Find the next point.
</p>
<p>Counter reset to be zero.
</p>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void line16_begin_segment(page_line16_d *l)
{
    int nextpoint;

    l-&gt;counter = 0;
    l-&gt;trig = 0;

    nextpoint = line16_find_next(l, l-&gt;nextpoint);

    if(nextpoint &lt; 0) return;

    l-&gt;pointpos = l-&gt;nextpoint;
    l-&gt;nextpoint = nextpoint;
}</pre></code>

<h5>4.14.2. DONE Local</h5>

<p><a id="wm_012_0538"></a>CLOSED: [2020-01-03 Fri 12:27]
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_begin_local(line16_localline *ll);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void line16_begin_local(line16_localline *ll)
{
    int nextpoint;

    ll-&gt;counter = 0;
    ll-&gt;trig = 0;

    nextpoint = line16_line_find_next(ll-&gt;l, ll-&gt;nextpoint);

    if(nextpoint &lt; 0) return;

    ll-&gt;pointpos = ll-&gt;nextpoint;
    ll-&gt;nextpoint = nextpoint;
}</pre></code>

<h4>4.15. Scale to duration</h4>

<p><a id="wm_012_0544"></a><div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static PWFLT line16_durscale(page_line16_d *l, PWFLT val);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static PWFLT line16_durscale(page_line16_d *l, PWFLT val)
{
    PWFLT mn, mx;
    mn = line16_dur_min_get(l);
    mx = line16_dur_max_get(l);
    return val * (mx - mn) + mn;
}</pre></code>

<h4>4.16. Start a line (Main + Local)</h4>

<p><a id="wm_012_0549"></a>Called when line is first initialized.
This will start the line. It will find first two line
segments.
</p>

<h5>4.16.1. Main</h5>

<p><a id="wm_012_0551"></a><div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_start_line(page_line16_d *line);</pre></code>
<p></p>
<p>A value of -1 is passed into <code>find_next</code> because this
function looks for the next value AFTER the input
value. Passing -1 allows the function to start looking
AT 0.
</p>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void line16_start_line(page_line16_d *line)
{
    line-&gt;counter = 0;
    line-&gt;pointpos = line16_find_next(line, -1);
    line-&gt;nextpoint = line16_find_next(line,
                                       line-&gt;pointpos);
}</pre></code>

<h5>4.16.2. Local</h5>

<p><a id="wm_012_0557"></a><div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_start_line_local(line16_localline *line);</pre></code>
<p></p>
<p>A value of -1 is passed into <code>find_next</code> because this
function looks for the next value AFTER the input
value. Passing -1 allows the function to start looking
AT 0.
</p>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void line16_start_line_local(line16_localline *line)
{
    line-&gt;counter = 0;
    line-&gt;pointpos = line16_line_find_next(line-&gt;l, -1);
    line-&gt;nextpoint = line16_line_find_next(line-&gt;l,
                                            line-&gt;pointpos);
}</pre></code>

<h4>4.17. Update Point Position</h4>

<p><a id="wm_012_0563"></a>This will update the point position on the monome.
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_update_pointpos(page_line16_d *l);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void line16_update_pointpos(page_line16_d *l)
{
    unsigned short val;

    if (l-&gt;selected_line != l-&gt;playing_line) {
        return;
    }

    if (l-&gt;timer &gt;= 0 && l-&gt;timer &lt; MIN_DUR) return;

    if (l-&gt;pointpos &lt; 0) val = 0;
    else val = 1 &lt;&lt; l-&gt;pointpos;



    if (l-&gt;pointpos != l-&gt;lpointpos) {
        monolith_page_mstate_led_row16(l-&gt;mstate, 6, val);
        l-&gt;timer = 0;
        l-&gt;lpointpos = l-&gt;pointpos;
    }
}</pre></code>
</div>
</body>
</html>
