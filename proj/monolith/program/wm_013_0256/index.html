<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<link rel="stylesheet" href="/css/style.css">

</head>
<body>
<div id="main">

<h3>8. Seq16 Patchwerk Nodes</h3>

<p><a id="wm_013_0256"></a></p>

<h4>8.1. Clock Node</h4>

<p><a id="wm_013_0257"></a>Clocks the sequence. Should only be called once, and before
trying to get values.
</p>

<h5>8.1.1. Clock Node Function</h5>

<p><a id="wm_013_0259"></a><div><b><i>&lt;&lt;seq16_function_declarations&gt;&gt;=</i></b></div><pre><code>static int node_seq16clk(pw_node *node, page_seq16_d *seq16);</pre></code>
<div><b><i>&lt;&lt;seq16_functions&gt;&gt;=</i></b></div><pre><code>&lt;&lt;seq16_node_functions&gt;&gt;
static int node_seq16clk(pw_node *node, page_seq16_d *seq16)
{
    pw_node_cables_alloc(node, 1);
    pw_node_set_data(node, seq16);
    pw_node_set_compute(node, clk_compute);
    return PW_OK;
}</pre></code>

<h5>8.1.2. Clock Compute</h5>

<p><a id="wm_013_0266"></a><div><b><i>&lt;&lt;seq16_node_functions&gt;&gt;=</i></b></div><pre><code>static void clk_compute(pw_node *n)
{
    int blksize;
    int s;
    pw_cable *in;
    page_seq16_d *seq;

    blksize = pw_node_blksize(n);
    seq = pw_node_get_data(n);

    pw_node_get_cable(n, 0, &in);

    seq-&gt;nevt = 0;
    seq-&gt;lastpos = seq-&gt;pos;
    for(s = 0; s &lt; blksize; s++) {
       if (pw_cable_get(in, s) != 0) {

           if (seq-&gt;reset) {
               seq-&gt;reset = 0;
               seq-&gt;nevt = 0;
               seq16_draw_col(seq, seq-&gt;pos);
               seq-&gt;lastpos = -1;
               seq-&gt;pos = -1;
           }
           if (seq-&gt;nevt &gt;= 4) continue;
           seq-&gt;evt[seq-&gt;nevt] = s;
           seq-&gt;nevt++;
           seq16_draw_col(seq, seq-&gt;pos);
           seq-&gt;pos = (seq-&gt;pos + 1) % seq-&gt;size;
           if (seq-&gt;playhead) seq16_draw_playhead(seq, seq-&gt;pos);
       }
    }

}</pre></code>

<h4>8.2. Seq16 value</h4>

<p><a id="wm_013_0270"></a>Gets clocked sequence
</p>

<h5>8.2.1. Value Node Function</h5>

<p><a id="wm_013_0272"></a><div><b><i>&lt;&lt;seq16_function_declarations&gt;&gt;=</i></b></div><pre><code>static int node_seq16val(pw_node *node, page_seq16_d *seq16);</pre></code>
<div><b><i>&lt;&lt;seq16_functions&gt;&gt;=</i></b></div><pre><code>&lt;&lt;seq16val_node_functions&gt;&gt;
static int node_seq16val(pw_node *node, page_seq16_d *seq16)
{
    pw_node_cables_alloc(node, 1);
    pw_node_set_block(node, 0);
    pw_node_set_data(node, seq16);
    pw_node_set_compute(node, val_compute);
    return PW_OK;
}</pre></code>

<h5>8.2.2. Value Node Compute</h5>

<p><a id="wm_013_0279"></a>The value function will locally step through the event stack
and "replay" the sequences.
<div><b><i>&lt;&lt;seq16val_node_functions&gt;&gt;=</i></b></div><pre><code>static void val_compute(pw_node *n)
{
    int blksize;
    int s;
    pw_cable *out;
    page_seq16_d *seq;
    int *evt;
    int nevt;
    int val;
    int pos;
    int evtpos;

    blksize = pw_node_blksize(n);
    seq = pw_node_get_data(n);

    pw_node_get_cable(n, 0, &out);

    pos = seq-&gt;lastpos;
    nevt = seq-&gt;nevt;
    evt = seq-&gt;evt;
    evtpos = 0;

    if (pos &lt; 0) val = 0;
    else val = seq-&gt;seq[pos];

    for(s = 0; s &lt; blksize; s++) {
        if (evtpos &lt; nevt) {
            if (evt[evtpos] == s) {
                pos = (pos + 1) % seq-&gt;size;
                val = seq-&gt;seq[pos];
                evtpos++;
            }
        }
        pw_cable_set(out, s, val);
    }
}</pre></code>

<h4>8.3. Seq16 gate</h4>

<p><a id="wm_013_0284"></a>Gets clocked sequence
</p>

<h5>8.3.1. Gate Function</h5>

<p><a id="wm_013_0286"></a><div><b><i>&lt;&lt;seq16_function_declarations&gt;&gt;=</i></b></div><pre><code>static int node_seq16gt(pw_node *node, page_seq16_d *seq16);</pre></code>
<div><b><i>&lt;&lt;seq16_functions&gt;&gt;=</i></b></div><pre><code>&lt;&lt;seq16gt_node_functions&gt;&gt;
static int node_seq16gt(pw_node *node, page_seq16_d *seq16)
{
    pw_node_cables_alloc(node, 1);
    pw_node_set_block(node, 0);
    pw_node_set_data(node, seq16);
    pw_node_set_compute(node, gt_compute);
    return PW_OK;
}</pre></code>

<h5>8.3.2. Gate Compute</h5>

<p><a id="wm_013_0293"></a>Gate is identical in behavior to val, except for the last
bit. The value is checked for 0 values. A zero value is a 0,
anything else is a 1.
</p>
<div><b><i>&lt;&lt;seq16gt_node_functions&gt;&gt;=</i></b></div><pre><code>static void gt_compute(pw_node *n)
{
    int blksize;
    int s;
    pw_cable *out;
    page_seq16_d *seq;
    int *evt;
    int nevt;
    int val;
    int pos;
    int evtpos;

    blksize = pw_node_blksize(n);
    seq = pw_node_get_data(n);

    pw_node_get_cable(n, 0, &out);

    pos = seq-&gt;lastpos;
    nevt = seq-&gt;nevt;
    evt = seq-&gt;evt;
    evtpos = 0;

    if (pos &lt; 0) val = 0;
    else val = seq-&gt;seq[pos];

    for(s = 0; s &lt; blksize; s++) {
        if (evtpos &lt; nevt) {
            if (evt[evtpos] == s) {
                pos = (pos + 1) % seq-&gt;size;
                val = seq-&gt;seq[pos];
                evtpos++;
            }
        }
        pw_cable_set(out, s, val != 0);
    }
}</pre></code>

<h4>8.4. Clock Getter</h4>

<p><a id="wm_013_0298"></a>Once a clock has been set, this signal can be dynamically
reconstructed. This sort of thing is useful for times when
the clock signal gets processed somehow before being
sent into seq16 (with a probability filter, or a clock 
divider).
</p>

<h5>8.4.1. Clock Getter Node</h5>

<p><a id="wm_013_0300"></a><code>node_seq16clkget</code>.
<div><b><i>&lt;&lt;seq16_function_declarations&gt;&gt;=</i></b></div><pre><code>static int node_seq16clkget(pw_node *node, page_seq16_d *seq16);</pre></code>
<div><b><i>&lt;&lt;seq16_functions&gt;&gt;=</i></b></div><pre><code>&lt;&lt;seq16clkget_node_functions&gt;&gt;
static int node_seq16clkget(pw_node *node, page_seq16_d *seq16)
{
    pw_node_cables_alloc(node, 1);
    pw_node_set_block(node, 0);
    pw_node_set_data(node, seq16);
    pw_node_set_compute(node, clkget_compute);
    return PW_OK;
}</pre></code>

<h5>8.4.2. Clock Getter Compute</h5>

<p><a id="wm_013_0308"></a>This works very similary to the gate compute function.
It reads values from the event stack. When it reaches
an event, it turns on a trigger.
</p>
<div><b><i>&lt;&lt;seq16clkget_node_functions&gt;&gt;=</i></b></div><pre><code>static void clkget_compute(pw_node *n)
{
    int blksize;
    int s;
    pw_cable *out;
    page_seq16_d *seq;
    int *evt;
    int nevt;
    int evtpos;

    blksize = pw_node_blksize(n);
    seq = pw_node_get_data(n);

    pw_node_get_cable(n, 0, &out);

    nevt = seq-&gt;nevt;
    evt = seq-&gt;evt;
    evtpos = 0;

    for(s = 0; s &lt; blksize; s++) {
        PWFLT o;
        o = 0;

        if (evtpos &lt; nevt) {
            if (evt[evtpos] == s) {
                o = 1;
                evtpos++;
            }
        }

        pw_cable_set(out, s, o);
    }
}</pre></code>
</div>
</body>
</html>
