<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<link rel="stylesheet" href="/css/style.css">

</head>
<body>
<div id="main">

<h3>3. Line16 Data</h3>

<p><a id="wm_012_0022"></a></p>

<h4>3.1. Line16 Point</h4>

<p><a id="wm_012_0023"></a>A point is a explicit point in a line.
</p>

<h5>3.1.1. Typedef</h5>

<p><a id="wm_012_0025"></a>Data for this point
is contained in a struct called <code>line16_point</code>.
<div><b><i>&lt;&lt;line16_typedefs&gt;&gt;=</i></b></div><pre><code>typedef struct line16_point line16_point;</pre></code>
<div><b><i>&lt;&lt;line16_struct&gt;&gt;=</i></b></div><pre><code>struct line16_point {
&lt;&lt;line16_point_contents&gt;&gt;
};</pre></code>

<h5>3.1.2. Init Function</h5>

<p><a id="wm_012_0035"></a>A <code>line16_point</code> is initialized using the function
<code>line16_point_init</code>.
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_point_init(line16_point *pt);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void line16_point_init(line16_point *pt)
{
&lt;&lt;line16_point_init&gt;&gt;
}</pre></code>

<h5>3.1.3. Contents</h5>

<p><a id="wm_012_0045"></a></p>

<h6>3.1.3.1. Active</h6>

<p><a id="wm_012_0046"></a>This is a boolean value. When not active, the point will be
skipped. The last active value will determine the length of
the line segment.
<div><b><i>&lt;&lt;line16_point_contents&gt;&gt;=</i></b></div><pre><code>int active;</pre></code>
<div><b><i>&lt;&lt;line16_point_init&gt;&gt;=</i></b></div><pre><code>pt-&gt;active = 0;</pre></code>

<h6>3.1.3.2. Value</h6>

<p><a id="wm_012_0054"></a>The value of a point is a normalized <code>PWFLT</code> floating point
value between 0 and 1.
<div><b><i>&lt;&lt;line16_point_contents&gt;&gt;=</i></b></div><pre><code>PWFLT val;</pre></code>
<div><b><i>&lt;&lt;line16_point_init&gt;&gt;=</i></b></div><pre><code>pt-&gt;val = 0;</pre></code>

<h6>3.1.3.3. Duration</h6>

<p><a id="wm_012_0060"></a>The duration tells how long the segment is, and by
definition also illustrates how long the interpolation
time to the next value will be.
<div><b><i>&lt;&lt;line16_point_contents&gt;&gt;=</i></b></div><pre><code>PWFLT dur;</pre></code>
<div><b><i>&lt;&lt;line16_point_init&gt;&gt;=</i></b></div><pre><code>pt-&gt;dur = 0;</pre></code>

<h6>3.1.3.4. Aux Values</h6>

<p><a id="wm_012_0066"></a>These are two aux values. These will be controllable
via the arc. These will map to any special point
functionalities that may arise in the future.
<div><b><i>&lt;&lt;line16_point_contents&gt;&gt;=</i></b></div><pre><code>PWFLT aux[2];</pre></code>
<div><b><i>&lt;&lt;line16_point_init&gt;&gt;=</i></b></div><pre><code>pt-&gt;aux[0] = 0;
pt-&gt;aux[1] = 0;</pre></code>

<h6>3.1.3.5. Playback Rate</h6>

<p><a id="wm_012_0072"></a>Every point has their own playback rate amount.
The idea is that this can be modified inside of
patchwerk. By default, this is set to be 1 (normal
speed).
<div><b><i>&lt;&lt;line16_point_contents&gt;&gt;=</i></b></div><pre><code>PWFLT rate;</pre></code>
<div><b><i>&lt;&lt;line16_point_init&gt;&gt;=</i></b></div><pre><code>pt-&gt;rate = 1;</pre></code>

<h6>3.1.3.6. Type</h6>

<p><a id="wm_012_0078"></a>This refers to the point slope type. By default, it is set
to be 0, or linear.
</p>

<h7>3.1.3.6.1. Struct Declaration</h7>

<p><a id="wm_012_0080"></a><div><b><i>&lt;&lt;line16_macros&gt;&gt;=</i></b></div><pre><code>enum {
SLOPE_LINEAR,
SLOPE_EXP_POSITIVE,
SLOPE_EXP_NEGATIVE,
SLOPE_BEZIER
};</pre></code>
<div><b><i>&lt;&lt;line16_point_contents&gt;&gt;=</i></b></div><pre><code>int type;</pre></code>
<div><b><i>&lt;&lt;line16_point_init&gt;&gt;=</i></b></div><pre><code>pt-&gt;type = SLOPE_LINEAR;</pre></code>

<h4>3.2. DONE Line16 Line</h4>

<p><a id="wm_012_0088"></a>CLOSED: [2020-01-02 Thu 13:58]
This is a struct which encapsulates a line.
</p>

<h5>3.2.1. Typedef</h5>

<p><a id="wm_012_0090"></a><div><b><i>&lt;&lt;line16_typedefs&gt;&gt;=</i></b></div><pre><code>typedef struct line16_line line16_line;</pre></code>
<div><b><i>&lt;&lt;line16_struct&gt;&gt;=</i></b></div><pre><code>struct line16_line {
&lt;&lt;line16_line_contents&gt;&gt;
};</pre></code>

<h5>3.2.2. Init</h5>

<p><a id="wm_012_0097"></a><div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_line_init(line16_line *line);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void line16_line_init(line16_line *line)
{
&lt;&lt;line16_line_init&gt;&gt;
}</pre></code>

<h5>3.2.3. Contents</h5>

<p><a id="wm_012_0104"></a></p>

<h6>3.2.3.1. Point Bank</h6>

<p><a id="wm_012_0105"></a><div><b><i>&lt;&lt;line16_line_contents&gt;&gt;=</i></b></div><pre><code>line16_point points[16];</pre></code>
<div><b><i>&lt;&lt;line16_line_init&gt;&gt;=</i></b></div><pre><code>{
    int i;
    for (i = 0; i &lt; 16; i++) {
        line16_point_init(&line-&gt;points[i]);
    }
}</pre></code>

<h6>3.2.3.2. Number Of Active Points</h6>

<p><a id="wm_012_0112"></a>Keeps track of how many active points there are. If there
are none, the line does not get saved.
<div><b><i>&lt;&lt;line16_line_contents&gt;&gt;=</i></b></div><pre><code>int nactive;</pre></code>
<div><b><i>&lt;&lt;line16_line_init&gt;&gt;=</i></b></div><pre><code>line-&gt;nactive = 0;</pre></code>

<h4>3.3. Line16 Main Data Contents</h4>

<p><a id="wm_012_0118"></a></p>

<h5>3.3.1. Monome State Data</h5>

<p><a id="wm_012_0119"></a><div><b><i>&lt;&lt;page_line16_contents&gt;&gt;=</i></b></div><pre><code>monolith_page_mstate *mstate;</pre></code>
<div><b><i>&lt;&lt;line16_init&gt;&gt;=</i></b></div><pre><code>monolith_page_mstate_new(pg, &line16-&gt;mstate);</pre></code>
<div><b><i>&lt;&lt;line16_cleanup&gt;&gt;=</i></b></div><pre><code>monolith_page_mstate_free(&line16-&gt;mstate);</pre></code>

<h5>3.3.2. Arc State Data</h5>

<p><a id="wm_012_0129"></a><div><b><i>&lt;&lt;page_line16_contents&gt;&gt;=</i></b></div><pre><code>monolith_page_arcstate *arcstate;</pre></code>
<div><b><i>&lt;&lt;line16_init&gt;&gt;=</i></b></div><pre><code>monolith_page_arcstate_new(pg, &line16-&gt;arcstate);</pre></code>
<div><b><i>&lt;&lt;line16_cleanup&gt;&gt;=</i></b></div><pre><code>monolith_page_arcstate_free(&line16-&gt;arcstate);</pre></code>

<h5>3.3.3. Line Point Bank (soon to be line bank).</h5>

<p><a id="wm_012_0136"></a>This is being refactored. Instead of having a point bank,
a newly introduced line struct with a point bank
inside of it. This will be a line bank with up to 16
lines available for programming.
<div><b><i>&lt;&lt;page_line16_contents&gt;&gt;=</i></b></div><pre><code>line16_line lines[16];</pre></code>
<div><b><i>&lt;&lt;line16_init&gt;&gt;=</i></b></div><pre><code>for (i = 0; i &lt; 16; i++) {
    line16_line_init(&line16-&gt;lines[i]);
}</pre></code>

<h5>3.3.4. Global Playback Rate</h5>

<p><a id="wm_012_0143"></a><div><b><i>&lt;&lt;page_line16_contents&gt;&gt;=</i></b></div><pre><code>PWFLT rate;</pre></code>
<div><b><i>&lt;&lt;line16_init&gt;&gt;=</i></b></div><pre><code>line16_rate_set(line16, 1);</pre></code>
<p>This can be accessed with <code>line16_rate_set</code> and
<code>line16_rate_get</code>.
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_rate_set(page_line16_d *l, PWFLT x);
static PWFLT line16_rate_get(page_line16_d *l);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void line16_rate_set(page_line16_d *l, PWFLT x)
{
    l-&gt;rate = x;
}

static PWFLT line16_rate_get(page_line16_d *l)
{
    return l-&gt;rate;
}</pre></code>

<h5>3.3.5. Selected Point</h5>

<p><a id="wm_012_0153"></a>The currently selected point in the main line sequencer.
<div><b><i>&lt;&lt;page_line16_contents&gt;&gt;=</i></b></div><pre><code>int selected_point;</pre></code>
<div><b><i>&lt;&lt;line16_init&gt;&gt;=</i></b></div><pre><code>line16-&gt;selected_point = 0;</pre></code>

<h5>3.3.6. Selected Line</h5>

<p><a id="wm_012_0159"></a><div><b><i>&lt;&lt;page_line16_contents&gt;&gt;=</i></b></div><pre><code>int selected_line;</pre></code>
<div><b><i>&lt;&lt;line16_init&gt;&gt;=</i></b></div><pre><code>line16-&gt;selected_line = 0;</pre></code>

<h5>3.3.7. Currently Playing Line</h5>

<p><a id="wm_012_0164"></a>This is the line that is being played in the main sequencer.
This can be different from the currently selected line.
<div><b><i>&lt;&lt;page_line16_contents&gt;&gt;=</i></b></div><pre><code>int playing_line;</pre></code>
<div><b><i>&lt;&lt;line16_init&gt;&gt;=</i></b></div><pre><code>line16-&gt;playing_line = 0;</pre></code>

<h5>3.3.8. Point Position</h5>

<p><a id="wm_012_0170"></a>An integer value. This shows holds the current
point value.
<div><b><i>&lt;&lt;page_line16_contents&gt;&gt;=</i></b></div><pre><code>int pointpos;</pre></code>
<div><b><i>&lt;&lt;line16_init&gt;&gt;=</i></b></div><pre><code>line16-&gt;pointpos = -1;</pre></code>

<h5>3.3.9. Last Point Position</h5>

<p><a id="wm_012_0176"></a>Every time the point position is updated on the monome grid,
it stores the previous value. This is done to prevent
the main function from overloading the grid and causing
libmonome to bugout.
</p>
<p>Initially set this to any arbitrary postive value larger
than 15, or any value less than -1 (-1 being the initial
unset point position).
<div><b><i>&lt;&lt;page_line16_contents&gt;&gt;=</i></b></div><pre><code>int lpointpos;</pre></code>
<div><b><i>&lt;&lt;line16_init&gt;&gt;=</i></b></div><pre><code>line16-&gt;lpointpos = -100;</pre></code>

<h5>3.3.10. Timers</h5>

<p><a id="wm_012_0182"></a></p>

<h6>3.3.10.1. Update Timer</h6>

<p><a id="wm_012_0183"></a>This is a special timer used rate limit the updates to
the monome grid. The timer measures the duration between
time segments. If the distance it too short, it will simply
not update the monome.
</p>
<p>Set to be a negative value by default, so the program knows
it is only initialized and not time has passed.
<div><b><i>&lt;&lt;page_line16_contents&gt;&gt;=</i></b></div><pre><code>double timer;</pre></code>
<div><b><i>&lt;&lt;line16_init&gt;&gt;=</i></b></div><pre><code>line16-&gt;timer = -1;</pre></code>
<div><b><i>&lt;&lt;line16_macros&gt;&gt;=</i></b></div><pre><code>#define MIN_DUR 0.05</pre></code>

<h6>3.3.10.2. Aux Timer</h6>

<p><a id="wm_012_0191"></a>This is used to rate limit updated values coming from
patchwerk nodes. To prevent weird interruptions and
glitches, a separate timer is used. This only needs to be
set to 0.
<div><b><i>&lt;&lt;page_line16_contents&gt;&gt;=</i></b></div><pre><code>double aux_timer;</pre></code>
<div><b><i>&lt;&lt;line16_init&gt;&gt;=</i></b></div><pre><code>line16-&gt;aux_timer = 0;</pre></code>
<div><b><i>&lt;&lt;line16_macros&gt;&gt;=</i></b></div><pre><code>#define AUX_MIN_DUR 0.03</pre></code>

<h5>3.3.11. Next Point</h5>

<p><a id="wm_012_0199"></a>Holds the integer value for the next point.
<div><b><i>&lt;&lt;page_line16_contents&gt;&gt;=</i></b></div><pre><code>int nextpoint;</pre></code>
<div><b><i>&lt;&lt;line16_init&gt;&gt;=</i></b></div><pre><code>line16-&gt;nextpoint = 0;</pre></code>

<h5>3.3.12. 1 / SR</h5>

<p><a id="wm_012_0205"></a>This is a constant that is the inverse of the sampling rate.
<div><b><i>&lt;&lt;page_line16_contents&gt;&gt;=</i></b></div><pre><code>PWFLT onedsr;</pre></code>
<div><b><i>&lt;&lt;line16_init&gt;&gt;=</i></b></div><pre><code>line16-&gt;onedsr = 1.0 / pw_patch_srate_get(patch);</pre></code>

<h5>3.3.13. Counter</h5>

<p><a id="wm_012_0211"></a>This is the counter, stored as a floating point value, in
seconds. Stores the current duration of the line segment.
<div><b><i>&lt;&lt;page_line16_contents&gt;&gt;=</i></b></div><pre><code>PWFLT counter;</pre></code>
<div><b><i>&lt;&lt;line16_init&gt;&gt;=</i></b></div><pre><code>line16-&gt;counter = 0;</pre></code>

<h5>3.3.14. Patchwerk Cable</h5>

<p><a id="wm_012_0217"></a>This holds a pre-allocated patchwerk cable with
an internal block. At every render block, the line
gets computed exactly once, and it is written to this
cable.. Other nodes then retrieve the block and copy
it over to their internal block.
<div><b><i>&lt;&lt;page_line16_contents&gt;&gt;=</i></b></div><pre><code>pw_cable out;
PWFLT *blk;</pre></code>
<p>Still need to initialize with patchwerk block.
Also need to allocate and bind a block.
<div><b><i>&lt;&lt;line16_init&gt;&gt;=</i></b></div><pre><code>pw_cable_init(NULL, &line16-&gt;out);
line16-&gt;blk = calloc(1,
                     pw_patch_blksize(patch) *
                     sizeof(PWFLT));
pw_cable_set_block(&line16-&gt;out,
                   line16-&gt;blk,
                   pw_patch_blksize(patch));</pre></code>
<p>Said block needs to be freed here.
<div><b><i>&lt;&lt;line16_cleanup&gt;&gt;=</i></b></div><pre><code>free(line16-&gt;blk);</pre></code>

<h5>3.3.15. Number of active points (migrated!)</h5>

<p><a id="wm_012_0227"></a>Migrated to the line struct.
</p>
</p>

<h5>3.3.16. Event Stack</h5>

<p><a id="wm_012_0229"></a>When a point is told to be turned on or off via the grid
or programatically, it pushes the command onto an event
stack, which is then processed by the internal node. This
is done as a measure to prevent weird bugs from happening
related to finding the next available point. The event
stack right now is only concerned with whether or not things
get activated. Other events, such as setting a value, will
be directly written to the point. I do not see any potential
weirdness here.
</p>

<h6>3.3.16.1. [2019-08-09 Fri 15:22] Dispute</h6>

<p><a id="wm_012_0231"></a>Okay. So I just realized the downfall of this event stack.
It makes it so you <b>have</b> to include the main node
in the audio graph in order to use. If you don't, the thing
appears to be broken. Also, if the sound is paused, the
thing will appear to be broken. Overall not a great design.
</p>
<p>My interest I think is going to be maybe capturing the
states of all the lines, and then copying over the states
whenever a change is made.
</p>

<h7>3.3.16.1.1. [2019-12-19 Thu 17:13] believe this is resolved</h7>

<p><a id="wm_012_0233"></a></p>

<h6>3.3.16.2. Data</h6>

<p><a id="wm_012_0234"></a></p>
<p>The intermediate state of a page is stored in an array of
char values as booleans.
</p>
<p>The <code>actions</code> variable is used to keep track of if any
actions happened.
</p>
<div><b><i>&lt;&lt;page_line16_contents&gt;&gt;=</i></b></div><pre><code>unsigned char state[16];
int actions;</pre></code>
<div><b><i>&lt;&lt;line16_init&gt;&gt;=</i></b></div><pre><code>line16_state_init(line16);</pre></code>

<h6>3.3.16.3. Initializing the event stack</h6>

<p><a id="wm_012_0240"></a>This just zeros out the stack.
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_state_init(page_line16_d *l);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void line16_state_init(page_line16_d *l)
{
    int i;
    for(i = 0; i &lt; 16; i++) {
        l-&gt;state[i] = 0;
    }
    l-&gt;actions = 0;
}</pre></code>

<h6>3.3.16.4. Set the state</h6>

<p><a id="wm_012_0246"></a>Sets the state.
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_state_set(page_line16_d *l, int pt, int s);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void line16_state_set(page_line16_d *l, int pt, int s)
{
    if(pt &lt; 0 || pt &gt;= 16) {
        return;
    }

    l-&gt;state[pt] = s;
    l-&gt;actions++;
}</pre></code>

<h6>3.3.16.5. Applying the state</h6>

<p><a id="wm_012_0252"></a>Will take the intermeidate state and apply it to the point
bank.
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_state_apply(page_line16_d *l);</pre></code>
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_state_apply(page_line16_d *l)
{
    int n;
    unsigned char *state;
    line16_point *pt;
    int nactive;
    line16_point *points;
    line16_line *line;

    line = &l-&gt;lines[l-&gt;selected_line];
    points = line-&gt;points;

    if (!l-&gt;actions) return;

    state = l-&gt;state;

    nactive = 0;
    for (n = 0; n &lt; 16; n++) {
        pt = &points[n];
        pt-&gt;active = state[n];
        if(state[n]) nactive++;
    }

    line-&gt;nactive = nactive;
    l-&gt;actions = 0;
}</pre></code>

<h6>3.3.16.6. Copying Page to Event Stack</h6>

<p><a id="wm_012_0258"></a>Does the reverse of <code>line16_state_apply</code>. Call it...
<code>line16_state_copy</code>.
</p>
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_state_copy(page_line16_d *l);</pre></code>
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_state_copy(page_line16_d *l)
{
    int n;
    line16_point *pt;
    unsigned char *state;
    int nactive;
    line16_point *points;
    line16_line *line;

    state = l-&gt;state;

    line = &l-&gt;lines[l-&gt;selected_line];
    points = line-&gt;points;

    nactive = 0;
    for (n = 0; n &lt; 16; n++) {
        pt = &points[n];
        state[n] = pt-&gt;active;
        if (state[n]) nactive++;
    }
    line-&gt;nactive = nactive;
}</pre></code>

<h5>3.3.17. min/max durations</h5>

<p><a id="wm_012_0264"></a>This will set the range of possible durations for the line
segments.
<div><b><i>&lt;&lt;page_line16_contents&gt;&gt;=</i></b></div><pre><code>PWFLT min;
PWFLT max;</pre></code>
<div><b><i>&lt;&lt;line16_init&gt;&gt;=</i></b></div><pre><code>line16_dur_min_set(line16, 0.1);
line16_dur_max_set(line16, 10);</pre></code>
<p></p>
<p>These are accessible through setters and getters, defined
below.
</p>
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_dur_min_set(page_line16_d *l, PWFLT val);
static void line16_dur_max_set(page_line16_d *l, PWFLT val);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void line16_dur_min_set(page_line16_d *l, PWFLT val)
{
    l-&gt;min = val;
}
static void line16_dur_max_set(page_line16_d *l, PWFLT val)
{
    l-&gt;max = val;
}</pre></code>
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static PWFLT line16_dur_min_get(page_line16_d *l);
static PWFLT line16_dur_max_get(page_line16_d *l);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static PWFLT line16_dur_min_get(page_line16_d *l)
{
    return l-&gt;min;
}
static PWFLT line16_dur_max_get(page_line16_d *l)
{
    return l-&gt;max;
}</pre></code>

<h5>3.3.18. Aux Cache</h5>

<p><a id="wm_012_0279"></a></p>

<h6>3.3.18.1. Struct Contents</h6>

<p><a id="wm_012_0280"></a>Any time a point changes, the point A's aux values at that
point in time are saved. As a result, the nodes setting
naturally go through a kind of sample and hold. Holding
onto values for the duration of the line is more musical
than if it were constantly changing because it allows
more contrast to happen.
<div><b><i>&lt;&lt;page_line16_contents&gt;&gt;=</i></b></div><pre><code>PWFLT aux_cache[2];</pre></code>
<div><b><i>&lt;&lt;line16_init&gt;&gt;=</i></b></div><pre><code>line16-&gt;aux_cache[0] = 0;
line16-&gt;aux_cache[1] = 0;</pre></code>

<h6>3.3.18.2. Updating The Aux Cache</h6>

<p><a id="wm_012_0286"></a>Any time the line is updated, the cache, too needs
to be updated. This is done with <code>line16_aux_cache_update</code>.
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void line16_aux_cache_udpate(page_line16_d *l);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void line16_aux_cache_udpate(page_line16_d *l)
{
    line16_point *pt_a;
    pt_a = line16_get_point(l, l-&gt;pointpos);
    if(pt_a == NULL) return;

    l-&gt;aux_cache[0] = pt_a-&gt;aux[0];
    l-&gt;aux_cache[1] = pt_a-&gt;aux[1];
}</pre></code>
<p>CLOSED: [2019-08-24 Sat 13:58]
</p>

<h5>3.3.19. Trigger Flag</h5>

<p><a id="wm_012_0293"></a>This gets set every time there is a trigger, and is used to
start a line up that waits for a trigger. When a trigger
occurs, the sample position is stored.
<div><b><i>&lt;&lt;page_line16_contents&gt;&gt;=</i></b></div><pre><code>int trig;</pre></code>
<div><b><i>&lt;&lt;line16_init&gt;&gt;=</i></b></div><pre><code>line16-&gt;trig = -1;</pre></code>

<h4>3.4. Line16 Typedef Declaration</h4>

<p><a id="wm_012_0299"></a>All line16 page data is contained in a struct called <code>page_line16_d</code>.
<div><b><i>&lt;&lt;line16_typedefs&gt;&gt;=</i></b></div><pre><code>typedef struct page_line16_d page_line16_d;</pre></code>
<div><b><i>&lt;&lt;line16_struct&gt;&gt;=</i></b></div><pre><code>struct page_line16_d {
&lt;&lt;page_line16_contents&gt;&gt;
};</pre></code>

<h4>3.5. Line16 Data Allocation/Initialization</h4>

<p><a id="wm_012_0307"></a>Line16 data is initiatlized with the function
<code>page_line16_init</code>.
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void page_line16_init(monolith_page *pg, page_line16_d *line16);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void page_line16_init(monolith_page *pg, page_line16_d *line16)
{
    int i;
    pw_patch *patch;

    patch = monolith_page_patchwerk(pg);
&lt;&lt;line16_init&gt;&gt;
    line16_redraw_points(line16);
    line16_select_point(line16, line16-&gt;selected_point);
}</pre></code>

<h4>3.6. Line16 Data Cleanup</h4>

<p><a id="wm_012_0315"></a>Line16 data is freed with the funciton <code>page_line16_free</code>.
<div><b><i>&lt;&lt;line16_function_declarations&gt;&gt;=</i></b></div><pre><code>static void page_line16_cleanup(page_line16_d *line16);</pre></code>
<div><b><i>&lt;&lt;line16_functions&gt;&gt;=</i></b></div><pre><code>static void page_line16_cleanup(page_line16_d *line16)
{
&lt;&lt;line16_cleanup&gt;&gt;
}</pre></code>
<p></p>
<br>
<p><hr>

<a href="/proj/monolith/program/wm_012_0002">prev</a> | <a href="/proj/monolith/program/wm_012">home</a> | <a href="/proj/monolith/program/wm_012_0323">next</a></p>
</div>
</body>
</html>
