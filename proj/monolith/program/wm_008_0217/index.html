<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<link rel="stylesheet" href="/css/style.css">

</head>
<body>
<div id="main">

<h3>7. DONE Knobs State Management</h3>

<p><a id="wm_008_0217"></a>CLOSED: [2019-12-07 Sat 17:30]
</p>

<h4>7.1. DONE Schema Values</h4>

<p><a id="wm_008_0219"></a>CLOSED: [2019-12-07 Sat 17:30]
</p>

<h5>7.1.1. DONE Values</h5>

<p><a id="wm_008_0221"></a>CLOSED: [2019-12-07 Sat 17:30]
Stored as a msgback blob in schema, the values store
all 128 variables as an array
</p>

<h6>7.1.1.1. Schema Entry</h6>

<p><a id="wm_008_0223"></a><div><b><i>&lt;&lt;knobs_schema_generation&gt;&gt;=</i></b></div><pre><code>monolith_param_mkblob(*schema, 0,
                      "vals", 4,
                      NULL, 0, NULL);</pre></code>

<h6>7.1.1.2. msgpack generation</h6>

<p><a id="wm_008_0227"></a></p>

<h7>7.1.1.2.1. Write</h7>

<p><a id="wm_008_0228"></a><div><b><i>&lt;&lt;knobs_function_declarations&gt;&gt;=</i></b></div><pre><code>int knobs_data_write_vals(cmp_ctx_t *c, PWFLT *vals);</pre></code>
<div><b><i>&lt;&lt;knobs_functions&gt;&gt;=</i></b></div><pre><code>int knobs_data_write_vals(cmp_ctx_t *c, PWFLT *vals)
{
    int i;
    int rc;
    if (!cmp_write_array(c, 128)) return 0;

    for (i = 0; i &lt; 128; i++) {
        rc = cmp_write_float(c, vals[i]);
        if (!rc) return 0;
    }

    return 1;
}</pre></code>

<h7>7.1.1.2.2. Read</h7>

<p><a id="wm_008_0233"></a><div><b><i>&lt;&lt;knobs_function_declarations&gt;&gt;=</i></b></div><pre><code>int knobs_data_read_vals(cmp_ctx_t *c, PWFLT *vals);</pre></code>
<div><b><i>&lt;&lt;knobs_functions&gt;&gt;=</i></b></div><pre><code>int knobs_data_read_vals(cmp_ctx_t *c, PWFLT *vals)
{
    int i;
    int rc;
    uint32_t size;
    if (!cmp_read_array(c, &size)) return 0;

    if (size != 128) {
        fprintf(stderr,
                "size of 128 expected, got %d\n",
                size);
        return 0;
    }

    for (i = 0; i &lt; 128; i++) {
        rc = cmp_read_float(c, &vals[i]);
        if (!rc) return 0;
    }

    return 1;
}</pre></code>

<h6>7.1.1.3. DONE Saving blob</h6>

<p><a id="wm_008_0238"></a>CLOSED: [2019-12-07 Sat 17:30]
Must be populated explicitely.
<div><b><i>&lt;&lt;knobs_data_save&gt;&gt;=</i></b></div><pre><code>{
    cmp_ctx_t cmp;
    moncmp_d m;
    size_t sz;
    uint8_t *buf;

    sz = 0;
    moncmp_init_getsize(&cmp, &sz);
    knobs_data_write_vals(&cmp, knobs-&gt;vals);

    buf = calloc(1, sz);
    moncmp_init_write(&m, &cmp, buf);

    knobs_data_write_vals(&cmp, knobs-&gt;vals);
    monolith_param_setblob_default(schema, 0, buf, sz);
}</pre></code>

<h6>7.1.1.4. DONE Reading blob</h6>

<p><a id="wm_008_0243"></a>CLOSED: [2019-12-07 Sat 17:30]
<div><b><i>&lt;&lt;knobs_data_load&gt;&gt;=</i></b></div><pre><code>{
    size_t sz;
    cmp_ctx_t cmp;
    uint8_t *buf;
    moncmp_d m;

    sz = 0;
    monolith_param_blob(schema, 0,
                        (void **)&buf,
                        (unsigned int *)&sz);

    moncmp_init_read(&m, &cmp, buf, sz);
    knobs_data_read_vals(&cmp, knobs-&gt;vals);
}</pre></code>

<h5>7.1.2. DONE Selected Knobs (4)</h5>

<p><a id="wm_008_0248"></a>CLOSED: [2019-12-07 Sat 17:30]
Useful because of how many knobs there are. Stored as int.
Four of em.
</p>

<h6>7.1.2.1. Schema Entry</h6>

<p><a id="wm_008_0250"></a><div><b><i>&lt;&lt;knobs_schema_generation&gt;&gt;=</i></b></div><pre><code>sprintf(tmp, "selected_0");
for (i = 0; i &lt; 4; i++) {
    tmp[9] = 48 + i; /* itoa */
    monolith_param_mkint(*schema, 1 + i,
                        tmp, 10,
                        knobs-&gt;selected[i]);
}</pre></code>

<h6>7.1.2.2. DONE Read Values</h6>

<p><a id="wm_008_0253"></a>CLOSED: [2019-12-07 Sat 17:30]
<div><b><i>&lt;&lt;knobs_data_load&gt;&gt;=</i></b></div><pre><code>for (i = 0; i &lt; 4; i++) {
    monolith_param_int(schema,
                       1 + i,
                       &knobs-&gt;selected[i]);
}</pre></code>

<h5>7.1.3. DONE Aux Knob</h5>

<p><a id="wm_008_0257"></a>CLOSED: [2019-12-07 Sat 17:30]
Stored as an integer.
</p>

<h6>7.1.3.1. Schema Entry</h6>

<p><a id="wm_008_0259"></a><div><b><i>&lt;&lt;knobs_schema_generation&gt;&gt;=</i></b></div><pre><code>monolith_param_mkint(*schema, 5,
                    "aux_knob", 8,
                    knobs-&gt;aux_knob);</pre></code>

<h6>7.1.3.2. DONE Read Aux Knob Value</h6>

<p><a id="wm_008_0262"></a>CLOSED: [2019-12-07 Sat 17:30]
<div><b><i>&lt;&lt;knobs_data_load&gt;&gt;=</i></b></div><pre><code>monolith_param_int(schema,
                   5,
                   &knobs-&gt;aux_knob);</pre></code>

<h4>7.2. DONE Knobs Schema Generation</h4>

<p><a id="wm_008_0266"></a>CLOSED: [2019-12-07 Sat 17:30]
A new knobs schema is created and initialized with the
function <code>knobs_schema</code>.
<div><b><i>&lt;&lt;knobs_function_declarations&gt;&gt;=</i></b></div><pre><code>static int knobs_schema(page_knobs_d *knobs,
                        monolith_state_schema **schema);</pre></code>
<div><b><i>&lt;&lt;knobs_functions&gt;&gt;=</i></b></div><pre><code>static int knobs_schema(page_knobs_d *knobs,
                        monolith_state_schema **schema)
{
    int i;
    char tmp[16];

    monolith_state_schema_init(schema, 6);
&lt;&lt;knobs_schema_generation&gt;&gt;
    return 1;
}</pre></code>

<h4>7.3. DONE Knobs State Save</h4>

<p><a id="wm_008_0274"></a>CLOSED: [2019-12-07 Sat 17:30]
<div><b><i>&lt;&lt;knobs_function_declarations&gt;&gt;=</i></b></div><pre><code>static int knobs_save(monolith_page *pg,
                    monolith_state *s,
                    const char *key,
                    unsigned int len);</pre></code>
<div><b><i>&lt;&lt;knobs_functions&gt;&gt;=</i></b></div><pre><code>static int knobs_save(monolith_page *pg,
                      monolith_state *s,
                      const char *key,
                      unsigned int len)
{
    page_knobs_d *knobs;
    monolith_state_schema *schema;
    knobs = monolith_page_data_get(pg);
    knobs_schema(knobs, &schema);
&lt;&lt;knobs_data_save&gt;&gt;
    monolith_state_write_schema(s, schema,
                                "knobs", 5,
                                key, len);
    monolith_state_schema_cleanup(&schema);
    return 1;
}</pre></code>
<div><b><i>&lt;&lt;knobs_assign_callbacks&gt;&gt;=</i></b></div><pre><code>monolith_page_save_set(pg, knobs_save);</pre></code>

<h4>7.4. DONE Knobs State Load</h4>

<p><a id="wm_008_0284"></a>CLOSED: [2019-12-07 Sat 17:30]
<div><b><i>&lt;&lt;knobs_function_declarations&gt;&gt;=</i></b></div><pre><code>static int knobs_load(monolith_page *pg,
                      monolith_state *s,
                      const char *key,
                      unsigned int len);</pre></code>
<div><b><i>&lt;&lt;knobs_functions&gt;&gt;=</i></b></div><pre><code>static int knobs_load(monolith_page *pg,
                      monolith_state *s,
                      const char *key,
                      unsigned int len)
{
    page_knobs_d *knobs;
    monolith_state_schema *schema;
    int rc;

    knobs = monolith_page_data_get(pg);

    knobs_schema(knobs, &schema);
    rc = monolith_state_read_schema(s, schema, "knobs", 5, key, len);
    if (rc) {
        int i;
&lt;&lt;knobs_data_load&gt;&gt;
        knobs_redraw(knobs);
    }
    monolith_state_schema_cleanup(&schema);
    return rc;
}</pre></code>
<div><b><i>&lt;&lt;knobs_assign_callbacks&gt;&gt;=</i></b></div><pre><code>monolith_page_load_set(pg, knobs_load);</pre></code>
</div>
</body>
</html>
