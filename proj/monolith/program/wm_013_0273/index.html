<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<link rel="stylesheet" href="/css/style.css">

</head>
<body>
<div id="main">

<h3>8. DONE Seq16 Patchwerk Nodes</h3>

<p><a id="wm_013_0273"></a>CLOSED: [2019-12-09 Mon 13:17]
</p>

<h4>8.1. Clock Node</h4>

<p><a id="wm_013_0275"></a>Clocks the sequence. Should only be called once, and before
trying to get values.
</p>

<h5>8.1.1. Clock Node Function</h5>

<p><a id="wm_013_0277"></a><div><b><i>&lt;&lt;seq16_function_declarations&gt;&gt;=</i></b></div><pre><code>static int node_seq16clk(pw_node *node, page_seq16_d *seq16);</pre></code>
<div><b><i>&lt;&lt;seq16_functions&gt;&gt;=</i></b></div><pre><code>&lt;&lt;seq16_node_functions&gt;&gt;
static int node_seq16clk(pw_node *node, page_seq16_d *seq16)
{
    pw_node_cables_alloc(node, 1);
    pw_node_set_data(node, seq16);
    pw_node_set_compute(node, clk_compute);
    return PW_OK;
}</pre></code>

<h5>8.1.2. Clock Compute</h5>

<p><a id="wm_013_0284"></a><div><b><i>&lt;&lt;seq16_node_functions&gt;&gt;=</i></b></div><pre><code>static void clk_compute(pw_node *n)
{
    int blksize;
    int s;
    pw_cable *in;
    page_seq16_d *seq;

    blksize = pw_node_blksize(n);
    seq = pw_node_get_data(n);

    pw_node_get_cable(n, 0, &in);

    seq-&gt;nevt = 0;
    seq-&gt;lastpos = seq-&gt;pos;
    for(s = 0; s &lt; blksize; s++) {
       if (pw_cable_get(in, s) != 0) {

           if (seq-&gt;reset) {
               seq-&gt;reset = 0;
               seq-&gt;nevt = 0;
               seq16_draw_col(seq, seq-&gt;pos);
               seq-&gt;lastpos = -1;
               seq-&gt;pos = -1;
           }
           if (seq-&gt;nevt &gt;= 4) continue;
           seq-&gt;evt[seq-&gt;nevt] = s;
           seq-&gt;nevt++;
           seq16_draw_col(seq, seq-&gt;pos);
           seq-&gt;pos = (seq-&gt;pos + 1) % seq-&gt;size;
           if (seq-&gt;playhead) seq16_draw_playhead(seq, seq-&gt;pos);
       }
    }

}</pre></code>

<h4>8.2. DONE Seq16 value</h4>

<p><a id="wm_013_0288"></a>CLOSED: [2019-12-09 Mon 13:13]
Gets clocked sequence
</p>

<h5>8.2.1. Value Node Function</h5>

<p><a id="wm_013_0290"></a><div><b><i>&lt;&lt;seq16_function_declarations&gt;&gt;=</i></b></div><pre><code>static int node_seq16val(pw_node *node, page_seq16_d *seq16);</pre></code>
<div><b><i>&lt;&lt;seq16_functions&gt;&gt;=</i></b></div><pre><code>&lt;&lt;seq16val_node_functions&gt;&gt;
static int node_seq16val(pw_node *node, page_seq16_d *seq16)
{
    pw_node_cables_alloc(node, 1);
    pw_node_set_block(node, 0);
    pw_node_set_data(node, seq16);
    pw_node_set_compute(node, val_compute);
    return PW_OK;
}</pre></code>

<h5>8.2.2. Value Node Compute</h5>

<p><a id="wm_013_0297"></a>The value function will locally step through the event stack
and "replay" the sequences.
<div><b><i>&lt;&lt;seq16val_node_functions&gt;&gt;=</i></b></div><pre><code>static void val_compute(pw_node *n)
{
    int blksize;
    int s;
    pw_cable *out;
    page_seq16_d *seq;
    int *evt;
    int nevt;
    int val;
    int pos;
    int evtpos;

    blksize = pw_node_blksize(n);
    seq = pw_node_get_data(n);

    pw_node_get_cable(n, 0, &out);

    pos = seq-&gt;lastpos;
    nevt = seq-&gt;nevt;
    evt = seq-&gt;evt;
    evtpos = 0;

    if (pos &lt; 0) val = 0;
    else val = seq-&gt;seq[pos];

    for(s = 0; s &lt; blksize; s++) {
        if (evtpos &lt; nevt) {
            if (evt[evtpos] == s) {
                pos = (pos + 1) % seq-&gt;size;
                val = seq-&gt;seq[pos];
                evtpos++;
            }
        }
        pw_cable_set(out, s, val);
    }
}</pre></code>

<h4>8.3. DONE Seq16 gate</h4>

<p><a id="wm_013_0302"></a>CLOSED: [2019-12-09 Mon 13:13]
Gets clocked sequence
</p>

<h5>8.3.1. Gate Function</h5>

<p><a id="wm_013_0304"></a><div><b><i>&lt;&lt;seq16_function_declarations&gt;&gt;=</i></b></div><pre><code>static int node_seq16gt(pw_node *node, page_seq16_d *seq16);</pre></code>
<div><b><i>&lt;&lt;seq16_functions&gt;&gt;=</i></b></div><pre><code>&lt;&lt;seq16gt_node_functions&gt;&gt;
static int node_seq16gt(pw_node *node, page_seq16_d *seq16)
{
    pw_node_cables_alloc(node, 1);
    pw_node_set_block(node, 0);
    pw_node_set_data(node, seq16);
    pw_node_set_compute(node, gt_compute);
    return PW_OK;
}</pre></code>

<h5>8.3.2. Gate Compute</h5>

<p><a id="wm_013_0311"></a>Gate is identical in behavior to val, except for the last
bit. The value is checked for 0 values. A zero value is a 0,
anything else is a 1.
<div><b><i>&lt;&lt;seq16gt_node_functions&gt;&gt;=</i></b></div><pre><code>static void gt_compute(pw_node *n)
{
    int blksize;
    int s;
    pw_cable *out;
    page_seq16_d *seq;
    int *evt;
    int nevt;
    int val;
    int pos;
    int evtpos;

    blksize = pw_node_blksize(n);
    seq = pw_node_get_data(n);

    pw_node_get_cable(n, 0, &out);

    pos = seq-&gt;lastpos;
    nevt = seq-&gt;nevt;
    evt = seq-&gt;evt;
    evtpos = 0;

    if (pos &lt; 0) val = 0;
    else val = seq-&gt;seq[pos];

    for(s = 0; s &lt; blksize; s++) {
        if (evtpos &lt; nevt) {
            if (evt[evtpos] == s) {
                pos = (pos + 1) % seq-&gt;size;
                val = seq-&gt;seq[pos];
                evtpos++;
            }
        }
        pw_cable_set(out, s, val != 0);
    }
}</pre></code>
</div>
</body>
</html>
