<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<link rel="stylesheet" href="/css/style.css">

</head>
<body>
<div id="main">

<h3>1. Grid</h3>

<p><a id="wm_009_0001"></a>The Grid is the first page ever created for Monolith, and was constructed
during the development of the page interface.
</p>
<p>With grid, you can turn monome LEDs on and off. This information can then
be read by a patchwerk node. Presumably, this interface is best used for
for programming drum sequences.
</p>

<h4>1.1. Top-Level Files</h4>

<p><a id="wm_009_0003"></a>The top level files for the grid interface are a single C file.
At the moment, no header file is anticipated because all the functionality is
localized to this file.
<div><b><i>&lt;&lt;grid-top&gt;&gt;=</i></b></div><pre><code>#include &lt;stdio.h&gt;
#include &lt;runt.h&gt;
#include &lt;patchwerk.h&gt;
#include &lt;runt_patchwerk.h&gt;
#include "s9core.h"
#include "s9import.h"
#include "s9ext.h"
#include "monolith.h"
&lt;&lt;grid_typeflag&gt;&gt;
&lt;&lt;grid_typedefs&gt;&gt;
&lt;&lt;grid_structs&gt;&gt;
&lt;&lt;grid_function_declarations&gt;&gt;
&lt;&lt;grid_functions&gt;&gt;</pre></code>

<h4>1.2. Grid Page Data</h4>

<p><a id="wm_009_0019"></a>Grid data is stored in a struct called <code>page_grid_d</code>.
<div><b><i>&lt;&lt;grid_typedefs&gt;&gt;=</i></b></div><pre><code>typedef struct page_grid_d page_grid_d;</pre></code>
<div><b><i>&lt;&lt;grid_structs&gt;&gt;=</i></b></div><pre><code>struct page_grid_d {
&lt;&lt;grid_struct_contents&gt;&gt;
};</pre></code>
<div><b><i>&lt;&lt;grid_struct_contents&gt;&gt;=</i></b></div><pre><code>monolith_page_mstate *mstate;</pre></code>

<h4>1.3. Grid Page Runtime Initialization</h4>

<p><a id="wm_009_0032"></a>When a grid page is created for the first time, global data needs to be
initialized. This is done with the function <code>grid_init</code>.
<div><b><i>&lt;&lt;grid_function_declarations&gt;&gt;=</i></b></div><pre><code>static void grid_init(monolith_d *m);</pre></code>
<div><b><i>&lt;&lt;grid_functions&gt;&gt;=</i></b></div><pre><code>static void grid_init(monolith_d *m)
{
&lt;&lt;grid_init&gt;&gt;
}</pre></code>

<h4>1.4. Grid Page Creation</h4>

<p><a id="wm_009_0042"></a>A page is created with the function <code>page_grid</code>. This will take in a newly
initialized monolith page, and then assigns callback functions.
</p>
<p>The Grid page only requires use of the monome, so the press callback is the only
thing required.
</p>
<div><b><i>&lt;&lt;grid_function_declarations&gt;&gt;=</i></b></div><pre><code>static void page_grid(monolith_page *pg);</pre></code>
<div><b><i>&lt;&lt;grid_functions&gt;&gt;=</i></b></div><pre><code>static void page_grid(monolith_page *pg)
{
    page_grid_d *grid;
    grid = calloc(1, sizeof(page_grid_d));
    if(grid == NULL) return;
    if(grid_type == 0) grid_init(monolith_page_monolith(pg));
    if(!monolith_page_mstate_new(pg, &grid-&gt;mstate)) return;
&lt;&lt;grid_assign_callbacks&gt;&gt;
    monolith_page_data_set(pg, grid);
}</pre></code>

<h5>1.4.1. Setting the Grid Type Flag</h5>

<p><a id="wm_009_0050"></a><div><b><i>&lt;&lt;grid_assign_callbacks&gt;&gt;=</i></b></div><pre><code>monolith_page_type_set(pg, grid_type);</pre></code>

<h5>1.4.2. Grid Open</h5>

<p><a id="wm_009_0054"></a><div><b><i>&lt;&lt;grid_function_declarations&gt;&gt;=</i></b></div><pre><code>static void grid_open(monolith_page *pg);</pre></code>
<div><b><i>&lt;&lt;grid_functions&gt;&gt;=</i></b></div><pre><code>static void grid_open(monolith_page *pg)
{
    page_grid_d *grid;
    grid = monolith_page_data_get(pg);
    if(grid == NULL) return;
    monolith_page_mstate_recall(grid-&gt;mstate);
}</pre></code>
<div><b><i>&lt;&lt;grid_assign_callbacks&gt;&gt;=</i></b></div><pre><code>monolith_page_open_set(pg, grid_open);</pre></code>

<h5>1.4.3. Grid Free</h5>

<p><a id="wm_009_0061"></a><div><b><i>&lt;&lt;grid_function_declarations&gt;&gt;=</i></b></div><pre><code>static void grid_free(monolith_page *pg);</pre></code>
<div><b><i>&lt;&lt;grid_functions&gt;&gt;=</i></b></div><pre><code>static void grid_free(monolith_page *pg)
{
    page_grid_d *grid;
    grid = (page_grid_d *)monolith_page_data_get(pg);
    if(grid == NULL) return;
    monolith_page_mstate_free(&grid-&gt;mstate);
    free(grid);
}</pre></code>
<div><b><i>&lt;&lt;grid_assign_callbacks&gt;&gt;=</i></b></div><pre><code>monolith_page_free_set(pg, grid_free);</pre></code>

<h5>1.4.4. Monome Press Callback</h5>

<p><a id="wm_009_0068"></a><div><b><i>&lt;&lt;grid_function_declarations&gt;&gt;=</i></b></div><pre><code>static void grid_press(monolith_page *pg, int x, int y, int s);</pre></code>
<div><b><i>&lt;&lt;grid_functions&gt;&gt;=</i></b></div><pre><code>static void grid_press(monolith_page *pg, int x, int y, int s)
{
    page_grid_d *grid;
    int curstate;
    if(s == 0) return;
    grid = monolith_page_data_get(pg);
    if(grid == NULL) return;

    curstate = monolith_page_mstate_get(grid-&gt;mstate, x, y);

    if(curstate) {
        monolith_page_mstate_set(grid-&gt;mstate, x, y, 0);
    } else {
        monolith_page_mstate_set(grid-&gt;mstate, x, y, 1);
    }
}</pre></code>
<div><b><i>&lt;&lt;grid_assign_callbacks&gt;&gt;=</i></b></div><pre><code>monolith_page_press_set(pg, grid_press);</pre></code>

<h5>1.4.5. TODO State Management</h5>

<p><a id="wm_009_0075"></a></p>

<h6>1.4.5.1. DONE Schema Generation</h6>

<p><a id="wm_009_0076"></a>CLOSED: [2019-04-06 Sat 11:03]
The Schema for the "grid" page is pretty straightforward. All it needs to save
is the monome state.
<div><b><i>&lt;&lt;grid_function_declarations&gt;&gt;=</i></b></div><pre><code>static int grid_schema(page_grid_d *grid,
                       monolith_state_schema **schema);</pre></code>
<div><b><i>&lt;&lt;grid_functions&gt;&gt;=</i></b></div><pre><code>static int grid_schema(page_grid_d *grid,
                       monolith_state_schema **schema)
{
    monolith_state_schema_init(schema, 1);
    monolith_param_mkmstate(*schema, 0, "mstate", 6, grid-&gt;mstate);
    return 1;
}</pre></code>

<h6>1.4.5.2. TODO Grid Save Callback</h6>

<p><a id="wm_009_0082"></a><div><b><i>&lt;&lt;grid_function_declarations&gt;&gt;=</i></b></div><pre><code>static int grid_save(monolith_page *pg,
                     monolith_state *s,
                     const char *key,
                     unsigned int len);</pre></code>
<div><b><i>&lt;&lt;grid_functions&gt;&gt;=</i></b></div><pre><code>static int grid_save(monolith_page *pg,
                     monolith_state *s,
                     const char *key,
                     unsigned int len)
{
    page_grid_d *grid;
    monolith_state_schema *schema;
    grid = monolith_page_data_get(pg);
    grid_schema(grid, &schema);
    monolith_state_write_schema(s, schema, "grid", 4, key, len);
    monolith_state_schema_cleanup(&schema);
    return 1;
}</pre></code>
<div><b><i>&lt;&lt;grid_assign_callbacks&gt;&gt;=</i></b></div><pre><code>monolith_page_save_set(pg, grid_save);</pre></code>

<h6>1.4.5.3. TODO Grid Load Callback</h6>

<p><a id="wm_009_0089"></a><div><b><i>&lt;&lt;grid_function_declarations&gt;&gt;=</i></b></div><pre><code>static int grid_load(monolith_page *pg,
                     monolith_state *s,
                     const char *key,
                     unsigned int len);</pre></code>
<div><b><i>&lt;&lt;grid_functions&gt;&gt;=</i></b></div><pre><code>static int grid_load(monolith_page *pg,
                     monolith_state *s,
                     const char *key,
                     unsigned int len)
{
    page_grid_d *grid;
    monolith_state_schema *schema;
    int rc;
    grid = monolith_page_data_get(pg);

    grid_schema(grid, &schema);
    rc = monolith_state_read_schema(s, schema, "grid", 4, key, len);
    monolith_param_mstate(schema, 0, grid-&gt;mstate);
    if(monolith_page_selected(pg)) monolith_page_mstate_recall(grid-&gt;mstate);
    monolith_state_schema_cleanup(&schema);
    return rc;
}</pre></code>
<div><b><i>&lt;&lt;grid_assign_callbacks&gt;&gt;=</i></b></div><pre><code>monolith_page_load_set(pg, grid_load);</pre></code>

<h4>1.5. Grid Type Flag</h4>

<p><a id="wm_009_0096"></a></p>

<h5>1.5.1. Type Flag Declaration</h5>

<p><a id="wm_009_0097"></a>The grid type flag is declared as a static global variable. It is initialized to
be zero.
<div><b><i>&lt;&lt;grid_typeflag&gt;&gt;=</i></b></div><pre><code>static unsigned int grid_type = 0;</pre></code>

<h5>1.5.2. Setting the Grid Type</h5>

<p><a id="wm_009_0102"></a>The grid type flag is set once inside of <code>grid_init</code>.
</p>
<div><b><i>&lt;&lt;grid_init&gt;&gt;=</i></b></div><pre><code>grid_type = monolith_dict_newtype(monolith_dict_get(m));</pre></code>

<h5>1.5.3. Checking the Grid Type</h5>

<p><a id="wm_009_0107"></a>A page is checked to be a grid using the (static) function <code>is_grid</code>.
<div><b><i>&lt;&lt;grid_function_declarations&gt;&gt;=</i></b></div><pre><code>static int is_grid(monolith_page *pg);</pre></code>
<div><b><i>&lt;&lt;grid_functions&gt;&gt;=</i></b></div><pre><code>static int is_grid(monolith_page *pg)
{
    int type;
    type = monolith_page_type_get(pg);
    if(type == 0) return 0;
    return type == grid_type;
}</pre></code>

<h4>1.6. Grid Page Scheme Loader</h4>

<p><a id="wm_009_0113"></a>The main scheme loader is called <code>s9_load_grid</code>.
<div><b><i>&lt;&lt;grid_functions&gt;&gt;=</i></b></div><pre><code>&lt;&lt;grid_scheme_functions&gt;&gt;
static S9_PRIM grid_primitives[] = {
&lt;&lt;grid_scheme_entries&gt;&gt;
    {NULL}
};
void s9_load_grid(void)
{
    add_primitives("monolith", grid_primitives);
}</pre></code>

<h4>1.7. Grid Page Runt Loader</h4>

<p><a id="wm_009_0121"></a>Runt words are loaded inside the <code>grid_init</code> function, using the function
<code>grid_runt_loader</code>.
</p>
<div><b><i>&lt;&lt;grid_function_declarations&gt;&gt;=</i></b></div><pre><code>static int grid_runt_loader(monolith_d *m);</pre></code>
<div><b><i>&lt;&lt;grid_functions&gt;&gt;=</i></b></div><pre><code>&lt;&lt;grid_runt_functions&gt;&gt;
static int grid_runt_loader(monolith_d *m)
{
&lt;&lt;grid_runt_keywords&gt;&gt;
    monolith_runt_mark_set(m);
    return RUNT_OK;
}</pre></code>
<div><b><i>&lt;&lt;grid_init&gt;&gt;=</i></b></div><pre><code>grid_runt_loader(m);</pre></code>

<h4>1.8. Grid Scheme Functions</h4>

<p><a id="wm_009_0133"></a></p>

<h5>1.8.1. Create New Grid Page</h5>

<p><a id="wm_009_0134"></a><div><b><i>&lt;&lt;grid_scheme_entries&gt;&gt;=</i></b></div><pre><code>{"monolith:grid-new", pp_grid_new, 1, 1, {STR, ___, ___}},</pre></code>
<div><b><i>&lt;&lt;grid_scheme_functions&gt;&gt;=</i></b></div><pre><code>static cell pp_grid_new(cell x)
{
    const char *str;
    monolith_d *m;
    monolith_dict *dict;
    monolith_page *pg;
    int rc;

    m = monolith_data_get();
    dict = monolith_dict_get(m);

    str = string(car(x));

    rc = monolith_dict_newpage(dict, &pg, str, strlen(str));
    if(!rc) {
        return error(
            "could not create grid page (maybe it already exists?)",
            car(x));
    }

    page_grid(pg);

    return UNSPECIFIC;
}</pre></code>

<h5>1.8.2. Set Grid Value</h5>

<p><a id="wm_009_0141"></a><div><b><i>&lt;&lt;grid_scheme_entries&gt;&gt;=</i></b></div><pre><code>{"monolith:grid-set", pp_grid_set, 4, 4, {STR, INT, INT}},</pre></code>
<div><b><i>&lt;&lt;grid_scheme_functions&gt;&gt;=</i></b></div><pre><code>static cell pp_grid_set(cell x)
{
    const char *str;
    monolith_d *m;
    monolith_dict *dict;
    monolith_page *pg;
    int rc;
    page_grid_d *grid;
    cell cstr;
    int xpos, ypos, state;
    char name[] = "monolith:grid-set";

    m = monolith_data_get();
    dict = monolith_dict_get(m);

    cstr = car(x);
    str = string(cstr);

    rc = monolith_dict_lookup(dict, &pg, str, strlen(str));
    if(!rc) {
        return error(
            "could not find grid page",
            cstr);
    }

    x = cdr(x);
    xpos = integer_value(name, car(x));
    x = cdr(x);
    ypos = integer_value(name, car(x));
    x = cdr(x);

    if(!s9_integer_p(car(x))) {
        return error("argument should have been an integer", car(x));
    }
    state = integer_value(name, car(x));

    if(!is_grid(pg)){
        return error("page is not a grid!", car(x));
    }

    grid = (page_grid_d *)monolith_page_data_get(pg);

    monolith_page_mstate_set(grid-&gt;mstate, xpos, ypos, state);

    return UNSPECIFIC;
}</pre></code>

<h5>1.8.3. Get Grid Value</h5>

<p><a id="wm_009_0147"></a><div><b><i>&lt;&lt;grid_scheme_entries&gt;&gt;=</i></b></div><pre><code>{"monolith:grid-get", pp_grid_get, 3, 3, {STR, INT, INT}},</pre></code>
<div><b><i>&lt;&lt;grid_scheme_functions&gt;&gt;=</i></b></div><pre><code>static cell pp_grid_get(cell x)
{
    const char *str;
    monolith_d *m;
    monolith_dict *dict;
    monolith_page *pg;
    int rc;
    page_grid_d *grid;
    cell cstr;
    int xpos, ypos, state;
    char name[] = "monolith:grid-get";

    m = monolith_data_get();
    dict = monolith_dict_get(m);

    cstr = car(x);
    str = string(cstr);

    rc = monolith_dict_lookup(dict, &pg, str, strlen(str));
    if(!rc) {
        return error(
            "could not find grid page",
            cstr);
    }

    x = cdr(x);
    xpos = integer_value(name, car(x));
    x = cdr(x);
    ypos = integer_value(name, car(x));
    x = cdr(x);

    if(!is_grid(pg)){
        return error("page is not a grid!", car(x));
    }

    grid = (page_grid_d *)monolith_page_data_get(pg);

    state = monolith_page_mstate_get(grid-&gt;mstate, xpos, ypos);

    return s9_make_integer(state);
}</pre></code>

<h4>1.9. Grid Patchwerk Nodes</h4>

<p><a id="wm_009_0152"></a></p>

<h5>1.9.1. Gridstate</h5>

<p><a id="wm_009_0153"></a></p>

<h6>1.9.1.1. Gridstate Patchwerk Node</h6>

<p><a id="wm_009_0154"></a></p>

<h7>1.9.1.1.1. Gridstate Node Function</h7>

<p><a id="wm_009_0155"></a><div><b><i>&lt;&lt;grid_function_declarations&gt;&gt;=</i></b></div><pre><code>static int node_gridstate(pw_node *node, monolith_page *pg);</pre></code>
<div><b><i>&lt;&lt;grid_functions&gt;&gt;=</i></b></div><pre><code>&lt;&lt;gridstate_node_functions&gt;&gt;
static int node_gridstate(pw_node *node, monolith_page *pg)
{
    pw_node_cables_alloc(node, 3);
    pw_node_set_block(node, 2);
    pw_node_set_data(node, pg);
    pw_node_set_destroy(node, gridstate_destroy);
    pw_node_set_compute(node, gridstate_compute);
    /* TODO: "pin" page here */
    return PW_OK;
}</pre></code>

<h7>1.9.1.1.2. Gridstate Compute</h7>

<p><a id="wm_009_0162"></a><div><b><i>&lt;&lt;gridstate_node_functions&gt;&gt;=</i></b></div><pre><code>static void gridstate_compute(pw_node *node)
{
    int blksize;
    int s;
    PWFLT s_x, s_y, s_out;
    pw_cable *x, *y, *out;
    monolith_page *pg;
    page_grid_d *grid;

    blksize = pw_node_blksize(node);
    pw_node_get_cable(node, 0, &x);
    pw_node_get_cable(node, 1, &y);
    pw_node_get_cable(node, 2, &out);
    pg = pw_node_get_data(node);
    grid = monolith_page_data_get(pg);

    for(s = 0; s &lt; blksize; s++) {
        s_x = pw_cable_get(x, s);
        s_y = pw_cable_get(y, s);
        s_out = monolith_page_mstate_get(grid-&gt;mstate, (int)s_x, (int)s_y);
        pw_cable_set(out, s, s_out);
    }
}</pre></code>

<h7>1.9.1.1.3. Gridstate Destroy</h7>

<p><a id="wm_009_0166"></a><div><b><i>&lt;&lt;gridstate_node_functions&gt;&gt;=</i></b></div><pre><code>static void gridstate_destroy(pw_node *node)
{
    /* TODO: "unpin" page here */
    pw_node_cables_free(node);
}</pre></code>

<h6>1.9.1.2. Gridstate Runt Word</h6>

<p><a id="wm_009_0169"></a><div><b><i>&lt;&lt;grid_runt_keywords&gt;&gt;=</i></b></div><pre><code>monolith_runt_keyword(m, "gridstate", 9, rproc_gridstate, m);</pre></code>
<div><b><i>&lt;&lt;grid_runt_functions&gt;&gt;=</i></b></div><pre><code>static runt_int rproc_gridstate(runt_vm *vm, runt_ptr p)
{
    monolith_d *m;
    runt_int rc;
    rpw_param x;
    rpw_param y;
    const char *name;
    runt_stacklet *s;
    runt_stacklet *out;
    monolith_page *pg;
    pw_patch *patch;
    pw_node *node;

    m = runt_to_cptr(p);
    rc = runt_ppop(vm, &s);
    RUNT_ERROR_CHECK(rc);

    name = runt_to_string(s-&gt;p);

    rc = rpw_get_param(vm, &y);
    RUNT_ERROR_CHECK(rc);

    rc = rpw_get_param(vm, &x);
    RUNT_ERROR_CHECK(rc);

    rc = runt_ppush(vm, &out);
    RUNT_ERROR_CHECK(rc);

    rc = runt_monolith_lookup_page(vm, m, name,
                                   "grid",
                                   is_grid, &pg);
    RUNT_ERROR_CHECK(rc);

    patch = monolith_patchwerk_get(m);

    rc = pw_patch_new_node(patch, &node);
    PW_RUNT_ERROR_CHECK(rc);

    node_gridstate(node, pg);

    rpw_set_param(vm, node, &x, 0);
    rpw_set_param(vm, node, &y, 1);
    rpw_push_output(vm, node, out, 2);

    return RUNT_OK;
}</pre></code>
</div>
</body>
</html>
