<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/css/style.css">

</head>
<body>
<div id="main">
<title>Trig</title>
<h1>Trig</h1>
<p>A language/VM/system for computational rhythmic patterns.
Designed to eventually be programmed using the monome grid
interface.
</p>

<h3>Top Files</h3>

<div><b><i>&lt;&lt;trigvm.h&gt;&gt;=</i></b></div><pre><code>#ifndef TRIGVM_H
#define TRIGVM_H
&lt;&lt;typedefs&gt;&gt;
&lt;&lt;funcdefs&gt;&gt;
#ifdef TRIGVM_PRIVATE
&lt;&lt;structs&gt;&gt;
#endif
#endif</pre></code>
<div><b><i>&lt;&lt;trigvm.c&gt;&gt;=</i></b></div><pre><code>#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define TRIGVM_PRIVATE
#include "trigvm.h"
&lt;&lt;static_funcdefs&gt;&gt;
&lt;&lt;funcs&gt;&gt;</pre></code>

<h3>The Cell</h3>

<p>The core building block of Trig is the cell. A cell is
mainly comprised of 2 32-bit words, which will eventually
be displayed on a 8x8 grid. The topmost word holds the
data, the other will hold the command.
</p>
<div><b><i>&lt;&lt;typedefs&gt;&gt;=</i></b></div><pre><code>typedef struct trig_cell trig_cell;</pre></code>
<div><b><i>&lt;&lt;structs&gt;&gt;=</i></b></div><pre><code>struct trig_cell {
   uint32_t cmd;
   uint32_t data;
};</pre></code>
<p></p>
<p>Get these values directly with <code>trig_cell_cmd</code> and
<code>trig_cell_data</code>.
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>uint32_t trig_cell_cmd(trig_cell *c);
uint32_t trig_cell_data(trig_cell *c);</pre></code>
<p></p>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>uint32_t trig_cell_cmd(trig_cell *c)
{
    return c-&gt;cmd;
}

uint32_t trig_cell_data(trig_cell *c)
{
    return c-&gt;data;
}</pre></code>
<p></p>
<p>The main way to program cells is to set bits. This is
done by determining the word and the local XY position.
Word 0 is the top word. Word 1 is the bottom word. This is
how programming will be done on the monome (bit-by-bit,
literally).
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>void trig_cell_set(trig_cell *c, int w, int pos, int s);</pre></code>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>void trig_cell_set(trig_cell *c, int w, int pos, int s)
{
    uint32_t *x;
    if (w) {
        x = &c-&gt;data;
    } else {
        x = &c-&gt;cmd;
    }

    if (s) {
        *x |= 1 &lt;&lt; pos;
    } else {
        *x &= ~(1 &lt;&lt; pos);
    }
}</pre></code>
<p></p>
<p>In practice, bits will be toggled, not set. Do this with
<code>trig_cell_tog</code>. It's similar to <code>trig_cell_set</code>, except
that the state value isn't supplied.
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>void trig_cell_tog(trig_cell *c, int w, int pos);</pre></code>
<p></p>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>void trig_cell_tog(trig_cell *c, int w, int pos)
{
    uint32_t *x;

    if (w) {
        x = &c-&gt;data;
    } else {
        x = &c-&gt;cmd;
    }

    *x ^= 1 &lt;&lt; pos;
}</pre></code>
<p></p>
<p>Printing a cell is useful for debugging. It will also
provide a good preview for what a cell will look like
displayed on a monome.
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>void trig_cell_print(trig_cell *c);</pre></code>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>void trig_cell_print(trig_cell *c)
{
    int i;

    for (i = 0; i &lt; 64; i++) {
        int s;
        uint32_t byte;
        int pos;

        if (i &lt; 32) {
            byte = c-&gt;cmd;
            pos = i;
        } else {
            byte = c-&gt;data;
            pos = i - 32;
        }

        if (i == 32) {
            printf("\n");
        }

        s = (byte &gt;&gt; pos) & 1;

        if (s) {
            printf("#");
        } else {
            printf("-");
        }

        if (((i + 1) % 8) == 0) {
            printf("\n");
        }
    }

    printf("\n");
}</pre></code>

<h3>The VM</h3>

<p>All state data is maintained inside of a struct called
<code>trig_vm</code>.
</p>

<h4>VM Data</h4>

<div><b><i>&lt;&lt;typedefs&gt;&gt;=</i></b></div><pre><code>typedef struct trig_vm trig_vm;</pre></code>
<div><b><i>&lt;&lt;structs&gt;&gt;=</i></b></div><pre><code>&lt;&lt;trig_state&gt;&gt;
struct trig_vm {
    &lt;&lt;trig_vm&gt;&gt;
};</pre></code>
<p></p>
<p>A <code>trig_vm</code> is initialized with <code>trig_vm_init</code>.
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>void trig_vm_init(trig_vm *vm);</pre></code>
<p></p>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>void trig_vm_init(trig_vm *vm)
{
    &lt;&lt;trig_vm_init&gt;&gt;
}</pre></code>
<p></p>
<p>No destroy function needed, as there is no memory
allocation.
</p>

<h4>VM struct size</h4>

<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>size_t trig_vm_size(void);</pre></code>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>size_t trig_vm_size(void)
{
    return sizeof(trig_vm);
}</pre></code>

<h4>The Cell Pool</h4>

<p>Cells are managed in a pool of exactly 32. This fits into
a 8x4 rectangle.
<div><b><i>&lt;&lt;trig_vm&gt;&gt;=</i></b></div><pre><code>trig_cell cell[32];</pre></code>
<p></p>
<div><b><i>&lt;&lt;trig_vm_init&gt;&gt;=</i></b></div><pre><code>{
    int i;
    for (i = 0; i &lt; 32; i++) {
        vm-&gt;cell[i].cmd = 0;
        vm-&gt;cell[i].data = 0;
    }
}</pre></code>

<h4>Internal State</h4>

<p>Internal state variables that can be swapped out. Used
to have multiple readers happening at once.
</p>
<div><b><i>&lt;&lt;trig_vm&gt;&gt;=</i></b></div><pre><code>trig_state *state;
trig_state istate;</pre></code>
<p></p>
<div><b><i>&lt;&lt;trig_vm_init&gt;&gt;=</i></b></div><pre><code>vm-&gt;state = &vm-&gt;istate;</pre></code>
<p></p>
<div><b><i>&lt;&lt;trig_vm_init&gt;&gt;=</i></b></div><pre><code>trig_state_init(&vm-&gt;istate);</pre></code>

<h4>Goto</h4>

<p>Sets the cell position of the internal struct.
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>void trig_vm_goto(trig_vm *vm, int pos);</pre></code>
<p></p>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>void trig_vm_goto(trig_vm *vm, int pos)
{
    vm-&gt;istate.pos = pos;
}</pre></code>

<h5>Counter</h5>

<p>A global counter is used by certain kinds of cells for
performing patterns.
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>void trig_vm_counter_reset(trig_vm *vm);</pre></code>
<p>Just the main counter. Other states will have to be reset
another way (inside a patchwerk node... re-compilation).
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>void trig_vm_counter_reset(trig_vm *vm)
{
    vm-&gt;istate.counter = -1;
}</pre></code>

<h4>Wires</h4>

<p>"Wires" are floating point variables that can be used for
input or output. The VM doesn't really make a distinction.
</p>
<p>The number of wires can be set with the <code>TRIG_NWIRES</code> macro,
which for now is set to be 8 by default.
<div><b><i>&lt;&lt;trig_vm&gt;&gt;=</i></b></div><pre><code>#ifndef TRIG_NWIRES
#define TRIG_NWIRES 8
#endif
float wires[TRIG_NWIRES];</pre></code>
<p></p>
<div><b><i>&lt;&lt;trig_vm_init&gt;&gt;=</i></b></div><pre><code>{
    int i;
    for (i = 0; i &lt; TRIG_NWIRES; i++) {
        vm-&gt;wires[i] = 0;
    }
}</pre></code>
<p></p>
<p>A value of a wire can be retrieved using the function
<code>trig_vm_wire_get</code>.
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>float trig_vm_wire_get(trig_vm *vm, int wire);</pre></code>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>float trig_vm_wire_get(trig_vm *vm, int wire)
{
    return vm-&gt;wires[wire];
}</pre></code>
<p></p>
<p>A value of a wire can be set using the function
<code>trig_vm_wire_set</code>.
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>void trig_vm_wire_set(trig_vm *vm, int wire, float val);</pre></code>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>void trig_vm_wire_set(trig_vm *vm, int wire, float val)
{
    vm-&gt;wires[wire] = val;
    if (vm-&gt;set != NULL) {
        vm-&gt;set(vm, vm-&gt;ud, wire, val);
    }
}</pre></code>
<p></p>
<p>The pointer reference of the wire can be retrieved with
<code>trig_vm_wire_ref</code>

<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>float* trig_vm_wire_ref(trig_vm *vm, int wire);</pre></code>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>float* trig_vm_wire_ref(trig_vm *vm, int wire)
{
    return &vm-&gt;wires[wire];
}</pre></code>

<h4>Wire Callback</h4>

<p>In order to integrate wires with Patchwerk, a callback
interface is provided. This gets called anytime a cable
value is set.
</p>
<div><b><i>&lt;&lt;typedefs&gt;&gt;=</i></b></div><pre><code>typedef void (*trig_setter) (trig_vm *, void *, int, float);</pre></code>
<div><b><i>&lt;&lt;trig_vm&gt;&gt;=</i></b></div><pre><code>trig_setter set;
void *ud;</pre></code>
<div><b><i>&lt;&lt;trig_vm_init&gt;&gt;=</i></b></div><pre><code>vm-&gt;set = NULL;
vm-&gt;ud = NULL;</pre></code>
<p>It can be set with the callback with
<code>trig_vm_setter</code>.
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>void trig_vm_setter(trig_vm *vm, trig_setter fun, void *ud);</pre></code>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>void trig_vm_setter(trig_vm *vm, trig_setter fun, void *ud)
{
    vm-&gt;set = fun;
    vm-&gt;ud = ud;
}</pre></code>

<h4>Run Flag</h4>

<p>This flag is set at the beginning of a step, and will cause
the program to step through the system until a cell flips it
off.
</p>
<div><b><i>&lt;&lt;trig_vm&gt;&gt;=</i></b></div><pre><code>int running;</pre></code>
<p></p>
<div><b><i>&lt;&lt;trig_vm_init&gt;&gt;=</i></b></div><pre><code>vm-&gt;running = 0;</pre></code>

<h4>Get Cell</h4>

<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>trig_cell * trig_vm_cell_get(trig_vm *vm, int cell);</pre></code>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>trig_cell * trig_vm_cell_get(trig_vm *vm, int cell)
{
    return &vm-&gt;cell[cell];
}</pre></code>

<h3>VM State</h3>

<div><b><i>&lt;&lt;typedefs&gt;&gt;=</i></b></div><pre><code>typedef struct trig_state trig_state;</pre></code>
<p>The idea here is to have a component that allows multiple
readers to read from one pool. This sort of functionality
would make it easier for a single Trig instance to play
multiple sequences.
</p>
<p>It is initialized with <code>trig_state_init</code>.
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>void trig_state_init(trig_state *ts);</pre></code>
<p></p>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>void trig_state_init(trig_state *ts)
{
    &lt;&lt;trig_state_init&gt;&gt;
}</pre></code>
<p></p>
<p>Two big things that an independent VM state would need:
counter + cell position.
</p>
<p>For convenience purposes, an optional pointer holding
<code>trig_vm</code> is also part of the state. This makes it easier
to wrap a patchwerk node around a reader.
</p>
<div><b><i>&lt;&lt;trig_state&gt;&gt;=</i></b></div><pre><code>struct trig_state {
    int counter;
    int pos;
    int ipos;
    void *ud;
};</pre></code>
<p></p>
<div><b><i>&lt;&lt;trig_state_init&gt;&gt;=</i></b></div><pre><code>ts-&gt;counter = -1;
ts-&gt;pos = 0;
ts-&gt;ipos = 0;
ts-&gt;ud = NULL;</pre></code>
<p></p>
<p>The data in the <code>trig_state</code> struct can be set/get with
<code>trig_state_ud_set</code> and <code>trig_state_ud_get</code>.
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>void trig_state_ud_set(trig_state *state, void *ud);
void * trig_state_ud_get(trig_state *state);</pre></code>
<p></p>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>void trig_state_ud_set(trig_state *state, void *ud)
{
    state-&gt;ud = ud;
}

void * trig_state_ud_get(trig_state *state)
{
    return state-&gt;ud;
}</pre></code>
<p></p>
<p>If vm is not empty, <code>trig_state_step</code> can run
<code>trig_vm_state_step</code> internally.
</p>
<p>An initial position, <code>ipos</code>, dictates where to start.
Internally, this is represented as an 0-indexed array
offset. Externally, the values are 1-indexed in order
for it to make it align more with the visuals.
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>void trig_state_ipos(trig_state *state, int ipos);</pre></code>
<p></p>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>void trig_state_ipos(trig_state *state, int ipos)
{
    if (ipos &lt; 1 || ipos &gt; 32) return;
    state-&gt;ipos = ipos - 1;
}</pre></code>
<p></p>
<p>A state can be reset with <code>trig_state_reset</code>. This sets
the pos to be <code>ipos</code>.
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>void trig_state_reset(trig_state *state);</pre></code>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>void trig_state_reset(trig_state *state)
{
    state-&gt;pos = state-&gt;ipos;
    state-&gt;counter = -1;
}</pre></code>

<h3>Procedure (trig_vm_ex)</h3>

<p>A cell procedure determines how to determine the bitpattern
to perform a particular function. It will always return an
integer, which is the next cell position to jump to. The
three major parameters it takes in are current position,
command word, the data word. This function parses the
command word, and executes the appropriate function.
</p>
<p>When a cell is computed, it copies it's internal words over
to this function to be parsed.
</p>
<p>There are a potential of 8 major opcode types, stored in the
first 8 bits of the bytes, which correspond to 8 potential
functions.
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>int trig_vm_ex(trig_vm *vm,
               int pos,
               uint32_t cmd,
               uint32_t data);</pre></code>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>&lt;&lt;exfuncs&gt;&gt;
int trig_vm_ex(trig_vm *vm,
               int pos,
               uint32_t cmd,
               uint32_t data)
{
    if (cmd == 0) return empty(vm, pos, cmd, data);
    if (cmd & 1) return pattern(vm, pos, cmd, data);
    if (cmd & 2) return jump(vm, pos, cmd, data);
    if (cmd & 4) return maygate(vm, pos, cmd, data);
    if (cmd & 8) return metapattern(vm, pos, cmd, data);

    return empty(vm, pos, cmd, data);
}</pre></code>

<h3>Step</h3>

<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>void trig_vm_step(trig_vm *vm);</pre></code>
<p></p>
<p>When a VM step happens, it will run through the program
until it reaches a pattern cell or an empty cell. Some
protection is done to ensure that an infinite loop doesn't
happen.
</p>
<p>This now wraps around <code>trig_vm_step_state</code> using the
internal state file. See that function for more detail.s
</p>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>void trig_vm_step(trig_vm *vm)
{
    trig_vm_step_state(vm, &vm-&gt;istate);
}</pre></code>
<p></p>
<p>This <code>trig_vm_step_state</code> steps with an external state. This
can be used to allow multiple readers to happen
concurrently.
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>void trig_vm_step_state(trig_vm *vm, trig_state *ts);</pre></code>
<p></p>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>void trig_vm_step_state(trig_vm *vm, trig_state *ts)
{
    int count;
    vm-&gt;running = 1;

    count = 0;
    vm-&gt;state = ts;
    while (vm-&gt;running) {
        trig_cell *c;

        count++;

        if (count &gt;= 64) {
            fprintf(stderr,
            "trig: max count of 64 reached. "
            "breaking.\n");
            vm-&gt;running = 0;
            break;
        }

        if (ts-&gt;pos &lt; 0 || ts-&gt;pos &gt;= 32) {
            fprintf(stderr,
                    "trig: invalid position %d\n",
                    ts-&gt;pos);
            vm-&gt;running = 0;
            break;
        }
        c = &vm-&gt;cell[ts-&gt;pos];
        ts-&gt;pos = trig_vm_ex(vm, ts-&gt;pos, c-&gt;cmd, c-&gt;data);
    }

    vm-&gt;state = &vm-&gt;istate;
}</pre></code>

<h3>Empty Cell</h3>

<p>Does nothing. Goes nowhere. This can be used to terminate
programs.
<div><b><i>&lt;&lt;exfuncs&gt;&gt;=</i></b></div><pre><code>static int empty(trig_vm *vm,
                 int pos,
                 uint32_t cmd,
                 uint32_t data)
{
    vm-&gt;running = 0;
    trig_vm_wire_set(vm, 0, 0);
    return pos;
}</pre></code>

<h3>Pattern Cell</h3>

<p>A pattern cell is a kind of cell that plays a rhythmic
pattern. It can have a maximum size of 32. When the VM
arrives on a pattern cell, it will begin playing the cell
pattern. It will remain on this cell until it reaches the
end of the pattern, then it will go to the next cell.
</p>
<p>A pattern cell can write to any of the 8 wires. It will use
the rightmost bit on the second byte to determine which wire
to write to. If no bits are turned on, it is assumed to be
wire 1.
</p>
<p>The counter is used to extract the corresponding bit state
in a way you'd typically expect. When the counter reaches
the end of pattern, it returns the next position in the
series, with loopback if appropriate.
</p>
<p>A pattern cell uses the global counter variable to maintain
state. If the counter is at -1, it assumed that the VM just
arrived at the pattern, and uses this to initialize the
counter to be 0.
</p>
<p>A bit of bitwise magic is used to determine the rightmost
bit of the third byte (<code>x & -x</code>) was retrieved from the book
"hackers delight" in the section called "the basics".
</p>
<p>Wire number from the byte gets converted to a wire position
<code>wp</code> using a sort of log2 while-loop function.
</p>
<p>The fourth command byte is used for additional
functionality. The byte is divided up into 2 nibbles.
The lower nibble determines the command, the upper
nibble defines the data. This is done because it will
show up command, data on the monome.
</p>
<p>If the command nibble is 0, nothing happens.
</p>
<p>Nibble command 1 enables switch mode. It will split
the pattern into 2 16-bit sections. It will reading from
the wire specified in the nibble data. A zero value will'
select the lower half pattern. A non-zero value selects the
upper half pattern. The wire data is specified as a binary
value.
<div><b><i>&lt;&lt;exfuncs&gt;&gt;=</i></b></div><pre><code>static int pattern(trig_vm *vm,
                   int pos,
                   uint32_t cmd,
                   uint32_t data)
{
    int nib;
    int dur;
    uint32_t pat;
    trig_state *ts;

    ts = vm-&gt;state;
    dur = (cmd &gt;&gt; 16) & 0xFF;
    dur *= (dur &lt;= 32);
    nib = (cmd &gt;&gt; 24) & 0xFF;
    pat = data;

    if (nib & 0xf) {
        int ncmd;
        int ndat;

        ncmd = nib & 0xf;
        ndat = (nib &gt;&gt; 4) & 0xf;

        if (ncmd == 1) {
            int wire;

            wire = ndat;
            if (wire &gt; 0 && wire &lt;= 8) wire--;
            else wire = 0;

            if (vm-&gt;wires[wire] == 0) {
                pat = data & 0xFFFF;
            } else {
                pat = (data &gt;&gt; 16) & 0xFFFF;
            }
        }
    }

    vm-&gt;running = 0;

    if (ts-&gt;counter == -1) {
        ts-&gt;counter = 0;
    } else {
        ts-&gt;counter++;
    }

    if (ts-&gt;counter == dur || dur == 0) {
        ts-&gt;counter = -1;
        vm-&gt;running = 1;
        return (pos + 1) % 32;
    } else {
        int wire;
        int s;
        int wp;

        wire = (cmd &gt;&gt; 8) & 0xFF;

        if (wire == 0) {
            wire = 1;
        } else {
            /* only use rightmost bit */
            wire = wire & -wire;
        }

        wp = 0;

        while (wire &gt;&gt;= 1) wp++;


        s = (pat & (1 &lt;&lt; ts-&gt;counter)) != 0;

        trig_vm_wire_set(vm, wp, s);

        return pos;
    }

    return pos;
}</pre></code>

<h3>Jump Cell</h3>

<p>A jump cell is used to jump to a particular cell. This wire
is multifunctional, depending on the states of the command
cell.
</p>
<p>Location is stored in the rightmost turned on bit in data.
Each bit correspond to a location in the cell pool
(of size 32). If no bits are turned on, the jump cell is
is ignored.
</p>
<p>If the second command byte is zero, it will behave as a goto
operation and immediately go to the cell location in the
data word.
</p>
<p>If the second command byte is a non zero value, it will use
the wire in the rightmost bit as a conditional. If the wire
is non-zero, it will go to the location. Otherwise, it will
continue on to the next cell in the VM.
</p>
<div><b><i>&lt;&lt;exfuncs&gt;&gt;=</i></b></div><pre><code>static int jump(trig_vm *vm,
                int pos,
                uint32_t cmd,
                uint32_t data)
{
    int go;
    int rbit;
    int wire;

    if (data == 0) return (pos + 1) % 32;

    rbit = (data & -data);

    go = 0;

    while (rbit &gt;&gt;= 1) go++;

    wire = (cmd &gt;&gt; 8) & 0xFF;

    if (wire == 0) {
        return go % 32;
    } else {
        int wp;

        rbit = wire & -wire;

        wp = 0;
        while (rbit &gt;&gt;= 1) wp++;

        if (trig_vm_wire_get(vm, wp) != 0) return go % 32;
    }

    return (pos + 1) % 32;
}</pre></code>

<h3>Maygate Cell</h3>

<p>Randomly sets the state of a wire to be 1 or 0.
</p>
<p>byte 1: wire to set. 0 by default.
</p>
<p>For now, this is just a cointoss (50/50) probability.
</p>
<p>If the data is non-zero, maygate can function as a
conditional jump. The random state of 1 will cause a jump
to the location stored in the data byte.
</p>
<div><b><i>&lt;&lt;exfuncs&gt;&gt;=</i></b></div><pre><code>static int maygate(trig_vm *vm,
                   int pos,
                   uint32_t cmd,
                   uint32_t data)
{
    int byte;
    int wire;
    double rnd;

    byte = (cmd &gt;&gt; 8) & 0xFF;

    /* right most bit */
    byte &= -byte;

    wire = 0;
    while (byte &gt;&gt;= 1) wire++;

    rnd = (double) rand() / RAND_MAX;

    if (rnd &gt; 0.5) {
        trig_vm_wire_set(vm, wire, 1);
    } else {
        trig_vm_wire_set(vm, wire, 0);
    }

    if (data == 0) {
        return (pos + 1) % 32;
    } else {
        if (rnd &gt; 0.5) {
            int go;

            byte = data;
            byte &= -byte;
            go = 0;
            while (byte &gt;&gt;= 1) go++;

            return go;
        } else {
            return (pos + 1) % 32;
        }
    }
}</pre></code>

<h3>Metapatterns</h3>

<p>A "metapattern" is a pattern that references another
pattern, and applies some transformations to it. After it
applies the transformations, it behaves just like a pattern
would.
</p>
<p>The metapattern uses all bytes in the word as a single unit,
rather than making between data + command.
</p>
<p>After the first metapattern identifying byte comes the byte
that holds the pattern reference. Encoded in binary, the
pattern reference the location in the cell pool. This
reference can either be a pattern or another metapattern.
</p>
<p>The remaining 6 bytes are used as transformation commands
that can be composed together. These transformation commands
non-destructively alter the pattern in some way.
</p>
<p>A transformation command byte is divided up into two
nibbles. The lower (lefthand) nibble displays the command,
the upper (righthand) nibble is the parameter.
</p>
<p>Transformations may include:
</p>
<p>left/right rotational shift: shift the entire pattern
by some amount with wraparound.
</p>
<p>shrink/expand: take a pattern and stretch/squash it by
some factor.
</p>
<p>invert: flips the bits of the pattern.
</p>
<p>crop: takes only a portion of the pattern
</p>
<p>repeat: repeats a segment of a pattern a certain number
of times
</p>
<p>reverse: reverses the pattern
</p>
<p>mirror: creates a mirror image of the pattern
</p>
<p>decimate: add some kind of noise/randomness to
the pattern
</p>
<div><b><i>&lt;&lt;exfuncs&gt;&gt;=</i></b></div><pre><code>static int metaprocess(trig_vm *vm, int pos,
                       uint32_t cmd,
                       uint32_t data,
                       uint32_t *cmdout,
                       uint32_t *dataout)
{
    int pat;
    uint32_t pcmd;
    uint32_t pdat;
    trig_cell *c;

    pat = (cmd &gt;&gt; 8) & 0xFF;

    if (pat &lt; 1 || pat &gt; 32) {
        return empty(vm, pos, 0, 0);
    }
    pat--;

    c = trig_vm_cell_get(vm, pat);

    pcmd = c-&gt;cmd;
    pdat = c-&gt;data;

    if (pcmd & 8) {
        if (pos == pat) return empty(vm, pos, 0, 0);
        return metaprocess(vm, pos, pcmd, pdat, cmdout, dataout);
    } else if (pcmd & 1) {
        uint8_t ncmd;
        uint8_t ndat;
        uint8_t nib;
        int n;
        int update;
        int next;

        update = 0;
        for (n = 0; n &lt; 6; n++) {
            if (n &lt;= 1) {
                nib = (cmd &gt;&gt; (16 + n*8)) & 0xFF;
            } else {
                nib = (data &gt;&gt; ((n - 2)*8)) & 0xFF;
            }

            ncmd = nib & 0xf;
            ndat = (nib &gt;&gt; 4) & 0xf;

            if (ncmd == 1) {
                &lt;&lt;simple_commands&gt;&gt;
            } else if (ncmd == 2) {
                &lt;&lt;backward_shift&gt;&gt;
            } else if (ncmd == 3) {
                &lt;&lt;forward_shift&gt;&gt;
            } else if (ncmd == 15) {
                &lt;&lt;cellular_automata&gt;&gt;
            }
        }

        next = pattern(vm, pos, pcmd, pdat);

        if (update) {
            &lt;&lt;update_the_cell&gt;&gt;
        }

        return next;
    }

    return empty(vm, pos, 0, 0);
}

static int metapattern(trig_vm *vm,
                       int pos,
                       uint32_t cmd,
                       uint32_t data)
{
    uint32_t pcmd;
    uint32_t pdat;

    pcmd = 0;
    pdat = 0;

    return metaprocess(vm, pos, cmd, data, &pcmd, &pdat);
}</pre></code>

<h4>Parameterless Transformations</h4>

<p>To save on bits, all commands that do not require any
parameters in the data nib are thrown into command nib 1.
These are known as "simple" commands. The data portion
of the simple commands is used to tell which command to use.
</p>
<p>At the moment:
</p>
<p>0: invert
</p>
<p>1: reverse
</p>
<p>2: update
<div><b><i>&lt;&lt;simple_commands&gt;&gt;=</i></b></div><pre><code>if (ndat == 0) {
    &lt;&lt;command_invert&gt;&gt;
} else if (ndat == 1) {
    &lt;&lt;reverse_command&gt;&gt;
} else if (ndat == 2) {
    &lt;&lt;update_command&gt;&gt;
}</pre></code>

<h5>Inversion</h5>

<p>Inversion (0) simply inverts the entire data bit. Anything
that is a 1 becomes a 0, and vice versa.
</p>
<div><b><i>&lt;&lt;command_invert&gt;&gt;=</i></b></div><pre><code>pdat = ~pdat;</pre></code>

<h5>Reverse</h5>

<p>Reversal (1) reverses the pattern. This requires knowing the
size of the pattern, so both the command and data words of
the pattern are needed.
</p>
<div><b><i>&lt;&lt;reverse_command&gt;&gt;=</i></b></div><pre><code>pdat = reverse(pcmd, pdat);</pre></code>
<p></p>
<div><b><i>&lt;&lt;static_funcdefs&gt;&gt;=</i></b></div><pre><code>static uint32_t reverse(uint32_t cmd, uint32_t dat);</pre></code>
<p></p>
<p>Reversal does what you'd do for a reverse-in-place on
a string, only with bits.
</p>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>static uint32_t reverse(uint32_t cmd, uint32_t dat)
{
    uint32_t out;
    uint8_t sz;
    uint8_t szd2;
    int n;

    sz = (cmd &gt;&gt; 16) & 0xFF;
    szd2 = sz / 2;

    out = dat;

    for (n = 0; n &lt; szd2; n++) {
        int s1, s2;
        int end;

        end = sz - n - 1;

        s1 = (dat &gt;&gt; n) & 1;
        s2 = (dat &gt;&gt; end) & 1;

        if (s1) {
            out |= (1 &lt;&lt; end);
        } else {
            out &= ~(1 &lt;&lt; end);
        }

        if (s2) {
            out |= (1 &lt;&lt; n);
        } else {
            out &= ~(1 &lt;&lt; n);
        }

   }

    return out;
}</pre></code>

<h5>Update</h5>

<p>The <code>update</code> copies over the metapattern as it exists back
to the original pattern. This command will set an <code>update</code>
flag to be 1.
</p>
<div><b><i>&lt;&lt;update_command&gt;&gt;=</i></b></div><pre><code>update = 1;</pre></code>
<p></p>
<p>The cell should only be updated when the pattern reaches
the end. This is checked by seeing if the return position
differs.
</p>
<div><b><i>&lt;&lt;update_the_cell&gt;&gt;=</i></b></div><pre><code>if (next != pos) {
    c-&gt;cmd = pcmd;
    c-&gt;data = pdat;
}</pre></code>

<h4>1-bit CA</h4>

<p>1-dimensional cellular automata (15, all on) can be applied
to the 32-bit pattern data from a rule. A rule is an 8-bit
number. Command nibbles are only 4 bits, so to make this
work, this command gobbles up the following byte, and reads
all 8 bits as the parameter for rule.
</p>
<p>This particular cellular automata implementation was adapted
from
<a href="https://rosettacode.org/wiki/Elementary_cellular_automaton#C">rosetta code</a>.
<div><b><i>&lt;&lt;cellular_automata&gt;&gt;=</i></b></div><pre><code>uint8_t rule;
uint32_t out;
int j;

rule = 0;
out = 0;
#define B(x) (1 &lt;&lt; (x))
if (n &lt; 5) {
    n++; /* skips the next byte */
    if (n &lt;= 1) {
        rule = (cmd &gt;&gt; (16 + n*8)) & 0xFF;
    } else {
        rule = (data &gt;&gt; ((n - 2)*8)) & 0xFF;
    }

    for (j = 0; j &lt; 32; j++) {
        if (rule & B(7 & (pdat&gt;&gt;(j-1) | pdat&lt;&lt;(32+1-j))))
            out |= B(j);
    }

    pdat = out;
}
#undef B</pre></code>

<h4>WIP Shifts</h4>

<p>ncmds 2 and 3 do rotational shifts of a pattern, with the
ncmd being a value for how many times to shift.
</p>
<p>Normally, these shifts are referred to as left/right shifts,
but this can be confusing with the little-endian binary
representation. Instead, the terms <code>forward</code> and <code>backward</code>
will be used relative to how they are displayed. 2 will be
a forward (right) shift, and 3 will be a backward (left)
shift.
</p>
<p>A rotational shift moves bits in a direction, and does wrap
around. This operation to be specially built in order to
compensate for pattern size. This operation does one shift
at a time. It shifts the value, takes the shifted bit, and
ORs it to the other side.
</p>
<p>A forward shift is actually a left shift on the the layout
(counter-intuitive riight?).
</p>
<div><b><i>&lt;&lt;static_funcdefs&gt;&gt;=</i></b></div><pre><code>static uint32_t fshift_1(uint32_t n, uint32_t patsize);</pre></code>
<p></p>
<p>First, the rotated bit is retrieved by ANDing the value at
the end of the pattern position.
</p>
<p>The value is then left shifted, masked, and then the rotated
bit is OR'd into the first position.
</p>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>static uint32_t fshift_1(uint32_t x, uint32_t patsize)
{
    uint32_t out;
    int bit;

    bit = (x & (1 &lt;&lt; (patsize - 1))) &gt; 0;
    out = (x &lt;&lt; 1);
    out |= bit;
    if (patsize &lt; 32) out &= (1 &lt;&lt; patsize) - 1;
    return out;
}</pre></code>
<p></p>
<div><b><i>&lt;&lt;static_funcdefs&gt;&gt;=</i></b></div><pre><code>static uint32_t fshift(uint32_t cmd, uint32_t dat, int n);</pre></code>
<p></p>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>static uint32_t fshift(uint32_t cmd, uint32_t dat, int n)
{
    uint32_t out;
    uint32_t sz;
    int i;
    sz = (cmd &gt;&gt; 16) & 0xFF;
    out = dat;

    for (i = 0; i &lt; n; i++) out = fshift_1(out, sz);

    return out;
}</pre></code>
<p></p>
<div><b><i>&lt;&lt;forward_shift&gt;&gt;=</i></b></div><pre><code>{
    pdat = fshift(pcmd, pdat, ndat);
}</pre></code>
<p></p>
<p>A backward shift (right shift) is mirror of the forward
shift. The rotated bit is the very first bit, and gets OR'd
into the last bit position in the pattern.
</p>
<div><b><i>&lt;&lt;static_funcdefs&gt;&gt;=</i></b></div><pre><code>static uint32_t bshift_1(uint32_t n, uint32_t patsize);</pre></code>
<p></p>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>static uint32_t bshift_1(uint32_t x, uint32_t patsize)
{
    uint32_t out;
    int bit;

    bit = (x & 1);
    out = (x &gt;&gt; 1);
    out |= (bit &lt;&lt; (patsize - 1));
    if (patsize &lt; 32) out &= (1 &lt;&lt; patsize) - 1;
    return out;
}</pre></code>
<p></p>
<div><b><i>&lt;&lt;static_funcdefs&gt;&gt;=</i></b></div><pre><code>static uint32_t bshift(uint32_t cmd, uint32_t dat, int n);</pre></code>
<p></p>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>static uint32_t bshift(uint32_t cmd, uint32_t dat, int n)
{
    uint32_t out;
    uint32_t sz;
    int i;
    sz = (cmd &gt;&gt; 16) & 0xFF;
    out = dat;

    for (i = 0; i &lt; n; i++) out = bshift_1(out, sz);

    return out;
}</pre></code>
<p></p>
<div><b><i>&lt;&lt;backward_shift&gt;&gt;=</i></b></div><pre><code>{
    pdat = bshift(pcmd, pdat, ndat);
}</pre></code>
</div>
</body>
</html>
