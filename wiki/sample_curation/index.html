<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/css/style.css">

</head>
<body>
<div id="main">
<title>Sample Curation</title>
<h1>Sample Curation</h1>

<h2>The Sample Curation Problem</h2>

<p>A on-going problem of mine: how does one efficiently manage
or <code>curate</code> a large database of <code>samples</code>?
</p>
<p>My compositions up to this point in time have been largely
vacant of samples for this reason. I do have sample
collections, I always find myself overwhelmed when it comes
to choosing a sample. How do I know when I have found the
"right" sample? And what happens if I find a good sample,
but I don't have a use for it? I don't have a good system
in place, so sample selection for me comes down to either
random selection, panick-y random trial and error, or just
what is most convenient (first one selected, selection from
a arbitrarily limited subset, etc).
</p>

<h2>A Potential Solution</h2>

<p>This is beginning to be realized in a few existing tools of
mine: <a href="/wiki/weewiki">weewiki</a>, <a href="/wiki/zet">zet</a>, and
<a href="/wiki/crate">crate</a>, are the notable ones. These provide a
means for collecting, annotating, tagging, and connecting
samples.
</p>
<p>The premise is to think of a sample library like a
<a href="/wiki/zettelkasten">zettelkasten</a>.
</p>

<h2>Sample Curation Actions</h2>

<p>Outlined below are the actions needed for a successful
sample curation system, with some implemented solutions.
</p>

<h3>Listen</h3>

<p>you gotta hear it! and you gotta hear lots of them.
</p>
<p>I currently use <a href="/wiki/monolith">monolith</a> for my interactive
audio needs. Being able to build something on top of that
could save me from re-implementing mundane stuff, and it
could also be an interesting way to hook into my composition
environment.
</p>
<p>There's still the issue of interface, which I don't think
monolith addresses right now. <a href="https://github.com/paulbatchelor/noice">noice</a> has been
my go-to interface, with a few modifications. <code>noice</code>reduces the task of listening to files down to a few
keystrokes and is quite ergonomic to use.
</p>

<h3>Browse</h3>

<p><code>Browse</code> refers to the ability to effortlessly navigate,
listen, and discover a collection of samples. This will
probably be one of the last of the actions I'll address.
</p>
<p>The easiest way to accomplish this is with a filesystem and
a good filebrowser. In my <a href="https://github.com/paulbatchelor/noice">aging fork of noice</a>,
an <code>ncurses</code> based filebrowser,
one is able to navigate a file tree
and play wav files using only a few keystrokes. For what
it is, it works pretty well. But static file tree
structures are rigid. Still, it is a good start.
</p>
<p>Using a <code>bitmap</code> interface instead could provide
a more helpful interface for browsing. Even a <code>1bit</code>graphics buffer could be useful in things like visualizing
waveforms. As it just so happens, I have a <a href="#">btprnt</a> that probably could
be a good start. An interactive backend would still need
to be writen, which is where <a href="/wiki/bitwrite">bitwrite</a> may
come in. This project is a ways off though.
</p>

<h3>Annotate</h3>

<p><code>Annotation</code> is about writing stuff down. Both long and
short-form writing is needed.
</p>
<p>Short-term annotations need to be quick and painless. The
same transactional cost one gets from tooting from mastodon.
</p>
<p>Long-form writing should be done in a format that makes it
easy to do edits and rewrites. A text file with some kind of
markup should do the trick.
</p>
<p>For long-form writing, there's <code>weewiki</code>. <a href="/wiki/weewiki">weewiki</a> strengths include the org markup syntax and the
links. High-level ideas can be encapsulated in this format,
which can lead to thoughtful ways to organize and curate
sounds.
</p>
<p>For short term writing, I've created a <code>zettelkasten</code> in
weewiki called the <a href="/wiki/zet">zet</a>. The <code>zet</code> interface is
loosely based on <a href="/wiki/twtxt">twtxt</a>, and allows not only logs
and messages, but links to files as well.
</p>

<h3>Store</h3>

<p>A meaningful way to store and organize samples and metadata.
</p>
<p>To do this task, I've created <a href="/wiki/crate">crate</a>. <code>crate</code>is built on top of the weewiki <code>zet</code> as a means to connect
to <a href="/wiki/sqlar">sqlar</a>.
</p>
<p>The <code>sqlar</code> library has always been attractive for
me because the SQLite format makes it easy to build
structures on top of it. Also, I personally like having
everything self-contained. There are performance trade-offs,
but it's a cost I'm willing to pay at this personal scale.
</p>
<p>Programs like <a href="/wiki/monolith">monolith</a> already have the ability
to read directly from SQLar files, and more recently, also
<code>crate</code> files! See <a href="/proj/monolith/wiki/sqlar">the sqlar monolith wiki page</a> for more details.
</p>

<h3>Query</h3>

<p><code>Query</code> refers to being able to find sampels given some sort
of parametric constraints.
</p>
<p><a href="/wiki/sqlite">SQLite</a> comes in handy yet again.
Weewiki, Zet, and Crate are all built on top of SQLite,
so they all can leverage the SQLite query language, which
has proven to be quite powerful even in the initial stages
I'm currently at.
</p>

<h2>Updates</h2>

<p>Updates about this page from the <a href="/wiki/zet">zet</a> will be
dynamically generated below:
</p>
<p></p>
<blockquote>
<p><b>2021-11-10 10:45:45</b>: (<a href="/wiki/sqlar">sqlar</a>) and sqlarfs have been pretty convenient in my (<a href="/wiki/sample_curation">sample_curation</a>) workflow efforts. The idea of everything belong to one centralized thing is very grounding from a creative point of view.
</p>
<p><b>2021-11-06 14:55:30</b>: it's taken all year, but (<a href="/wiki/novembeat_2021">novembeat_2021</a>) has finally been the motivation for me to look at the (<a href="/wiki/zet">zet</a>) I started for samples. (<a href="/wiki/gest">gest</a>) really was the missing link in all this.
</p>
<p><b>2021-01-09 14:38:19</b>: some rewriting of (<a href="/wiki/sample_curation">sample_curation</a>) done.
</p>
<p><b>2021-01-09 13:19:06</b>: I really need to rewrite (<a href="/wiki/sample_curation">sample_curation</a>), now that I've built out the (<a href="/wiki/zet">zet</a>) and (<a href="/wiki/crate">crate</a>) interfaces.
</p>
<p><b>2021-01-09 13:14:18</b>: getting the hang of managing external harddrives in a workflow. All this time and I just avoided the problem by not using samples and synthesizing everything.
</p>
<p><b>2020-12-23 10:08:23</b>: the (<a href="/wiki/sqlar">sqlar</a>) loadwav utility has been reworked slightly so that it reads from a sqlite handle rather than a filename. It's necessary to deal with a runt quirk, but I also think of it as a smarter step forward.
</p>
<p><b>2020-12-20 17:26:42</b>: picking a sample at random from a library is a totally valid approach to sample curation. So, I added a shuffle feature to the (<a href="/wiki/zet">zet</a>) which picks N random elements that match a pattern. This general thing can then be used with (<a href="/wiki/crate">crate</a>) to choose random samples from a folder.
</p>
<p><b>2020-12-19 11:21:01</b>: just connected the (<a href="/wiki/zet">zet</a>) and (<a href="/wiki/crate">crate</a>) pages to (<a href="/wiki/sample_curation">sample_curation</a>). That's a neat zet trick.
</p>
<p><b>2020-12-19 10:23:04</b>: some good stuff is happening with the weewiki zet page wrt sample curation. will have to update the (<a href="/wiki/sample_curation">sample_curation</a>) page soon.
</p>
</blockquote>
<hr>
<p><a href="/wiki/">home</a> | <a href="/wiki/wiki_index">index</a></div>
</body>
</html>
