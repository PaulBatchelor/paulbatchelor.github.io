<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/css/style.css">

</head>
<body>
<div id="main">
<title>Literate Programming</title>
<h1>Literate Programming</h1>
<p><a href="/wiki/keywords">keywords</a>: <code>literate programming</code> <code>lp</code> <code>knuth</code><code>worgle</code> <code>cweb</code> <code>web</code>.
</p>
<p><a href="https://en.wikipedia.org/wiki/Literate_programming">Literate programming</a> is a programming paradigm invented by
Donald Knuth.
</p>
<p>The core concept in literate programming is to better
leverage natural language to better increase the readability
of a program.
</p>

<h2>Example Literate Programs</h2>

<p>The following are works of the author that explore literate
programming
</p>

<h3>Worgle</h3>

<p><a href="/wiki/worgle">Worgle</a> is tangler for literate programs
written in org markdown. <code>Worgle</code> is written in a literate
style using Org, and is tangled in code using itself.
</p>

<h3>Patchwerk</h3>

<p><a href="/proj/patchwerk">Patchwerk</a> is a C library for creating
reasonably efficient audio graphs. <code>Patchwerk</code> is written
in <code>CWEB</code>.
</p>

<h3>Monolith</h3>

<p><a href="/wiki/monolith">Monolith</a> is a compositional
environment with an emphasis on realtime audio and live
coding. The core <code>monolith</code> program is written in a
literate style using <code>Org</code> markdown and <a href="/proj/worgle">Worgle</a>.
It is perhaps the single largest example of a program
written in Org Markdown (via <code>worgle</code>).
</p>

<h3>Libline</h3>

<p><a href="/proj/libline">libline</a> is a library for creating
audio-rate line segements, written as a literate
program in <code>CWEB</code>.
</p>

<h3>Voc</h3>

<p><a href="/proj/voc">Voc</a> is a C port of
<a href="https://dood.al/pinktrombone/">pink trombone</a>. It is a
physical model of the vocal tract. Voc is written
using <code>CWEB</code>.
</p>

<h2>Notable Literate Programs</h2>

<p>Good literate programs that you should know about,
if you don't know them already.
</p>

<h3>TeX</h3>

<p>The original <code>TeX</code> typesetting system was written by Donald
Knuth using <code>WEB</code>, his literate programming tool.
</p>

<h3>PBRT</h3>

<p>The textbook
<a href="https://pbrt.org">Physically Based Rendering Techniques</a>,
or <code>PBRT</code> for short, is both a textbook on physically modelled
raytracing techniques, and a program which compiles to a
very capable raytracer. It is written using a homegrown
version of <code>noweb</code>.
</p>

<h3>s9fes</h3>

<p>Scheme 9 from extended space, or
<a href="https://www.t3x.org/s9fes/">s9fes</a> is a public domain
dialect of scheme, implemented in ANSI C. The author
has developed it in a semi-literate style using
<a href="https://www.t3x.org/s9fes/edoc.html">EDOC</a>, a
documentation tool of their own creation. The resulting
work is a
<a href="https://www.t3x.org/s9book/index.html">book available for purchase</a>.
(It is a very well written book that goes into the entire
implementation).
</p>

<h2>Tools for Literate Programming</h2>


<h3>WEB/CWEB</h3>

<p><a href="https://en.wikipedia.org/wiki/WEB">WEB</a> was the original
literate programming system developed by Donald Knuth. It
was most famously used to develop the TeX typesetting
system. The original WEB was built to tangle PASCAL code.
A version for the C programming language was developed
called <a href="https://en.wikipedia.org/wiki/CWEB">CWEB</a>.
</p>

<h3>Noweb</h3>

<p><a href="https://www.cs.tufts.edu/~nr/noweb/">noweb</a> is a literate
programming system that aims to be simpler and more flexible
than the WEB system. <code>Noweb</code> has the ability to target HTML
and TeX system, and can work with any language.
</p>

<h3>OrgMode</h3>

<p><a href="https://orgmode.org">Org Mode</a> is a highly configurable
outlining system commonly used for note taking and
task management. <code>Org mode</code> is capable of noweb style
literate programming via
<a href="https://orgmode.org/worg/org-contrib/babel/intro.html#literate-programming">Babel</a>.
</p>

<h3>Leo</h3>

<p><a href="http://leoeditor.com/">Leo</a> is an outline-based
IDE that provides a very powerful environment for literate
programming. <code>Leo</code> is highly suggested to read
<a href="http://leoeditor.com/preface.html">A brief summary of leo</a>.
</p>

<h3>Eve</h3>

<p><code>Eve</code> was an experimental IDE heavily
<a href="http://witheve.com/deepdives/literate.html">inspired by literate programming</a>.
</p>

<h2>"True" Literate Programming</h2>

<p>A common misconception with literate programming is that
it is a form enhanced documentation. It is true that
literate programming tool can be used in this way, but this
approach does not represent what it means to write things in
a "literate" style. In a regular
program, documentation follows code. In a literate program,
code follows documentation.
</p>
<p>A <b>true</b> literate program gets the programmer in question
to think of program structure in terms of natural language
instead machine language.
For this to happens, a literate programming environment must
do two important things:
</p>
<p>1. Code needs to be explained out of order. Both noweb and
web do this using a sort of macro expansion system. It is
important that definitions don't need to happen before they
are used in a code block.
</p>
<p>2. The code generation bit (referred to as "tangling") is
used to abstract away the code structure from the user. The
only thing reading these files should be
compilers/interpreters/REPLs, not humans.
</p>
<p>If a LP tool fails to do both of these things, it is tool
that embraces literate programming as Knuth intended.
</p>

<h2>Problems with literate programming</h2>

<p>Gosh. <a href="/wiki/antilp">There are a few</a>.
Half the time I wonder
why I even bother. The other half of the time, I'm so
enamored with the discipline that I can't help but try it.
</p>
<p>A bad literate program is worse than no literate program at
all. It is very easy for your code to turn in to an
incomprehensible mess of spaghetti code and jargon
(in many ways, <a href="/proj/voc">Voc</a> is a prime example of such
a failure). A literate program can be a good barometer for
code quality. If things read like a rushed first draft,
the code probably is too. If it is a thoughtful read, the
code is as well. This can be a metric not only for entire
codebases, but also sections of codebases as well.
</p>
<p>Collaboration seems to be tough. I've had little to no
experience collaborating on a literate project, but the
paradigm seems mostly apt for single-brain projects.
Uncoincidentally, so is writing. I a solution could be found
if one treats a program like writing a book, rather than a
codebase. This is just a hunch, though.
</p>
<p>Literate programming takes more time because writing takes
time. Programs take longer to write, but more often than not
they end being better programs. The LP paradigm encourages
thoughtful programming, which leads to better software
in the long-term.
</p>
<hr>
<a href="/wiki/">home</a> | <a href="/wiki/wiki_index">index</a></div>
</body>
</html>
