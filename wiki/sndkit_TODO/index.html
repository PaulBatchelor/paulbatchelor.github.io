<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/css/style.css">

</head>
<body>
<div id="main">
<title>sndkit TODO</title>
<h1>sndkit TODO</h1>
<p>A dynamically generated list of public-facing TODO items for
<a href="/wiki/sndkit">sndkit</a>. The TODO list is managed using this
wiki's <a href="/wiki/zetdo">zetdo</a>, using the state <code>TODO-sndkit</code>.
</p>
<p></p>

<h2>create graforge performance utility that works similar to pipelining diagram</h2>

<a id="1438984d"></a><p>UUID: <a href="#1438984d">#1438984d</a>.
</p>
<blockquote>
<p><b>2022-04-03 07:23:34</b>: inspired by reading about pipelining diagrams in CSAPP. what I'm thinking at the moment is to build an interface that renders a node list in a patch, and then times how long each component takes.
</p>
</blockquote>
</p>

<h2>create faust nodes in sndkit</h2>

<a id="3842ba70"></a><p>UUID: <a href="#3842ba70">#3842ba70</a>.
</p>
<blockquote>
<p><b>2022-03-23 09:39:38</b>: some way to easily wrap sndkit nodes and LIL boilerplate around Faust generated C code. If I just make them single-sample tick functions.
</p>
</blockquote>
</p>

<h2>create new tract model with glottal pulse noise</h2>

<a id="80fc9d2a"></a><p>UUID: <a href="#80fc9d2a">#80fc9d2a</a>.
</p>
<p>glottis from pink trombone has a few limitations. I'd like to build a modified version of this that has better waveshape control with pulsed glottal noise.
</p>
<blockquote>
<p><b>2022-04-15 09:23:00</b>: The timing of the pulsed noise is something I need to look into. Where it occurs in the period, and for what duration. I already know that they used some kind of hann window for an envelope, applied to some noise filtered at I want to say ~4khz? It's all in a published paper that Lu wrote.
</p>
<p><b>2022-04-12 10:53:14</b>: might be worth studying this a bit more closely, just to make sure I'm getting it right. PRC and Lu.
</p>
<p><b>2022-04-06 13:53:41</b>: singing stuff is important to me right now. I think this will be investigated after I examine the gnuspeech TRM and study fricatives and consonsants. I'll be adding this to my agenda.
</p>
<p><b>2022-02-05 10:55:29</b>: you know, assuming it works. still prototyping.
</p>
</blockquote>
</p>

<h2>update landing page for sndkit</h2>

<a id="a5ae35b6"></a><p>UUID: <a href="#a5ae35b6">#a5ae35b6</a>.
</p>
<blockquote>
</blockquote>
</p>

<h2>create sound recipes page in sndkit</h2>

<a id="ae5a3011"></a><p>UUID: <a href="#ae5a3011">#ae5a3011</a>.
</p>
<blockquote>
<p><b>2022-04-06 16:20:55</b>: My initial thinking here was to port my initial synthwave instrument elements. I feel like that would be an easier thing for me to do than make a blog series.
</p>
<p><b>2022-04-06 16:18:45</b>: it seems I made an initial recipes branch
</p>
<p><b>2022-04-06 13:51:47</b>: I think this would be a good small creative thing I could do on a regular basis. I have added it to my agenda list.
</p>
</blockquote>
</p>

<h2>create limit</h2>

<a id="3f1d0bba"></a><p>UUID: <a href="#3f1d0bba">#3f1d0bba</a>.
</p>
<blockquote>
</blockquote>
</p>

<h2>create cabtmp</h2>

<a id="f6125d13"></a><p>UUID: <a href="#f6125d13">#f6125d13</a>.
</p>
<blockquote>
</blockquote>
</p>

<h2>create ANSI C version of KBVerb</h2>

<a id="33b2d86a"></a><p>UUID: <a href="#33b2d86a">#33b2d86a</a>.
</p>
<blockquote>
<p><b>2021-12-02 09:53:52</b>: I have FAUST generated C code. going to poke at this for a bit, see if I can't rework this.
</p>
</blockquote>
</p>

<h2>convert chowkick into sndkit node</h2>

<a id="31a59826"></a><p>UUID: <a href="#31a59826">#31a59826</a>.
</p>
<p>chowkick is a kick plugin under a BSD license. it would be neat to extract the core DSP code from the JUCE plugin code, wrap it into a sndkit node, and then reduce the C++ code into ANSI C.
</p>
<blockquote>
<p><b>2021-09-10 09:32:14</b>: clearly, this kick is not something I am going to have time for this month. will have to push aside for now.
</p>
<p><b>2021-09-10 09:22:53</b>: added the chowdsp utilities, which is where I think the WDF utilities are.
</p>
<p><b>2021-09-10 09:16:40</b>: the pulseshaper has all the circuit stuff. uses WDFs from another project I think.
</p>
<p><b>2021-09-10 09:10:13</b>: chowkick outfilter
</p>
<p><b>2021-09-10 09:09:42</b>: chowkick resonantfilter
</p>
<p><b>2021-09-10 09:09:10</b>: chowkick pulseshaper
</p>
<p><b>2021-09-10 09:08:50</b>: chowkick trigger
</p>
<p><b>2021-09-10 09:06:55</b>: ah okay. I don't think I'll need to compile this code. the DSP bits are quite simple. trigger goes into pulseshaper which goes into resonate filter, which goes into an 'outputfilter' and then a DC blocker. there's also work to account for polyphony. this will be discarded.
</p>
<p><b>2021-09-10 09:02:00</b>: peaking at the code. seeing if I can get the DSP code to compile without the JUCE plugin bits.
</p>
</blockquote>
</p>

<h3>chowkick trigger</h3>

<a id="3667e868"></a><p>UUID: <a href="#3667e868">#3667e868</a>.
</p>
<blockquote>
<p><b>2021-09-10 09:24:25</b>: this is going to have to be rewritten. from what I see so far, this looks like a thing that takes MIDI signals and turns them into gate signals. for the pulseshaper.
</p>
</blockquote>
</p>

<h3>chowkick pulseshaper</h3>

<a id="e5d0f6b3"></a><p>UUID: <a href="#e5d0f6b3">#e5d0f6b3</a>.
</p>
<blockquote>
<p><b>2021-09-10 09:25:30</b>: this is the most complicated bit, and is where the WDFs are. the best course of action here is to reduce the C++ code to a point where it builds okay on my system, then reduce to C.
</p>
</blockquote>
</p>

<h3>chowkick resonantfilter</h3>

<a id="3367c482"></a><p>UUID: <a href="#3367c482">#3367c482</a>.
</p>
<blockquote>
<p><b>2021-09-10 09:25:53</b>: this resonant filter looks like a biquad at first glance.
</p>
</blockquote>
</p>

<h3>chowkick outfilter</h3>

<a id="76b11e01"></a><p>UUID: <a href="#76b11e01">#76b11e01</a>.
</p>
<blockquote>
<p><b>2021-09-10 09:27:19</b>: another biquad, possibly a lowpass filter from the looks of it.
</p>
</blockquote>
</p>

<h2>port hexwave into sndkit</h2>

<a id="5b744390"></a><p>UUID: <a href="#5b744390">#5b744390</a>.
</p>
<p>it's a really neat sounding technique and is part of the stb library collection, so it is public domain.
</p>
<blockquote>
<p><b>2021-12-02 09:54:39</b>: now that (<a href="/wiki/sndkit">sndkit</a>) has an extras folder, I could basically drop this in now.
</p>
<p><b>2021-08-03 08:52:41</b>: code: <a href="https://github.com/nothings/stb/blob/master/stb_hexwave.h">https://github.com/nothings/stb/blob/master/stb_hexwave.h</a>.
</p>
<p><b>2021-08-03 08:52:29</b>: demo video <a href="https://www.youtube.com/watch?v=hsUCrAsDN-M">https://www.youtube.com/watch?v=hsUCrAsDN-M</a></p>
</blockquote>
</p>

<h2>port soundpipe to sndkit</h2>

<a id="8222e6fc"></a><p>UUID: <a href="#8222e6fc">#8222e6fc</a>.
</p>
<p>this is a long-term task. I eventually want every module in soundpipe available in sndkit. Some will be ported to public domain literate programs, others will just be C code with an MIT license.
</p>
<blockquote>
<p><b>2021-07-26 20:38:53</b>: maybe someday Ill have a voc redux as an improvement to <a href="/sndkit/tract">tract</a>.
</p>
<p><b>2021-07-26 20:36:44</b>: stuff that I think I could port without issue: adsr, butterworth filters, clamp, clock, compressor, crossfade, delay, diode, dmetro, expon, line, loadwav, maygate, noise, paulstretch, peaklim, randh, saturator, scrambler, tadsr, tdiv, tenv, tenv2, tenvx, tgate, thresh, tseq...
</p>
<p><b>2021-07-26 20:34:22</b>: ones that aren't worth holding onto or are FAUST-based: autowah (FAUST), bitcrush (needs to be re-written), bl-stuff (faust, also blep replaces them), count (too basic/weird), dtrig, incr, jcrev (FAUST), nsmp, phaser, prop (!gest works better), randmt, random, reverse, sdelay, spa, sparec, tread, zitarev (FAUST)
</p>
<p><b>2021-07-26 20:31:18</b>: loosely glancing at the soundpipe folder the ones that stick out are: pinknoise, brown, talkbox, verbity, lpc.
</p>
<p><b>2021-07-26 20:29:12</b>: FAUST-derived stuff is not getting ported, unless I can reverse engineer them (but I do not intend to). some of my old stuff is a bit silly and not worth keeping. When you factor those out, there's very little that will remain as "code only".
</p>
</blockquote>
</p>

<h2>make a boilerplate function that frees cables and frees data for nodes</h2>

<a id="a8b39cbf"></a><p>UUID: <a href="#a8b39cbf">#a8b39cbf</a>.
</p>
<p>the destroy function in patchwerk is used so frequently that it would be worth creating a wrapper around it. Also, maybe memory allocation stuff as well?
</p>
<blockquote>
</blockquote>
</p>

<h2>create bitcrush algo</h2>

<a id="f2945ac3"></a><p>UUID: <a href="#f2945ac3">#f2945ac3</a>.
</p>
<p>the current soundpipe module is broken and not worth repair (totalled). it would be better to build another one from scratch.
</p>
<blockquote>
<p><b>2021-03-30 22:01:20</b>: should downsampling be a normalized value so that it can be sample-rate independant? I'm going to say no for now because the soundpipe bitcrush wasn't.
</p>
<p><b>2021-03-30 21:59:02</b>: yeah. I think that makes sense. bit depth all comes down to reducing noise floor. and noise floor happens as you strip away bits that are LSB. it was just a bit counter-intuitive for me for some reason.
</p>
<p><b>2021-03-30 21:56:52</b>: bit reduction can be done with a shift I think? but is it really about losing LSBs?
</p>
<p><b>2021-03-30 21:53:58</b>: downsampling is done via a sample and hold. the counter can be managed using a phasor. aliasing is desired.
</p>
<p><b>2021-03-30 21:51:29</b>: a bitcrusher actually does two things: it truncates the bit depth, and it downsamples. Both are done in an intentionally crude way.
</p>
</blockquote>
</p>

<h2>add error codes to sndkit core</h2>

<a id="317b788d"></a><p>UUID: <a href="#317b788d">#317b788d</a>.
</p>
<p>it is going to be difficult to know what goes wrong when things go wrong. adding specific error codes with canned messages will make life easier.
</p>
<blockquote>
</blockquote>
</p>

<h2>cflooper</h2>

<a id="a1e9dfbb"></a><p>UUID: <a href="#a1e9dfbb">#a1e9dfbb</a>.
</p>
<p>a cross-fade looping sampler with adjustable crossfade times and pitch control.
</p>
<blockquote>
<p><b>2022-03-14 09:21:11</b>: holding off for now. looped pad sounds just aren't all that important to me right now, plus I already have a way to do it in one go.
</p>
<p><b>2022-03-07 09:07:27</b>: I recently tried to do a crossfade delay line, so I've been thinking about crossfades. That effort failed, but maybe there are some insights here.
</p>
<p><b>2021-01-31 10:59:19</b>: If I can't figure out continuous adjustment, having something that dynamically produces a crossfade at run-time is good enough I guess. Since I added (<a href="/wiki/crate">crate</a>), I've been able to mess around with samples before and being able to turn any sound into a seamless texture is exciting to me.
</p>
<p><b>2021-01-31 10:57:38</b>: I already have a static crossfade loop generator (<a href="/wiki/cfloop">cfloop</a>). I want this one to have seamlessly adjustable crossfade looping abilities. Being able to do that continuously without clicks is what is interesting to me. I'm sure there may be a clever way to do this, I just haven't figured it out.
</p>
</blockquote>
</p>

<h2>stringer</h2>

<a id="706c040c"></a><p>UUID: <a href="#706c040c">#706c040c</a>.
</p>
<p>stringer is a string resonator filter
</p>
<blockquote>
<p><b>2021-07-10 08:03:24</b>: I miss having something like this.
</p>
</blockquote>
</p>

<h2>FM4</h2>

<a id="76f74cad"></a><p>UUID: <a href="#76f74cad">#76f74cad</a>.
</p>
<p>a 4 operator FM voice designed to be highly flexible.
</p>
<blockquote>
<p><b>2021-07-23 20:24:51</b>: pushing this aside for a while I guess.
</p>
<p><b>2021-02-12 09:40:03</b>: I want this FM oscillator to be keep me interested for a while. Each operator should be able to take in wavetables of arbitrary size. I should also be able to morph between an arbitrary set of wavetables, possibly with arbitray sizes. Feedback control will be a global knob. Since I want different configurations, it seems like any other solution would be too messy.
</p>
</blockquote>
</p>

<h2>port plateau DSP to patchwerk node</h2>

<a id="b24e17bf"></a><p>UUID: <a href="#b24e17bf">#b24e17bf</a>.
</p>
<p>see playground/plateau for more deets. the idea is to get the original C++ running, then to make a version of it in ANSI C later.
</p>
<blockquote>
</blockquote>
</p>

<h2>valp4</h2>

<a id="48eecf9c"></a><p>UUID: <a href="#48eecf9c">#48eecf9c</a>.
</p>
<p>valp4 is a Virtual-Analogue Low-Pass 4-pole filter
</p>
<blockquote>
<p><b>2022-04-06 13:57:11</b>: not really doing much subtractive synthesis, though it is a cool filter to have around. I'm afraid this is low priority now.
</p>
<p><b>2022-03-09 08:52:04</b>: the filter I believe that is going to be ported here is the Diode Ladder filter, described at the end of chater 5 of the art of VA filter design. Section 5.10, pg 164 (PDF page 176).
</p>
<p><b>2021-07-23 20:35:37</b>: this feels less pressing to me, so I'm removing it from the list. wavetables and FM and phase distortion is more interesting to me anyways.
</p>
<p><b>2021-07-05 12:17:33</b>: I also want to consult Zavalishin again, and try to see if I can grok the TPT stuff. I seem to recall things making sense at one point for <a href="/sndkit/valp1">valp1</a>. Hopefully I can understand things again, and keep it long enough in my head to write it down!
</p>
<p><b>2021-07-05 12:13:48</b>: it seems nonmateria has done the heavy lifting of porting Pirkle's C++ code to C: <a href="https://codeberg.org/nonmateria/folderkit/src/branch/main/src/dsp/va_filter.c">https://codeberg.org/nonmateria/folderkit/src/branch/main/src/dsp/va_filter.c</a>. I may end up turning this into a more generic <code>vafilt</code> that can be configured for different filter types, similar to how <a href="/sndkit/blep">blep</a> is configured for different waveforms.
</p>
<p><b>2021-03-02 14:00:28</b>: this needs to be examined more closely. similar to growl or <a href="/sndkit/bigverb">bigverb</a>, this has a lot of underlying components.
</p>
<p><b>2021-02-12 09:19:23</b>: I wrote a comment about this, but on the wrong task. will pirkle has a C++ implementation that is worth examining. It is from the same Art of VA filter design book. My version would ported to ANSI C, and of course would give credit to Pirkle.
</p>
</blockquote>
</p>

<h2>paulstretch</h2>

<a id="4482dab5"></a><p>UUID: <a href="#4482dab5">#4482dab5</a>.
</p>
<p>an implementation of the famous paulstretch algorithm. this code already exists in soundpipe, it just needs to be rewritten as a literate program.
</p>
<blockquote>
<p><b>2022-03-13 10:28:39</b>: to speed things along, I am making a paulstretch branch with a boilerplate org file
</p>
</blockquote>
<hr>
<p><a href="/wiki/">home</a> | <a href="/wiki/wiki_index">index</a></div>
</body>
</html>
