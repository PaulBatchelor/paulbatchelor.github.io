<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/css/style.css">

</head>
<body>
<div id="main">
<title>sndkit TODO</title>
<h1>sndkit TODO</h1>
<p>A dynamically generated list of public-facing TODO items for
<a href="/wiki/sndkit">sndkit</a>. The TODO list is managed using this
wiki's <a href="/wiki/zetdo">zetdo</a>, using the state <code>TODO-sndkit</code>.
</p>
<p></p>

<h3>create fixed-point phasor page.</h3>

<p>this component is used so frequently, it would be helpful to have an informational page about this.
<blockquote>
<b>2021-02-07 10:16:16</b>: lots of older computer music algorithms use fixed point precision phasors, and I have no intention of updating those to be floating point. what I'm interested in is: is it worth the trouble using fixed point on new algorithms?
</p>
<p><b>2021-02-07 10:15:17</b>: I've been saying that it is less prone to weird numerical errors compared to floating point. I don't know how true that actually is. Will look into it.
</p>
<p><b>2021-02-07 10:14:37</b>: I'm going to get to the bottom of this: is a fixed point phasor actually meaningful in any way on modern hardware and compilers?
</p>
</blockquote>
</p>

<h3>brainstorm and scope out initial sndkit API</h3>

<p>this would be a C API built on top of patchwerk that would make it easy-ish to build things with sndkit algos in C. The hope is to build language bindings on top of this for (<a href="/wiki/LIL">LIL</a>).
<blockquote>
</blockquote>
</p>

<h3>create page that explains what is meant by *normalized range*.</h3>

<p>the concept of a normalized range keeps coming up consistently, and it would be good to have a page that explains what it is and why it is important.
<blockquote>
</blockquote>
</p>

<h3>create parameter caching page</h3>

<p>create a informational wiki page in sndkit that explains what is meant by the term <b>parameterized caching</b>.
<blockquote>
</blockquote>
</p>

<h3>biramp</h3>

<p>biramp is a process that takes a phasor ramp signal, and converts it to a bidirectional ramp with adjustable position.
<blockquote>
<b>2021-01-30 11:36:18</b>: most of the words/logic have been written. now it's just code.
</p>
<p><b>2021-01-30 11:36:05</b>: biramp is a utility that adds turns an incoming phasor signal into a bidirectional ramp.
</p>
</blockquote>
</p>

<h3>clkphs</h3>

<p>given a clock signal, produce an approximate phasor signal.
<blockquote>
<b>2021-01-30 16:39:15</b>: I do have words written up for this. It's definitely been a less important thing to do over time.
</p>
</blockquote>
</p>

<h3>sparsenoise</h3>

<p>sparsenoise is will fire off random impulses. pretty much velvet noise I think?
<blockquote>
</blockquote>
</p>

<h3>use pikchr to draw diagrams in sndkit</h3>

<blockquote>
</blockquote>

<h3>clock-synced delay</h3>

<p>this is basically a variable delay line that stays in sync via an external clock signal.
<blockquote>
</blockquote>
</p>

<h3>stringer</h3>

<p>stringer is a string resonator filter
<blockquote>
</blockquote>
</p>

<h3>highshelf</h3>

<p>high shelf filter based on the audio EQ cookbook
<blockquote>
</blockquote>
</p>

<h3>lowshelf</h3>

<p>low shelf filter based on the audio EQ cookbook
<blockquote>
<b>2021-01-31 11:02:47</b>: from an educational standpoint, it might be useful to structure the writeup so that it starts with the math equation, and ends up in C code.
</p>
<p><b>2021-01-31 11:02:09</b>: all it is is a biquad filter with the right coefficients. The coefficients would come from the audio EQ cookbook, which I've already rewritten in TeX for myself. Those could be a nice part of the page.
</p>
<p><b>2021-01-31 11:01:08</b>: a low shelf filter is more useful to me than a high shelf filter right now, so this comes first.
</p>
</blockquote>
</p>

<h3>valp4</h3>

<p>valp4 is a Virtual-Analogue Low-Pass 4-pole filter
<blockquote>
</blockquote>
</p>

<h3>paulstretch</h3>

<p>an implementation of the famous paulstretch algorithm. this code already exists in soundpipe, it just needs to be rewritten as a literate program.
<blockquote>
</blockquote>
</p>

<h3>cflooper</h3>

<p>a cross-fade looping sampler with adjustable crossfade times and pitch control.
<blockquote>
<b>2021-01-31 10:59:19</b>: If I can't figure out continuous adjustment, having something that dynamically produces a crossfade at run-time is good enough I guess. Since I added (<a href="/wiki/crate">crate</a>), I've been able to mess around with samples before and being able to turn any sound into a seamless texture is exciting to me.
</p>
<p><b>2021-01-31 10:57:38</b>: I already have a static crossfade loop generator (<a href="/wiki/cfloop">cfloop</a>). I want this one to have seamlessly adjustable crossfade looping abilities. Being able to do that continuously without clicks is what is interesting to me. I'm sure there may be a clever way to do this, I just haven't figured it out.
</p>
</blockquote>
</p>

<h3>jitseg</h3>

<p>jitseg hopes to be a jitter signal generator
<blockquote>
<b>2021-02-07 09:53:08</b>: jitseg is actually a very small algorithm that will end up being under 100 lines of C. shouldn't be too hard to right about. the most complex part is the internal RNG to write about.
</p>
<p><b>2021-01-31 10:53:50</b>: there is some initial working code for this. maybe even a few words and outlines.
</p>
</blockquote>
<hr>
<p><a href="/wiki/">home</a> | <a href="/wiki/wiki_index">index</a></div>
</body>
</html>
