<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/css/style.css">

</head>
<body>
<div id="main">
<title>GTick</title>
<h1>GTick</h1>

<h2>Overview</h2>

<p>The <code>GTick</code> algorithm has but one purpose: take in a
gate signal, and return a tick signal.
</p>
<p>Gate signals, such as those generated by <a href="/sndkit/tgate">tgate</a>,
are signals that are either off (0) or on (1, or non-zero).
Tick signals, such as those generated by <a href="/sndkit/metro">metro</a> or <a href="/sndkit/phsclk">phsclk</a>, can be thought of as
impulse streams, and produce "tick" values, single-sample
non-zero impulses, that can be used as clock sources to
trigger things like <a href="/sndkit/tenv">tenv</a>, <a href="/sndkit/trand">trand</a>,
or <a href="/sndkit/tgate">tgate</a>.
</p>
<p>In many situations, it can be very difficult to produce
a tick signal that is guaranteed to be 1 sample long.
Meanwhile, a gate signal is a much more approachable kind
of signal to make.
</p>

<h2>Tangled Files</h2>

<div><b><i>&lt;&lt;gtick.h&gt;&gt;=</i></b></div><pre><code>#ifndef SK_GTICK_H
#define SK_GTICK_H

#ifndef SKFLT
#define SKFLT float
#endif

&lt;&lt;typedefs&gt;&gt;

#ifdef SK_GTICK_PRIV
&lt;&lt;structs&gt;&gt;
#endif

&lt;&lt;funcdefs&gt;&gt;

#endif</pre></code>
<p></p>
<div><b><i>&lt;&lt;gtick.c&gt;&gt;=</i></b></div><pre><code>#define SK_GTICK_PRIV
#include "gtick.h"
&lt;&lt;funcs&gt;&gt;</pre></code>

<h2>Struct</h2>

<p><code>sk_gtick</code>.
</p>
<div><b><i>&lt;&lt;typedefs&gt;&gt;=</i></b></div><pre><code>typedef struct sk_gtick sk_gtick;</pre></code>
<p></p>
<div><b><i>&lt;&lt;structs&gt;&gt;=</i></b></div><pre><code>struct sk_gtick {
    SKFLT prev;
};</pre></code>

<h2>Init</h2>

<p><code>sk_gtick_init</code>.
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>void sk_gtick_init(sk_gtick *gt);</pre></code>
<p></p>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>void sk_gtick_init(sk_gtick *gt)
{
    gt-&gt;prev = 0;
}</pre></code>

<h2>Compute</h2>

<p>A single sample of <code>gtick</code> is computed with
<code>sk_gtick_tick</code>. It expects as an input a gate signal.
</p>
<div><b><i>&lt;&lt;funcdefs&gt;&gt;=</i></b></div><pre><code>SKFLT sk_gtick_tick(sk_gtick *gt, SKFLT in);</pre></code>
<p></p>
<p>A tick signal is only produced what a gate transitions
from off to on (in Electrical Engineering terms, they
sometimes might say it goes from LOW to HIGH). It does
this by keeping track of the previous sample.
</p>
<p>A gate signal must transition from on to off before it
can be ready to produce another tick again.
</p>
<div><b><i>&lt;&lt;funcs&gt;&gt;=</i></b></div><pre><code>SKFLT sk_gtick_tick(sk_gtick *gt, SKFLT gate)
{
    SKFLT out;
    out = 0;

    if (gate &gt; 0 && gt-&gt;prev &lt;= 0) {
        out = 1;
    }

    gt-&gt;prev = gate;

    return out;
}</pre></code>
</div>
</body>
</html>
